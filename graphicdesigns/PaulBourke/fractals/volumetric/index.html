<html>
<head>
<link rel=StyleSheet href="../../pdbstyle.css" type="text/css" media=all>
<title>Volumetric fractals</title>
</head>
<body>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<script language="JavaScript">
<!--
   if (self.location.href != top.location.href) {
      top.location.href = self.location.href;
   }
-->
</script>


<center><table width=800><tr><td>

<center>
<h1>Bedouin Fractal</h1>
Created by <a href="../index.html">Paul Bourke</a><br>
Attributed to Russell Walsmith<br>
April 2016<p>
See also: <a href="../../papers/joc2017/index.html">Visualising volumetric fractals</a>
</center>
<p><br><p>

<p align="justify">
This is created by considering each point within some region of 3D space
(x<sub>0</sub>,y<sub>0</sub>,z<sub>0</sub>) and evaluating the following
series. The point (voxel in computer graphics language) is then assigned a
scalar quantity depending on how quickly the series tends to infinity.
</p>

<center>
x<sub>n+1</sub> = a + sin(x<sub>0</sub>)<br>
y<sub>n+1</sub> = b + sin(y<sub>0</sub>)<br>
z<sub>n+1</sub> = c + sin(z<sub>0</sub>)<br>
</center>
<p>

where<p>

<center>
a = x<sub>n</sub><sup>2</sup> - y<sub>n</sub><sup>2</sup> - z<sub>n</sub><sup>2</sup><br>
b = 2 x<sub>n</sub> z<sub>n</sub><br>
c = 2 x<sub>n</sub> y<sub>n</sub><br>
</center>
<p>

<p align="justify">
Rendering here done using custom code to create the volumes and then the Drishti
volume rendering software for the final graphics.
The rendering technique
is traditional volume rendering which includes assignment of both colour and opacity
dependent on the voxel scalar quantity and also the estimate of local
gradient to create a surface for the a lighting model.
</p>

<center>
<a href="bedouin_a.png">
<img src="bedouin_as.png" width=800 height=800 border=1></a>
</center><p>
<p><br><p>

<p align="justify">
The range for which the interesting part of the model exists is -1.5 to 1.5 on all three
axes. The first three renders here sample that volume 1024 times on each axis between
the bounds above, so approximately 340 samples per unit distance.
</p>

<center>
<a href="bedouin_b.png">
<img src="bedouin_bs.png" width=800 height=800 border=1></a>
</center><p>
<p><br><p>

<center>
<a href="bedouin_c.png">
<img src="bedouin_cs.png" width=800 height=800 border=1></a>
</center><p>
<p><br><p>

<p align="justify">
The next 2 images are a further 3 times zoom factor, namely 1000 sample per unit distance.
</p>

<center>
<a href="bedouin_d.png">
<img src="bedouin_ds.png" width=800 height=566 border=1></a>
</center><p>
<p><br><p>

<center>
<a href="bedouin_e.png">
<img src="bedouin_es.png" width=800 height=701 border=1></a>
</center><p>

<p><br><br><p>


<center>
<h1>Real number MSet</h1>
Attributed to Russell Walsmith<br>
Written by <a href="../index.html">Paul Bourke</a><br>
November 2006
</center>
<p><br><p>

<table width=100%><tr><td valign="top">
<pre>
int Eval(double cx,double cy,double cz,int nmax)
{
   int n = 0;
   double x1 = 0,y1 = 0,z1 = 0;
   double x2,y2,z2,zz = 0;

   while (zz < 8 && n < nmax) {
      x2 = x1 * x1 - y1 * y1 - z1 * z1 + cx;
      y2 = 2 * x1 * y1 + cy;
      z2 = 2 * x1 * z1 + cz;
      x1 = x2;
      y1 = y2;
      z1 = z2;
      n++;
      zz = x1 * x1 + y1 * y1 + z1 * z1;
   }

   return(n);
}
</pre>
</td><td valign="top" align="right">
	<a href="realmset_06.png"><img src="realmset_06_s.gif" width=300 height=329 border=1></a>
</td></tr></table>
<p><br><p>

<center><img src="realmset_05.png" width=800 height=600 border=1></center><p>
<p><br><p>

<center><img src="realmset_09.png" width=800 height=600 border=1></center><p>
<p><br><p>
<center><img src="realmset_10.png" width=800 height=800 border=1></center><p>

<p><br><br>

<center><table width=100%><tr><td valign="top">
<h1>Quinternions</h1>
Attributed to Russell Walsmith<br>
Written by <a href="../index.html">Paul Bourke</a><br>
August 2005
<p><br><p>

<p align="justify">
The images shown here are based upon quinternion arithmetic and 
are created in a similar way to the Mandelbrot set. That is,
a function is iterated with some dependency on a position on the complex plane.
The outcome of the series (infinity, zero, or
otherwise) determines the state of that position and ultimately how it is
represented graphically. 
Generally the distinction
is made between the series tending to zero (inside the set) and other
behaviour (outside the set). 
</p>

<p align="justify">
The difference here is the
function being iterated is not in the complex plane but rather in five
dimensions. To determine whether the position in 5D is inside or outside
the set, a test is made whether the magnitude of the series (a 5 dimensional
vector)
tends to zero. The result, as shown in the images on the right is a Mandelbrot
like outline, extruded in 3D space over some limited range. In these image the 
first three dimensions are mapped to 3D Cartesian coordinates and the last
two dimensions are fixed at one value, a point in the plane of the last two
dimensions.
</p>

The series in five dimensions is given by<br>
&nbsp;&nbsp;&nbsp;x<sub>n+1</sub> = a + x<sub>0</sub><br>
&nbsp;&nbsp;&nbsp;y<sub>n+1</sub> = b + y<sub>0</sub><br>
&nbsp;&nbsp;&nbsp;z<sub>n+1</sub> = c + z<sub>0</sub><br>
&nbsp;&nbsp;&nbsp;u<sub>n+1</sub> = d + u<sub>0</sub><br>
&nbsp;&nbsp;&nbsp;v<sub>n+1</sub> = e + v<sub>0</sub><br>
where<br>
&nbsp;&nbsp;&nbsp;a = x<sub>n</sub><sup>2</sup> + 2 (y<sub>n</sub>v<sub>n</sub> + z<sub>n</sub>u<sub>n</sub>)<br>
&nbsp;&nbsp;&nbsp;b = u<sub>n</sub><sup>2</sup> + 2 (x<sub>n</sub>y<sub>n</sub> + z<sub>n</sub>v<sub>n</sub>)<br>
&nbsp;&nbsp;&nbsp;c = y<sub>n</sub><sup>2</sup> + 2 (x<sub>n</sub>z<sub>n</sub> + u<sub>n</sub>v<sub>n</sub>)<br>
&nbsp;&nbsp;&nbsp;d = v<sub>n</sub><sup>2</sup> + 2 (x<sub>n</sub>u<sub>n</sub> + y<sub>n</sub>z<sub>n</sub>)<bR>
&nbsp;&nbsp;&nbsp;e = z<sub>n</sub><sup>2</sup> + 2 (x<sub>n</sub>v<sub>n</sub> + y<sub>n</sub>u<sub>n</sub>)<br>
where (x<sub>0</sub>,y<sub>0</sub>,z<sub>0</sub>,u<sub>0</sub>,v<sub>0</sub>) 
is the point in question.
<p>

<p><br><p>
<b>C style code to evaluate the quinternion</b>
<pre>
int Eval(double *q,int nmax)
{
   int i,n=0;
   double a[5],q1[5] = {0,0,0,0,0};
   double zz = 0;
   
   while (zz &lt; 100 && n &lt; nmax) {
      a[0] = q1[0]*q1[0]+2*(q1[1]*q1[4]+q1[2]*q1[3]);
      a[1] = q1[3]*q1[3]+2*(q1[0]*q1[1]+q1[2]*q1[4]);
      a[2] = q1[1]*q1[1]+2*(q1[0]*q1[2]+q1[3]*q1[4]);
      a[3] = q1[4]*q1[4]+2*(q1[0]*q1[3]+q1[1]*q1[2]);
      a[4] = q1[2]*q1[2]+2*(q1[0]*q1[4]+q1[1]*q1[3]);
      zz = 0; 
      for (i=0;i<&lt;5;i++) {
         q1[i] = a[i] + q[i];
         zz += q1[i] * q1[i];
      }
      n++;
   }

   return(n);
}
</pre>

</td><td valign="top">
<img src="quinternion_sample1.jpg" width=500 height=500><p>
<img src="quinternion_sample2.jpg" width=500 height=500><p>
<img src="quinternion_sample3.jpg" width=500 height=500><p>
</td></tr></table></center>

<center><table width=90%><tr><td valign="top">
<tr><td>
<img src="quinternion_small1.jpg" width=268 height=268>
</td><td>
<img src="quinternion_small2.jpg" width=268 height=268>
</td><td>
<img src="quinternion_small3.jpg" width=268 height=268>
</td></tr>
</table></center>


<center><img src="quinternion_1.png" width=800 height=600 border=1></center><p>
<center><img src="quinternion_2.png" width=800 height=600 border=1></center><p>
<center><img src="quinternion_3.png" width=800 height=600 border=1></center><p>

<p><br><br>

<center>
<h1>sine-mset</h1>
Created by <a href="../index.html">Paul Bourke</a><br>
Attributed to Russell Walsmith<br>
January 2007
</center>
<p><br><p>

<p align="justify">
This is created by considering each point within some region of 3D space
(x<sub>0</sub>,y<sub>0</sub>,z<sub>0</sub>) and evaluating the following
series. The point (voxel in computer graphics language) is then shaded/coloured
depending on how quickly the series tends to infinity.
</p>

<center>
x<sub>n+1</sub> = a + sin(x<sub>0</sub>)<br>
y<sub>n+1</sub> = b + sin(y<sub>0</sub>)<br>
z<sub>n+1</sub> = c + sin(z<sub>0</sub>)<br>
</center>
<p>

where<p>

<center>
a = x<sub>n</sub><sup>2</sup> + 2 y<sub>n</sub> z<sub>n</sub><br>
b = z<sub>n</sub><sup>2</sup> + 2 x<sub>n</sub> y<sub>n</sub><br>
c = y<sub>n</sub><sup>2</sup> + 2 x<sub>n</sub> z<sub>n</sub><br>
</center>
<p>

<center>
<a href="sinemset1.jpg">
<img src="sinemset1s.jpg" width=600 height=458 border=1></a>
</center><p>

<center>
<a href="sinemset2.jpg">
<img src="sinemset2s.jpg" width=600 height=458 border=1></a>
</center><p>

<center>
<a href="sinemset3.jpg">
<img src="sinemset3s.jpg" width=600 height=458 border=1></a>
</center><p>

<center>
<a href="sinemset4.jpg">
<img src="sinemset4s.jpg" width=600 height=458 border=1></a>
</center><p>

<center>
<a href="sinemset6.jpg">
<img src="sinemset6s.jpg" width=600 height=458 border=1></a>
</center><p>

<p><br><br>

<center>
<h1>Triternions</h1>
Attributed to Russell Walsmith<br>
Written by <a href="../index.html">Paul Bourke</a><br>
August 2005, Update: Oct 2014
</center>
<p><br><p>

<p align="justify">
The images shown here are based upon triternion arithmetic and 
are created in a similar way to the Mandelbrot set. That is,
a function is iterated with some dependency on a position on the complex plane.
The outcome of the series (infinity, zero, or
otherwise) determines the state of that position and ultimately how it is
represented graphically. 
Generally the distinction
is made between the series tending to zero (inside the set) and other
behaviour (outside the set). 
</p>

<center><img src="triternion_sample2.png" width=800 height=600 border=1></center><p>

<p align="justify">
The difference here is the
function being iterated is not in the complex plane but rather in three
dimensions. To determine whether the position in 3D is inside or outside
the set, a test is made whether the magnitude of the series (a vector) in 3D
tends to zero. The result, as shown in the images is a Mandelbrot
like outline, extruded in 3D space over some limited range.
</p>

<center><img src="triternion_sample4.png" width=800 height=600 border=1></center><p>

The series in three dimensions is given by<br>
&nbsp;&nbsp;&nbsp;x<sub>n+1</sub> = a + x<sub>0</sub><br>
&nbsp;&nbsp;&nbsp;y<sub>n+1</sub> = b + y<sub>0</sub><br>
&nbsp;&nbsp;&nbsp;z<sub>n+1</sub> = c + z<sub>0</sub><br>
where<br>
&nbsp;&nbsp;&nbsp;a = x<sub>n</sub><sup>2</sup> + 2 y<sub>n</sub> z<sub>n</sub><br>
&nbsp;&nbsp;&nbsp;b = z<sub>n</sub><sup>2</sup> + 2 x<sub>n</sub> y<sub>n</sub><br>
&nbsp;&nbsp;&nbsp;c = y<sub>n</sub><sup>2</sup> + 2 x<sub>n</sub> z<sub>n</sub><br>
and (x<sub>0</sub>,y<sub>0</sub>,z<sub>0</sub>) is the point in
question.
<p>

<center><img src="triternion_sample1.png" width=800 height=600 border=1></center><p>

<p align="justify">
In the images shown here
the bounds of the cube shown is -1.75 to 0.75 in each dimension.
</p>

<b>FracInt code by Russell Walsmith</b>
<pre>
; The reduced Tset formula
Frm4 {
   x=real(pixel), y=imag(pixel), z=p1
   x1=y1=z1=0:
   a = x1^2 + 2*y1*z1
   b = z1^2 + 2*x1*y1
   c = y1^2 + 2*x1*z1
   x1 = a+x, y1 = b+y, z1 = c+z
   s = x1^2 + y1^2 + v1^2
   s &lt; 100 
}
</pre>

<b>C style code to evaluate the triternion</b>
<pre>
int Eval(double x,double y,double z,int nmax)
{  
   int n = 0;
   double x1 = 0,y1 = 0,z1 = 0;
   double a,b,c;
   double zz = 0;
   
   while (zz &lt; 100 && n &lt; nmax) {
      a = x1*x1 + 2*y1*z1;
      b = z1*z1 + 2*x1*y1;
      c = y1*y1 + 2*x1*z1;
      x1 = a + x;
      y1 = b + y;
      z1 = c + z;
      zz = x1*x1 + y1*y1 + z1*z1;
      n++;
   }
   
   return(n);
}
</pre>

<center><img src="triternion_sample3.png" width=800 height=600 border=1></center><p>
<br><br>

<b>Update Oct 2014</b><p>

<p align="justify">
Code to create a volume suitable for rendering with the Drishti
volume visualisation software, although any volume rendering package
could be used: <a href="triternion.c">triternion.c</a>
</p>

<center>
<a href="triternion_new1.jpg"><img src="triternion_new1s.jpg" width=800 height=892 border=1></a>
</center><p>

<p><br><br>

<center>
<h1>Danca Fractal</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
In conjunction with Marius-F Danca.<br>
March 2008<p>
See also: <a href="../../papers/joc2017/index.html">Visualising volumetric fractals</a>
</center>
<p><br><p>

<p align="justify">
The following images/visualisation are explorations of the series below, 
where z, c<sub>1</sub>, and c<sub>2</sub> are all complex.
</p>
<center>
z<sub>n+1</sub> = (z<sub>n</sub><sup>2</sup> + c<sub>1</sub>)<sup>2</sup> + c<sub>2</sub>
</center>
<p>

<b>Connectedness of Julia sets</b><br>
<center>
<a href="danca_figure1.png">
<img src="danca_figure1_smaller.png" width=600 height=600 border=1></a>
</center><p>

<b>3D forms resulting from slices of the 4D space by each axis plane (at the origin)</b><p>
<center><table><tr><td>
<a href="danca_figure3a.png"><img src="danca_figure3as.jpg" width=200 height=200 border=1></a>
</td><td>
<a href="danca_figure3b.png"><img src="danca_figure3bs.jpg" width=200 height=200 border=1></a>
</td><td>
<a href="danca_figure3c.png"><img src="danca_figure3cs.jpg" width=200 height=200 border=1></a>
</td><td>
<a href="danca_figure3d.png"><img src="danca_figure3ds.jpg" width=200 height=200 border=1></a>
</td></tr></table></center><p>

<b><a href="slices/index.html">Plane slices through each of the above 3D forms</a></b>
<p>

<b>Other images</b><p>
<center>
<a href="danca_sample1.jpg">
<img src="danca_sample1s.jpg" width=600 height=442 border=1></a>
</center><p>

<center>
<a href="danca_sample2.jpg">
<img src="danca_sample2s.jpg" width=600 height=442 border=1></a>
</center><p>

<center>
<a href="danca_figure2a.jpg">
<img src="danca_figure2a_small.jpg" width=600 height=600 border=1></a>
</center><p>

<center>
<a href="danca_figure2b.jpg">
<img src="danca_figure2b_small.jpg" width=600 height=600 border=1></a>
</center><p>

<b>Slices through 3D section</b><br>
<center>
<a href="danca_figure4.png">
<img src="danca_figure4_smaller.png" width=800 height=752 border=1></a>
</center><p>

</td></tr></table></center>
</body>
</html>

