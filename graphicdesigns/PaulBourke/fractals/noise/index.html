<html>
<head>
<link rel=StyleSheet href="../../pdbstyle.css" type="text/css" media=all>
<title>Noise, Perlin, 1/f Noise, Modelling planets</title>
</head>
<body>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<script language="JavaScript">
<!--
   if (self.location.href != top.location.href) {
      top.location.href = self.location.href;
   }
-->
</script>


<center><table width=800><tr><td>

<center>
<h1>Generating noise with different power spectra laws</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
October 1998<p>
</center>

<p><br><p>

<p align="justify">
There are many ways to characterise different noise sources, one is 
to consider the spectral density, that is, the mean square fluctuation
at any particular frequency and how that varies with frequency.
In what follows, noise will be generated that has spectral densities
that vary as powers of inverse frequency, more precisely, the power
spectra P(f) is proportional to 1 / f<sup>beta</sup> for beta &gt= 0.
When beta is 0 the noise is referred to white noise, when it is 2 it
is referred to as Brownian noise, and when it is 1 it normally referred to
simply as 1/f noise which occurs very often in processes found in nature.
</p>

<p align="justify">
White noise, beta = 0<br>
<center><img src="white.gif" width="491" height="133"></center>
</p>

<p align="justify">
Brownian noise, beta = 2<br>
<center><img src="brown.gif" width="489" height="130"></center>
</p>

<p align="justify">
Note: Brownian noise is most easily generated by integrating white noise.
</p>

<p align="justify">
If one plots the log(power) vs log(frequency) for noise with a 
particular beta value, the slope gives the value of beta. This leads to
the most obvious way to generate a noise signal with a particular beta.
One generates the power spectrum with the appropriate distribution and
then inverse fourier transforms that into the time domain, this technique
is commonly called the fBm method and is used to create many natural looking
fractal forms.
</p>

<p align="justify">
The basic method involves creating frequency components which have a
magnitude that is generated from a Gaussian white process and scaled
by the appropriate power of f. The phase is uniformly distributed on
0, 2pi. See the code at the end of this document for more precise details.
</p>

<p align="justify">
There is a relationship between the value of beta and the fractal dimension
D, namely, D = (5 - beta) / 2
</p>

<h3>Examples</h3>

<p align="justify">
The following are examples of noise time series generated as described.
They were all based upon the same initial seeds and therefore have the same
general "shape".
</p>

<p align="justify">
beta = 1<br>
<center><img src="noise10.gif" width="535" height="128"></center>
</p>

<p align="justify">
beta = 1.5<br>
<center><img src="noise15.gif" width="532" height="129"></center>
</p>

<p align="justify">
beta = 2, Brownian noise (random walk)<br>
<center><img src="noise20.gif" width="533" height="130"></center>
</p>

<p align="justify">
beta = 2.5<br>
<center><img src="noise25.gif" width="530" height="127"></center>
</p>

<p align="justify">
beta = 3<br>
<center><img src="noise30.gif" width="532" height="126"></center>
</p>

<h3>C Source</h3>

<p align="justify">
A straightforward C program is given <a href="gennoise.c">here</a> that 
generates a noise series with a particular beta value.
The RandomGaussian function returns a Gaussian white noise process
with zero mean and unity standard deviation. RandomUniform returns
a uniformly distributed noise process distributed between 0 to 1.
</p>


<p><br><br><br><p>


<center>
<h1>Deterministic 1/f noise</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
February 1999<p>
Listen to deterministic noise: <a href="deterministic.mov">QuickTime</a>
</center>
<p><br><p>

1/f noise can be created using random noise generators
but it can also be producted using deterministic functions.
One such method is a finite difference equation proposed
by I. Procaccia and H. Schuster. It is simply<p>
<center>x<sub>t</sub> = 
(x<sub>t-1</sub> + x<sub>t-1</sub><sup>2</sup>) mod 1</center>
<p>

A section of the time series is illustrated below.
<p><center><img src="time.gif"></center><p>

The power spectra is shown below.
<p><center><img src="spectra.gif"></center><p>

<p><b>References</b><p>
Schuster, H.G.  Deterministic Chaos - An Introduction.  Physik verlag, Weinheim, 1984
<p>

Procaccia, I. and Schuster, H.G.
Functional renormalisation group theory of universal 1/f noise
in dynamical systems.  Phys Rev 28 A, 1210-12 (1983)
<p>

<br><br><br>

<center>
<h1>Modelling fake planets</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
October 2000<p>
<a href="index_gr.html">Greek version</a> (Uses iso-8859-7 character set)
</center>
<p><br><p>

<p align="justify">
The following describes a method of creating realistic looking planetary
models. The technique has been known for some time and is both an elegant
and non-intuitive way of creating such fractal surfaces. 
The exact approach chosen here was to enable the
models to be used in a variety of rendering packages, as such it is based
upon facet approximations to a sphere. The same approach can readily be
modified to deal with other data structures.
</p>

<table cellspacing=0 cellpadding=0 width=100%>
<tr><td valign="top">
<p align="justify">
The basic approach is as follows: start is a sphere, on each iteration
choose a random vector, let this define a plane passing through the center
of the sphere, increase the elevation of all points on one side by some
small amount, decrease the elevation of all points on the other side by
the same small amount, .... , repeat lots of times.
</p>
<p align="justify">
In terms of the implementation, the test for whether a point on the surface
is on one side of the plane or the other just involves a dot product 
between the unit vector to the point on the surface and the unit normal.
Note also that since the vector to the points on the surface doesn't
change, the heights can be accumulated and the actual points transformed
at the end of the iterative process.
</p>
</td><td width=320 valign="top" align="right">
<img src="diagram.gif" width=300 height=316>
</td></tr></table>
<p>

The sequence is illustrated below.<p>

<table width=100%  cellspacing=0 cellpadding=0>
<tr><td valign="top">
<b>0</b><br>
This is a the initial perfectly smooth sphere, in this particular case
there are about 33000 triangular polygons.
</td><td valign="top">
<a href="0.html"><img src="0.gif" width=200 height=200></a>
</td></tr>

<tr><td valign="top">
<b>1</b><br>
In the first iteration a random plane is chosen by choosing a random
normal vector (the plane passes through the center of the sphere).
The points on one side are raised, those on the other side are lowered.
A Mars colour map is mapped onto height in this example.
</td><td valign="top">
<a href="1.html"><img src="1.gif" width=200 height=200></a>
</td></tr>

<tr><td valign="top">
<b>2</b><br>
The second iteration sees the process applied to a second randomly chosen
plane. There are now 3 different height values on the surface of the
sphere.
</td><td valign="top">
<a href="2.html"><img src="2.gif" width=200 height=200></a>
</td></tr>

<tr><td valign="top">
<b>3</b><br>
The third iteration.
</td><td valign="top">
<a href="3.html"><img src="3.gif" width=200 height=200></a>
</td></tr>

<tr><td valign="top">
<b>10</b><br>
The tenth iteration and things don't look terribly promising.
</td><td valign="top">
<a href="10.html"><img src="10.gif" width=200 height=200></a>
</td></tr>

<tr><td valign="top">
<b>100</b><br>
The one hundredth iteration and suddenly it is starting to look interesting.
Note that as with many fractal techniques, the surface is completely specified
by one number, that is, the original random number seed. A new surface is
created by changing the seed, old landscapes can be regenerated if their
seed is known.
</td><td valign="top">
<a href="100.html"><img src="100.gif" width=200 height=200></a>
</td></tr>

<tr><td valign="top">
<b>1000</b><br>
At one thousand iterations the line structure still apparent at 100
iterations has gone. In this case there isn't much point continuing
because of the relatively low resolution of the sphere tessellation.
</td><td valign="top">
<a href="1000.html"><img src="1000.gif" width=200 height=200></a>
</td></tr>
</table>
<p>

<b>Other examples</b>
<p align="justify">
The above example and the ones that follow were created in an interactive
OpenGL environment. While this leads to the ability to fly around and explore
the models, it does restrict the rendering quality. It will be left to
the reader to create more stunning images using their favorite rendering
package.
</p>
<center>
<a href="planet1.html"><img src="planet1.gif" width=200 height=200></a>
<a href="planet2.html"><img src="planet2.gif" width=200 height=200></a>
<a href="planet3.html"><img src="planet3.gif" width=200 height=200></a>
</center>
<p>

<b>Mirror effect</b><br>
<p align="justify">
An artifact of this method is that the planets have a mirror symmetry.
A contour at a high elevation on one side of the planet will have a matching
contour on the opposite side of the planet. In particular, if the planet
is flood filled to some level, the outline of the land on one side will
look the same as the outline of the water on the other side. This is
clearly seen in the example below, the ocean on the left matches (given
some mirror axes) the land on the opposite side of the planet as shown
on the right.
</p>
<center>
<a href="mirror1.html"><img src="mirror1.gif" width=200 height=200></a>
<a href="mirror2.html"><img src="mirror2.gif" width=200 height=200></a>
</center>
<p>

<table width=100% cellpadding=0 cellspacing=0>
<tr><td valign="top">
<p align="justify">
This artifact is
rarely noticed, if it is a problem then the restriction above where
the plane intersects the center of the planet can be lifted.
One not only randomly chooses a normal but also a scalar offset.
The usual approach is to displace the plane by the random offset
along the direction of the normal. This also seems to generate
better looking planets, the downside is that it takes more
iterations to reach a particular level of resolution.
</p>
</td><td width="435" valign="top" align="right">
<img src="diagram2.gif" width="415" height="328">
</td></tr></table>
<p>

<center>
<a href="method2a.html"><img src="method2a.gif" width=200 height=200></a>
<a href="method2b.html"><img src="method2b.gif" width=200 height=200></a>
</center>
<p>

<b>Source code</b><p>
<p align="justify">
An example application that implements the above is provided as simple
OpenGL based program written in C:
<a href="planet.c">planet.c</a> and <a href="planet.h">
planet.h</a>. These should form a good basis for you own experimentation.
For example, depending on the ability of your graphics card you might like to
increase the maximum sphere resolution, test out more realistic colour
maps, add cloud cover, etc. I'd be interested in seeing imagery resulting
from this exploration. This code also supports frame sequential stereo
if your OpenGL card supports it.....
To find out about the basic operation of this program, after compiling
it try "planet -h", this will give the command line options. The right
mouse button (aka GLUT) will give a bunch of randomly organised options.
</p>

<b>Contribution by Julien Amsellem for 3DStudioMax</b><p>

<table border="0" cellspacing="0" cellpadding="0" width=100%>
        <tr valign="top">
                <td>
                IgePlanet 3DS Max plugin<p>
                <a href="igeplanet.rar">Download</a>
                </td>
                <td width=35 align="right">
                <a href="igeplanet_shot2.jpg" target="_blank">
                <img src="igeplanet_thumb2.jpg" alt="" width="25" height="100" border="1"></a>
                </td>
                <td width=140 align="right">
                <a href="igeplanet_shot1.jpg" target="_blank">
                <img src="igeplanet_thumb1.jpg" alt="" width="130" height="100" border="1"></a>
                </td>
                <td width=140 align="right">
                <a href="igeplanet_shot0.jpg" target="_blank">
                <img src="igeplanet_thumb0.jpg" alt="" width="130" height="100" border="1"></a>
                <br><font size=-1>Julien Amsellem</font>
                </td>
                <td width=30>
                &nbsp;
                </td>
      <td width=140 align="right">
      <a href="igeplanet_shot4.jpg" target="_blank">
      <img src="igeplanet_thumb4.jpg" alt="" width="130" height="100" border="1"></a>
                <br><font size=-1>Evan Hallein</font>
      </td>
        </tr>
</table>

<b>Planar version</b><p>

<p align="justify">
A version of the above can also be performed on the plane, that is, on each iteration
choose two random points on the plane forming a cut line. 
The side of the plane on the left of the line is raised and the side on the right of
the plane lowered. Performing this operation for various iteration counts is illustrated
below where the height is mapped onto a grey scale.
</p>

<center><table width=100%>
<tr><td>
	<a href="plane10.jpg"><img src="plane10s.jpg" width=400 height=400 border=1></a><br>
	<font size=-1>10 iterations</font>
</td><td>
	<a href="plane100.jpg"><img src="plane100s.jpg" width=400 height=400 border=1></a><br>
	<font size=-1>100 iterations</font>
</td></tr>
<tr><td>
   <a href="plane1000.jpg"><img src="plane1000s.jpg" width=400 height=400 border=1></a><br>
   <font size=-1>1000 iterations</font>
</td><td>
   <a href="plane100000.jpg"><img src="plane100000s.jpg" width=400 height=400 border=1></a><br>
   <font size=-1>100,000 iterations</font>
</td></tr>
</table></center><p>

<p><br><br><br><p>


<center>
<h1>Fractal Landscapes</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
January 1991
</center>

<p><br><p>

<b>Introduction</b><p>

Fractal landscapes are often generated using a technique called spatial
subdivision. For magical reasons this results in surfaces that are similar in
appearance to the earth's terrain.

<p>

The idea behind spatial subdivision is quite
simple. Consider a square on the x-y plane,<br>
<dl>
<dd>(1) split the square up into a 2x2 grid<br>
<dd>(2) vertically perturb each of the 5 new vertices by a random amount<br>
<dd>(3) repeat this process for each new square decreasing the perturbation each iteration.<br>
</dl>

<center><IMG SRC="landscapes1.gif"></center><p>

The controls normally available when generating such landscapes are:<br>
<dl>
<dd> 
* <b>A seed for the random number generator</b>. This starts the random number
  generator and means that the same landscape can be recreated by remembering 
  only one number.<br>
<dd> 
* <b>A roughness parameter</b>. This is normally the factor by which the perturbations
  are reduced on each iteration. A factor of 2 is the usual default, lower
  values result in a rougher terrain, higher values result in a smoother
  surface.<br>
<dd> 
* <b>The initial perturbation amount.</b> This set the overall height
  of the landscape.<br>
<dd> 
* <b>Initial points</b>. It is often desirable to specify some initial points,
  normally on the corners of the initial rectangles. This provides some
  degree of control over the macro appearance of the landscape.<br>
<dd> 
* <b>Sea level</b>. This "flood" the terrain to a particular level simulating
  the water level.<br>
<dd> 
* <b>Colour ramp</b>. This is used for shading of the terrain surface
  based on the height. Normally two or three colours are defined for
  particular heights, the surface at other heights is linearly interpolated
  from these points.<br>
<dd> 
* <b>Number of iterations</b>. This results in the density of the mesh
  that results from the iteration process.<br>
</dl>

<p><b>FracHill</b><p>

An application that creates fractal landscapes has been written by myself
called FracHill.
It fully implements fractal terrain generation including
control over 
(x,y) range, 
sea colour, background colour, terrain colour ramp, 
lighting, rendering options,
camera attributes, 
grid density, 
9 initial points,
height variation, 
and roughness. <br>

This application runs on any Macintosh computer with colour QuickDraw.
It supports image saving to PICT files and colour printing through the
standard Apple printing mechanism.<br>
It also has the ability to geometrically morph between any two terrain
models, images or models can be automatically exported and formed into
animation sequences.<p>
FracHill was primarily written as a creator of terrain models for other 
3D modelling and rendering packages and thus provides
the ability to export the land surface in a number of CAD formats so that it
can be imported into 3D modelling packages.<br>
At the time of writing it exports to the following file formats<br>
<dl>
<dd>DXF
<dd>Super3D
<dd>Radiance
<dd>RayShade
<dd>POV-Ray
<dd>points
</dl>
<p>
The following shows a terrain surface at various grid resolutions from 2x2 to
32x32.<br>

<center><table width=100%><tr><td>
<center><IMG SRC="landscapes2.gif"></center><p>
</td><td>
<center><IMG SRC="landscapes3.gif"></center><p>
</td></tr><tr><td>
<center><IMG SRC="landscapes4.gif"></center><p>
</td><td>
<center><IMG SRC="landscapes5.gif"></center><p>
</td></tr></table></center><p>

In addition to wireframe views, FracHill performs other types of rendering
including <br>
<dl>
<dd>hiddenline
<dd>coloured
<dd>shaded<br>
</dl>
Some examples directly from FracHill are shown below<br>
<center><table width=100%><tr><td>
<center><img src="landscapes6.gif"></center>
</td><td>
<center><img src="landscapes7.gif"></center>
</td></tr></table></center><p>

A well known artefact (bug) with terrains generated this way is the
appearance of "seams" or "creases". These generally occur along the edges
of the geometry associated with early iterations.
A clear example is shown below, notice the crease in the bottom left 
part of the terrain highlighted by the shadow zone:<br>

<center><img src="landscapes8.gif"></center><p>

<p><b>References</b><p>

<i>Heinz-Otto and Dietmar Saupe</i>,
The Science of Fractal Images,
Springer-Verlag
<p>
<i>The Synthesis and Rendering or Eroded Fractal Terrains</i>,
F.Kenton Musgrave, Craig E Kolb, Robert S. Mace,
IEEE Computer Graphics & Applications
<p>


<p><br><br><br><p>


<center>
<h1>Frequency Synthesis of Landscapes (and clouds)</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
March 1997<p>
</center>

<p><br><p>

<p align="justify">
Frequency synthesis is based upon the observation that many "natural"
forms and signals have a 1/f<sup>p</sup>
frequency spectra, that is, their spectra
falls off as the inverse of some power of the frequency where the power is
related to the fractal dimension. 
</p>

This leads naturally to a method of generating such fractals:
<ul>
<li>Generate a random (white noise) signal.<br>
<li>Transform this into the frequency domain.<br>
<li>Scale the resulting spectra by the desired 1 / f<sup>p</sup> function.<br>
<li>Inverse transform.
</ul>
<p>

<p align="justify">
In what follows this technique will be applied to 2 dimensional data,
as will be seen, these look like terrain models when viewed as 3 dimensional
models and clouds when viewed as 2 dimensional images.
</p>

<p align="justify">
To illustrate the process consider firstly a white noise signal in the
spatial domain. To illustrate each stage both the image and 3D model will be
shown together, the example below will use a 256 x 256 grid.
</p>

<table width=100%><tr><td>
<center><img src="noise2d.gif" width="256" height="256"></center>
</td><td>
<center><img src="noise3d.gif" width="400" height="254"></center>
</td></tr></table><p>

<p align="justify">
The next stage is to apply a fast Fourier transform to transfer the
image into the frequency domain. For white noise this essentially
looks like another noise field, the following shows the magnitude
but remember each frequency component is a complex number, it has 
a real and imaginary part
</p>
<table width=100%><tr><td>
<center><img src="fft2d.gif" width="256" height="256"></center>
</td><td>
<center><img src="fft3d.gif" width="400" height="244"></center>
</td></tr></table><p>

<p align="justify">
Now we apply the 1/f filter. Note that the DC value is in the center
of the image. This filter is applied to both the  real and imaginary
values of the harmonics in the frequency domain.
</p>
<table width=100%><tr><td>
<center><img src="filter2d.gif" width="256" height="256"></center>
</td><td>
<center><img src="filter3d.gif" width="400" height="251"></center>
</td></tr></table><p>

<p align="justify">
And lastly we transform back into the spatial domain with an inverse
Fourier transform.
</p>
<table width=100%><tr><td>
<center><img src="cloud2d.gif" width="256" height="256"></center>
</td><td>
<center><img src="cloud3d.gif" width="400" height="246"></center>
</td></tr></table><p>

<p align="justify">
An important attribute of these images/models is
that they tile perfectly, this is a direct result of the Fourier
method which assumes periodic bounds.
The following is a 2 x 2 tiling of the cloud-like image above,
this suggests a way of creating tiled textures....but that's another
story.
</p>
<center><img src="cloud2d4.gif" width="512" height="512"></center><p>

<p align="justify">
There are a number of ways of controlling how rough or smooth the
surface is, the most obvious is to vary the power relationship.
The following two images show the same surface as that used earlier
(same random number sequence) but with a 1/f power of 1.8 and 2.4 
respectively.
</p>
<center>
<img src="09.gif" width="622" height="409"><p>
<img src="12.gif" width="622" height="411"><p>
</center>
<p>

<p align="justify">
As with other fractal generation systems a particular image or surface
is completely characterised by one number, namely the random number seed.
</p>

<center><img src="line.gif" width="700" height="475"></center><p>

<p align="justify">
Bodies of water can be introduced by "flooding" the 3D models to
some level. This is done simply by setting the height dimension of
all grid cells to the flood level if the original height is less than
the flood level.
</p>

<center><img src="flood.gif" width="600" height="569"></center><p>

And finally, a cloud background to a thin gold sheel with a cutout
made from a fractal by Roger Bagula.<p>
<center><img src="roger18c.gif" width="700" height="799"></center>
<p>


<p><br><br><br><p>


<center><table>
<tr>
<td align="center" colspan=2>

<center>
<b>Gallery of images created with</b>
<h1>Voxel World</h1>
By Dmytry Lavrov
<p align="justify">
Voxel world is a terrain and volumetric atmosphere/cloud rendering program being developed
by Dmytry Lavrov. The volumetric approach to clouds and light interaction can create
compelling and realistic atmospheric effects.
</p>
</center>
<p><br><p>
</td>
</tr>

<tr>
<td align="center">
   <a href="sample11.html"><img src="sample11s.jpg" width=300 height=225 border=2></a>
</td>
<td align="center">
   <a href="sample12.html"><img src="sample12s.jpg" width=300 height=225 border=2></a>
</td>
</tr>

<tr>
<td colspan=2 cellpadding=2 align="center">
   <a href="sample10.html"><img src="sample10.jpg" width=300 height=206 border=2></a>
   <br>
</td>
</tr>

<tr>
<td align="center">
	<a href="sample1.html"><img src="sample1s.jpg" width=300 height=240 border=2></a>
</td>
<td align="center">
	<a href="sample2.html"><img src="sample2s.jpg" width=300 height=240 border=2></a>
</td>
</tr>

<tr>
<td colspan=2 align="center">
	<a href="sample3.html"><img src="sample3s.jpg" width=600 height=169 border=2></a>
</td>
</tr>

<tr>
<td align="center">
   <a href="sample6.html"><img src="sample6s.jpg" width=300 height=240 border=2></a>
	<br>Mars - Mariner Valley
</td>
<td align="center">
   <a href="sample7.html"><img src="sample7s.jpg" width=300 height=240 border=2></a>
	<br>Mars - Olympus Mons
</td>
</tr>

<tr>
<td align="center">
   <a href="sample8.html"><img src="sample8s.jpg" width=300 height=240 border=2></a>
   <br>Mountain snow
</td>
<td align="center">
   <a href="sample9.html"><img src="sample9s.jpg" width=300 height=240 border=2></a>
	<br>Mars - Dust storm
</td>
</tr>

<tr>
<td align="center">
   <a href="sample4.html"><img src="sample4s.jpg" width=300 height=240 border=2></a>
</td>
<td align="center">
   <a href="sample5.html"><img src="sample5s.jpg" width=300 height=240 border=2></a>
</td>
</tr>
</table></center>

<p><br><br>

<center><table width=800><tr><td>
<center>
<h1>Perlin Noise and Turbulence</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
January 2000
</center>
<p><br><p>

<b>Introduction</b><br>
<p align="justify">
It is not uncommon in computer graphics and modelling to want to
use a random function to make imagery or geometry appear more natural looking.
The real world is not perfectly smooth nor does it move or change 
in regular ways. The random function found in the maths libraries of
most programming languages aren't always suitable, the main reason
is because they result in a discontinuous function. 
The problem then is to dream up a 
random/noisy function that changes "smoothly". It turns out that there
are other desirable characteristics such as it being defined everywhere
(both at large scales and at very small scales) and for it to be band
limited, at least in a controllable way.
</p>

<p align="justify">
The most famous practical solution to this problem came from Ken Perlin
back in the 1980's. His techniques have found their way in one form or another
into many rendering packages both free and commercial, it has also found
its way into hardware such as the MMX chip set. At the bottom of this
document I've included the original (almost) version of the C code as
released by Ken Perlin and on which most of the examples in the document
are based.
</p>

<p align="justify">
The basic idea is to create a seeded random number series and smoothly
interpolate between the terms in the series, 
filling-in the gaps if you like. There are
a number of ways of doing this and the details of the particular
method used by Perlin need not be discussed here. Perlin noise can
be defined in any dimension, most common dimensions are 1 to 4.
The first 3 of these will be illustrated and discussed below.
</p>

<b>1 Dimensional</b><p>
<p align="justify">
A common technique is to
create 1/f<sup>n</sup> noise which is known to occur often in natural
processes. An approximation to this is to add suitably scaled harmonics
of this basic noise function. 
For the rest of this discussion the Perlin noise functions will be
referred to as Noise(<b>x</b>) of a variable <b>x</b> which may
a vector in
1, 2, 3 or higher dimension. This function will return a real (scalar) value.
A harmonic will be Noise(b <b>x</b>) where "b" is some positive number
greater than 1, most commonly it will be powers of 2.
While the Noise() functions can be used by themselves, a more common
approach is to create a weighted sum of a number of harmonics of 
these functions. These will be refered to as NOISE(<b>x</b>)
and can be defined as 
<br>
<center><img src="equation1.gif" width="184" height="76"></center>
<br>
Where N is typically between 6 and 10.
The parameter "a" controls how rough the final NOISE() function will be. 
Small values of "a", eg: 1, give very rough functions, larger values give
smoother functions. While this is the standard form in practice it
isn't uncommon for the terms a<sup>i</sup> and b<sup>i</sup> to be 
replaced by arbitrary values for each i.
</p>

<p align="justify">
The following shows increasing harmonics of 1 dimensional Perlin noise
along with the sum of the first 8 harmonics at the bottom. In this case
a and b are both equal to 2. Note that
since in practice we only ever add a limited number of harmonics, if we
zoom into this function sufficiently it will become smooth.
</p>

<center><img src="perlin1d.gif" width="525" height="663"></center>
<p>

<b>2 Dimensional</b><p>

<p align="justify">
The following show the same progression but in two dimensions.
This is also a good example of
why one doesn't have to sum to large values of N, after the 4th
harmonic the values are less than the resolution of a grey scale image
both in terms of spatial resolution and the resolution of 8 bit grey scale.
</p>

<center><table>
<tr><td valign="center" align="center">
<img src="perlin2d_0.gif" width=200 height=200><br>
0 (1)
</td><td valign="center" align="center">
<img src="perlin2d_1.gif" width=200 height=200><br>
1 (2)
</td><td valign="center" align="center">
<img src="perlin2d_2.gif" width=200 height=200><br>
2 (4)
</td></tr>

<tr><td valign="center" align="center">
<img src="perlin2d_3.gif" width=200 height=200><br>
3 (8)
</td><td valign="center" align="center">
<img src="perlin2d_4.gif" width=200 height=200><br>
4 (16)
</td><td valign="center" align="center">
<img src="perlin2d_sum.gif" width=200 height=200><br>
Sum
</td></tr>
</table></center><p>

<p align="justify">
As earlier, a and b are both set to 2 but 
note that there are an infinite number of ways these harmonics could
be added together to create different effects. For example, if in the
above case one wanted more of the second harmonic then the scaling of that
can be increased. While the design of a particular image/texture isn't
difficult it does take some practice to become proficient.
</p>

<b>3 Dimensional</b><br>

<p align="justify">
Perlin noise can be created in 3D and higher dimensions, unfortunately it is
harder to visualise the result in the same way as the earlier dimensions.
One isosurface of the first two harmonics are shown below but it hardly tells
the whole story since each point in space has a value assigned to it.
</p>

<center><table><tr><td align="center">
<a href="3d_0.gif"><img src="3d_0small.gif" width=300 height=271></a><br>
0 (1)
</td><td align="center">
<a href="3d_1.gif"><img src="3d_1small.gif" width=300 height=271></a><br>
1 (2)
</td></tr></table></center>

<p align="justify">
Perhaps the most common use of 3D Perlin noise is generating volumetric
textures, that is, textures that can be evaluated at any point in space
instead of just on the surface. There are a number of reasons why this
is desirable. 
</p>

<ul>
<li><p align="justify">
It means that the texture need not be created beforehand but can 
be computed on the fly. 
</p>
<li><p align="justify">
There are a number of ways the texture can be animated.
One way to to translate the 3 dimensional point passed to the Noise()
function, alternatively one can rotate the points. Since the 3D texture
is defined everywhere in 3D space, this is equivalent to translating or
rotating the texture volume.
</p>
<li><p align="justify">
The exact appearance of the texture can be controlled by either varying
the relative scaling of the harmonics or by adjusting how the scalar from
the Perlin functions is mapped to colour and/or transparency.
</p>
<li><p align="justify">
It gets around the problem of mapping rectangular texture images
onto topologically different surfaces. For example, the following texture
for a sun was created using 3D noise and evaluating the points using the
same mapping as will be used when the texture is mapped onto a sphere.
The result is that the texture will map without pinching at the poles and
there will not be any seams on the left and right.<p>
<center><img src="sun.gif" width="512" height="256"></center>
</p>
</ul>

<table width=100% callpadding=0 cellspacing=0>
<tr><td valign="top">

<b>Source code</b><br>
<p align="justify">
The original C code by Ken Perlin is given here:
<a href="perlin.h">perlin.h</a> and <a href="perlin.c">perlin.c</a>.
</p>

<b>Applications</b><br>
<p align="justify">
The above describes a way of creating a noisy but continuous function.
In normal operation one passes a vector in some dimension and the function
returns a scalar. How this scalar is used is the creative part of the
process. Often it is can be used directly, for example, to move the
limbs of virtual character so they aren't rigid looking. Or it might be
used directly as the transparency function for clouds. Another fairly
common application is to use the 1D noise to perturb lines so they look
more natural, or to use the 2D noise as the height for terrain models.
2D and 3D perlin noise are often used to create clouds, a hint of this
can be seen in the sum of the 2D Noise() functions above.
</p>

<p align="justify">
When the aim is to create a texture the scalar is used as an index into
a colour map, this may either be a continuous function or a lookup table.
Creating the colour map to achieve the result being sought is a matter
of skill and experience. Another approach is to use NOISE() functions
as arguments to other mathematical functions, for example, marble effects
are often made using cos(x + NOISE(x,y,z)) and mapping that to the desired
marble colours.
<br>
</p>

</td><td valign="top" width=10">
&nbsp;
</td><td valign="top">
<img src="sun2.gif" width=300 height=300><p>
<img src="clouds.gif" width=300 height=300><p>
</td></tr></table>

<p align="justify">
In order to effectively map the values returned from the noise functions
one needs to know the range of values and the distribution of values
returned. The original functions and therefore the ones presented
here both have Gaussian like distributions centered on the origin.
Noise() returns values between about -0.7 and 0.7 while NOISE() returns
values potentially between -1 and 1. The two distributions are shown
below.
</p>

<p>
<center><img src="distribution.gif" width="492" height="261"></center>
<p>

The possibilities are endless, enjoy experimenting.<p>

<b>References</b><p>

Ken Perlin.
An Image Synthesizer.  Computer Graphics, 1985, 19 (3), pp 287-296.
<p>

Donald Hearn and M. Pauline Baker.
Fractal-Geometry Methods.  Computer Graphics, C-Version, 1997, pp 362-378. 
<p>

Perlin, K.  Live Paint: Painting with Procedural Multiscale Textures.
Computer Graphics, Volume 28, Number 3. 
<p>

David Ebert, et al (Chapter by Ken Perlin).
Texturing and Modeling, A Procedural Approach.  AP Professional, Cambridge, 1994.
<p>

Perlin, K., Hoffert, E.  Hypertexture.
Computer Graphics (proceedings of ACM SIGGRAPH Conference), 1989, Vol. 22, No. 3.
<p>

</td></tr></table></center>
</body>
</html>

