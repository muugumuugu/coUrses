<html>
<head>
<link rel=StyleSheet href="../../pdbstyle.css" type="text/css" media=all>
<title>WLD - WorldBuilder file format</title>
</head>
<body>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<script language="JavaScript">
<!--
   if (self.location.href != top.location.href) {
      top.location.href = self.location.href;
   }
-->
</script>


<center><table width=800><tr><td>

<center>
<h1>WLD - WorldBuilder file format</h1>
</center>
<p><br><p>

<B><P>Overview:</P>
</B><P>Morfit&#146;s .wld format can describe any kind of world, and can also describe movement within the world, by:</P>
<OL START=0>

<LI>having objects follow a certain path in the world</LI>
<LI>giving the camera a path to follow</LI>
<LI>having one object follow another object</LI>
<LI>having the camera follow an object</LI></OL>


<P>You can also give physical properties to objects in the world (speed, force,etc.). Everything else must be done through programming.</P>

<B><P>Introduction:</P>
</B><P>The basic building blocks used to build a Morfit world file are:</P>

<B><P>Module: </B>Think of this as a &#145;model&#146;. A Module defines a shape.</P>

<B><P>Polygon: </B>That&#146;s just it;a Polygon.</P>

<B><P>Object: </B>An Object is one instance of a predefined shape (model). For example, if you have a module called tree, you can have 100 Objects, placing an instance of a tree in 100 different locations. You can change an Object&#146;s proportions, rotate it, change its location, etc., but the basic shape does not change. </P>

<B><P>Track: </B>A Track defines a path in the world that a Dynamic Object or a Camera can follow.</P>

<B><P>Dynamic Object: </B>Make your Objects dynamic only if you want them to be able to move. A Dynamic Object can be moved either by putting it on a track in the world, or by making it move in a program (using Morfit functions in your code). If you know the object will be stationary, make it a regular Object.</P>

<B><P>Camera: </B>The Camera represents the view from which the world is seen.</P>

<B><P>Animation: </B>Animation is a sequence of bitmaps that replace one another.</P>

<B><P>Background: </B>A Background is a bitmap spread over the background of the world</P>

<B><P>Atmosphere:</B> This sets the atmospheric effects in the world, including light and fog.</P>

<P>Test the sample .wld files given , using &#145;World Text Editor&#146; for a better understanding of the Morfit&#146;s world file format. </P>

<B><P>Coordinate System:</P></b>
<P>Morfit .wld coordinate system:</P>
<P>positive x = moves out of the screen (away from the world)</P>
<P>negative x = moves into the screen (further into the world)</P>
<P>positive y = moves to the right in the world</P>
<P>negative y = moves to the left in the world</P>
<P>positive z = moves up in the world (height)</P>
<P>negative z = moves down in the world (height)</P>

<P>Example: For an object placed at the origin (0, 0, 0), it's best to place the camera at a positive x location (ex. 500, 0, 0) and give the camera a negative x direction so that it can see the object (ex. &#151;1, 0, 0). </P>

<B><P>Starting Out:</P>
</B>
<P>Sample: 
<a href="http://paulbourke.net/dataformats/wld/Skeleton.wld">Skeleton.wld</a></P>

<P>Every Morfit &#145;.wld&#146; file must begin with &#145;BEGIN DESIGN:&#146; and end with &#145;END DESIGN:&#146;.</P>

<B><P>Module:</P></B>

<P>Sample: 
<a href="http://paulbourke.net/dataformats/wld/Module.wld">Module.wld</a></P>

<B><P>The fields include:</P>
</B><P>Module Name: Give a name to the module.</P>

<B><P>REMARKS:</P>
</B><P>Every world must include one module named <B>main</B>, which is the engine's starting point.</P>
<P>Inside a module, you can have polygons or objects, and nothing else.</P>
<P>Recursive definitions are allowed (i.e. a module consisting of an object that uses a module, etc&#133; For example a module called 'house' uses a 'table' object which in turn consists of a 'leg' module&#133;.). </P>
<B>
<P>Polygon:</P>

</B><P>Sample: 
<a href="http://paulbourke.net/dataformats/wld/Polygon.wld">Polygon.wld</a></P>

<B><P>The fields include</B>:</P>
<P>Polygon Name: Give a name to the polygon.</P>

<P>Orientation: 
Defines the object space. It can be either top, bottom, front, side</P>

<P>or not specified. See REMARKS for more details.</P>

<P>Color:
This button opens a color dialog box. You can choose a color, or customize your own.</P>

<P>Bitmap:
Give the name of the bitmap to map onto the polygon.</P>

<P>Transparent:
Any number greater than or equal to &#151;1.</P>

<P>-1: Doesn't omit any color. It leaves the image as it is.</P>
<P>0: The most frequently used color is omitted (usually the background color). This is the default.</P>
<P>1: The second most frequently used color is omitted.</P>
<P>Etc.</P>

<P>Rotated:
YES/NO option. If the polygon is rotated, the front of the polygon will always be facing towards the camera, creating the allusion that the polygon is 3-dimensional.</P>

<P>Light Diminution:
Any number greater than or equal to 0. This controls how fast the polygon blends with the atmospheric color, as it gets further away. For example, you'd give a rock a large value since it should blend into the atmosphere as it gets further away, and you'd give a fire a small value so as to see it even when its far away.</P>
<P>
With a light diminution value of 0, the polygon won't be influenced by any atmospheric effect.</P>

<P>Number of Points:
This field will get filled in automatically as you add points to the polygon.</P>

<P>Add Points:
For each point, you must give six numbers: the first three are the x, y, and z coordinates of the point, the next two are the bitmap x and bitmap y coordinates, and the last number is the point&#146;s light intensity.</P>
<P>
The bitmap coordinates will be put on the polygon&#146;s x and y coordinates.</P>
<P>See REMARKS for examples of matching bitmap points to the polygon points.</P>

<B><P>REMARKS:</P>
<P>Orientation: </P>
</B><P>In 'Viewer' mode the orientation is only relevant for dynamic objects. In 'Editor' mode all polygons belong to a certain group, therefore orientation is important. If you want to use functions like Morfit_group_rotate( ) and Morfit_group_move( ) (in 'Object Space'), the engine needs to know the front, top, etc. of each polygon in the group, so that it will know how to advance or rotate it (which polygon should face the camera, which should stay on the ground, etc.).</P>
<P>Orientation of polygons go in couples: 1. bottom-top and 2. front-back.</P>
<P>For a full definition of the group/dynamic object the polygon belongs to, you must have at least one orientation from each couple. That is, 1. Either a bottom or a top <B>AND</B> 2. Either a front or a back. It is preferable to make the rest of the polygons in the group 'not specified'.</P>

<P>If you give the same orientation to more than one polygon, the engine will give that orientation only to the first one it finds. To avoid contradictory cases, give each orientation to one polygon only.</P>

<P>When using this together with the "World Builder", it knows how to place a piano (for example) in the world, according to which polygon has the bottom (or top) orientation (i.e. - bottom down or top up).</P>

<P>Orientation defines the object space. See the following Morfit functions :</P>

<P>Morfit_object_rotate( )</P>
<P>Morfit_object_move( )</P>
<P>Morfit_group_rotate( )</P>
<P>Morfit_group_move( )</P>

<P>NOTE: For beginners, if confused about all these explanations, choose the 'not specified' orientation and don't think too much about it!</P>

<B><P>Bitmap Points:</P>
</B><P>Bitmaps are always a square, with the following coordinates:</P>
<B>
</B><P><IMG SRC="http://paulbourke.net/dataformats/wld/Image1.gif" WIDTH=64 HEIGHT=66> 0,0 1,0</P>
0,1 1,1</P>

<B><P>Example #1: </B>To specify bitmap coordinates for a triangle, give it these:</P>

<P><IMG SRC="http://paulbourke.net/dataformats/wld/Image2.gif" WIDTH=66 HEIGHT=66><IMG SRC="http://paulbourke.net/dataformats/wld/Image3.gif" WIDTH=66 HEIGHT=66>0,0 ;1,0 0.5,0 0.5,0</P>
<P><IMG SRC="http://paulbourke.net/dataformats/wld/Image4.gif" WIDTH=66 HEIGHT=66>0,1 1,1 0,1 1,1 0,1 1,1</P>

<B><P>Example #2: </B>To tile a bitmap (repetitive bitmap) :</P>
<B><P><IMG SRC="http://paulbourke.net/dataformats/wld/Image5.gif" WIDTH=55 HEIGHT=51><IMG SRC="http://paulbourke.net/dataformats/wld/Image6.gif" WIDTH=112 HEIGHT=162><IMG SRC="http://paulbourke.net/dataformats/wld/Image7.gif" WIDTH=112 HEIGHT=162></B>
0,0</P>
<P>2,3</P>

<P>This will repeat the bitmap 2 across and 3 down to fill the polygon.</P>
<B>
<P>Example #3: </B>You must specify (at least) <B>3</B> bitmap-x and <B>3</B> bitmap-y coordinates for a polygon. For all other points it's better to give a <B>&#151;1</B> value to the bitmap_x and y coordinates, which tells the engine to figure it out by itself. This will avoid contradiction.</P>

<B><P><IMG SRC="http://paulbourke.net/dataformats/wld/Image8.gif" WIDTH=88 HEIGHT=64><IMG SRC="http://paulbourke.net/dataformats/wld/Image9.gif" WIDTH=88 HEIGHT=65><IMG SRC="http://paulbourke.net/dataformats/wld/Image10.gif" WIDTH=88 HEIGHT=63></B>0,0 
1,0 -1,-1 -1,-1</P>
<P>0,1 1,1 0,1 1,1 0,1 1,1</P>

<P>You can specify only one coordinate of a point to be &#151;1, if you know the other:</P>

<B><P><IMG SRC="http://paulbourke.net/dataformats/wld/Image10.gif" WIDTH=88 HEIGHT=63></B>-1,0</P>

<P>0,1 1,1</P>
<B>
<P>Object:</P>

</B><P>Sample: 
<a href="http://paulbourke.net/dataformats/wld/Object.wld">Object.wld</a></P>

<P>The fields include</B>:</P>
<P>Module Name:
Which module to use.</P>

<P>Location:
Location of the object.</P>

<P>Scale:
To change the size of the object. Example: 2, 2, 2 will double the size. .5, .5, .5 will half it. You can change one, two, or all axis.</P>

<B><P>Track:</P></B>

<P>Sample: 
<a href="http://paulbourke.net/dataformats/wld/Track.wld">Track.wld</a></P>

<B><P>The fields include</B>:</P>
<P>Track Name:
Give a name to the track.</P>

<P>Cyclic:
Yes/No option.</P>

<P>YES: The track is connected (i.e. after the last point, it continues to the first). Example: A car or an air plane, traversing the same route repetitively.</P>
<P>NO: The track is not connected. Example: You want an object to move to the point where the user clicks on the screen. To do this, you take the previous point, and the point where the user clicked, and make a track consisting of those two points.</P>

<P>Points:
Specify the points in the track (x, y, and z coordinates). </P>

<B><P>Dynamic Object:</P>
</B>
<P>Sample: 
<a href="http://paulbourke.net/dataformats/wld/DynamicObject.wld">DynamicObject.wld</a> (same as Track.wld)</P>

<P>The fields include</B>:</P>
<P>Object Name:
Give the dynamic object a name.</P>

<P>Module Name:
Which module to use.</P>

<P>Type:
Relevant in AUTO_BEHAVIOR mode. Car: moves like a car. Plane: moves like an air plane. If in USER_DEFINED mode, the user can use it as he/she wants to.</P>

<P>Control:
Relevant in AUTO_BEHAVIOR mode. Player: the program takes input from the user. Computer: takes no user input. If in USER_DEFINED_BEHAVIOR mode, the user can use it as he/she wants to.</P>

<P>Track:
Which track the dynamic object should follow. Relevant only when chase type is 'chase_track' or 'chase_track_airplane'.</P>

<P>Track Offset:
The center of the track is put at this offset.</P>

<P>Chase:
Which dynamic object this dynamic object should chase. Only relevant when chase type is 'chase_flexible' or 'chase_location'. </P>

<P>Chase Offset:
The offset at which the dynamic object should chase the object.</P>

<P>Chase Type:
chase_track: Movement is according to the track.</P>
<P>chase_track_airplane: Like 'chase_track', but moves like an airplane.</P>
<P>chase_flexible: Chases softly.</P>
<P>chase_location: The dynamic object will change its location, but not its direction. Only the offset is relevant, and not the softness or distance.</P>
<P>chase_physics: Uses the 'Physics' fields to determine how to chase.</P>
<P>chase_precise: The dynamic object will chase the object precisely &#151; will mimic the object's movements exactly. The object itself won't look like it's moving, but the world around it will.</P>
<P>no_chase: Doesn't chase anything.</P>

<P>Chase Softness:
A number between 0 and 1. This controls how the dynamic object will turn. The bigger this number is, the more rigid (choppy) it'll turn. 0- so smooth, practically not usable.</P>

<P>Chase Distance:
The distance between this dynamic object and the dynamic object to chase.</P>

<P>Physics:
Only relevant if chase type is 'chase_physics', except for speed, which is relevant for 'chase_track' or 'chase_track_airplane'. (The following fields are 'physics' fields.)</P>

<P>Speed:
Specify the speed vector. The direction of the vector is the direction of the movement, and the length of the vector controls the magnitude of the speed (magnitude = the square root of x^2 + y^2 + z^2) For 'chase_track', use the x-coordinate to specify the speed. Example: 100, 0, 0. </P>

<P>Force:
The direction of the force operating on the vector. The length of the vector controls the magnitude of the force. If you want to implement gravity, make the force something like this: 0, 0, -10. (make z negative).</P>

<P>Maximum Speed:
The maximum speed it can move.</P>

<P>Friction:
A number smaller than or equal to 1.</P>

<P>0 : No friction.</P>
<P>1 : Infinite friction, so won't move.</P>

<P>Negative numbers: Acts like pressing the gas. This can be used for increasing the speed. &#151;1 doubles the speed. &#151;2 triples the speed. </P>

<P>Typical numbers can be .03 or -.03.</P>

</B><P>Camera Name:
Give a name to the camera. The first camera the engine sees in the world file will be the default camera.</P>


<P>Location:
The location of the camera.</P>

<P>Direction:
The direction the camera is facing.</P>

<P>View Field:
The angle the camera sees. This number can be anything from 1 to 179 degrees. 1 means a very strong zoom in, and 179 means a very strong zoom out.</P>

<P>Culling Depth:
-1 : Not active. Other values (in the range of [0-infinity]), will cut the world. For example, if culling depth is 1000, the camera won't see anything further than 1000 virtual units. This makes render work faster since the engine draws less, but a better way of causing this is to use the atmospheric effect: when it's foggy, the engine doesn't have to draw anything in the fog. This is better, since it blends naturally and doesn't cut objects in the middle.</P>
<P ALIGN="RIGHT"></P>
<P>Eye Distance:
How far from itself the camera should start seeing (can't see things that are too close). The bigger this number is, the more accurate will be the rendering of the objects. On the other hand, a number that is too big will hide objects that are near the camera. Typical numbers are 1, 4, 10, 20 when distance in the world is measured in centimeters. Try to make this number as big as you can, but stop increasing it when near objects are not drawn. (The bigger it is, the better the z-buffer operates and removes 'hidden surface removal' effects.)</P>

<P>Track:
Which track the camera should follow. Relevant only when chase type is 'chase_track' or 'chase_track_airplane'.</P>

<P>Track Offset:
The center of the track is put at this offset.</P>

<P>Chase:
Which dynamic object the camera should chase. Only relevant when chase type is 'chase_flexible' or 'chase_location'. </P>

<P>Chase Offset:
The offset at which the camera should chase the object.</P>

<P>Chase Type:
chase_track: Movement is according to the track.</P>
<P>chase_track_airplane: Like 'chase_track', but moves like an airplane.</P>
<P>chase_flexible: Chases softly, always following the object from behind.</P>
<P>chase_location: The camera will change its location, but not its direction (so that if the object turns, you'll see its side or back, because the camera didn't turn). Only the offset is relevant, and not the softness or distance.</P>
<P>chase_physics: Uses the 'Physics' fields to determine how to chase.</P>
<P>chase_precise: The camera will chase the object precisely - will mimic the object's movements exactly. The object itself won't look like it's moving, but the world around it will.</P>
<P>no_chase: Doesn't chase anything.</P>

<P>Chase Softness:
A number between 0 and 1. This controls how the camera will turn. The bigger this number is, the more rigid (choppy) it'll turn. 0- so smooth, practically not usable.</P>

<P>Chase Distance:
The distance between the camera and the dynamic object to chase.</P>

<P>Physics:
Only relevant if chase type is 'chase_physics', except for speed, which is relevant for 'chase_track' or 'chase_track_airplane'. (The following fields are 'physics' fields.)</P>

<P>Speed:
Specify the speed vector. The direction of the vector is the direction of the movement, and the length of the vector controls the magnitude of the speed (magnitude = the square root of x^2 + y^2 + z^2) For 'chase_track', use the x-coordinate to specify the speed. Example: 100, 0, 0. </P>

<P>Force:
The direction of the force operating on the vector. The length of the vector controls the magnitude of the force. If you want to implement gravity, make the force something like this: 0, 0, -10. (make z negative).</P>

<P>Maximum Speed:
The maximum speed it can move.</P>

<P>Friction:
A number smaller than or equal to 1.</P>

<P>0 : No friction.</P>
<P>1 : Infinite friction, so won't move.</P>

<P>Negative numbers: Acts like pressing the gas. This can be used for increasing the speed. &#151;1 doubles the speed. &#151;2 triples the speed. </P>

<P>Typical numbers can be .03 or -.03.</P>

<P>Elasticity:
What happens when the object reaches an obstacle. </P>
<P>1 - the object doesn't lose any speed </P>
<P>0.5 - speed is cut in half</P>
<P>0 &#151; the object stops right there</P>

</B><P>Also, see Mrft_api.h (header file) for an in-depth explanation of all these fields.</P>

<B><P>Animation:</P>

</B><P>Sample: 
<aahref="Animation.wld">Animation.wld</a></P>

<P>The fields include</B>:</P>
<P>Animation Name: Give a name to the animation.</P>

<P>Number of Frames: The number of images the animation has.</P>

<P>Times: The time, in hundreds of seconds, in each frame. </P>

<P>NOTE: <B>1.</B> The render function never skips a frame, and therefore you cannot replace the images faster than it takes the engine to render the image. <B>2.</B> You must give a time for each frame.<B> </P>

</B><P>The next 5 fields are: 
BACK, BACK-SIDED, SIDE, FRONT-SIDED, and FRONT, representing different angles of the animation. Together, they represent 180 degrees, mirroring the images to get the other half of the circle. </P>

<P>You must fill in at least one of these fields.</P>

<P>For each of these fields, you specify the bitmap to use for each frame, followed by a number specifying its transparency property. The transparency default is 0 if none is specified.</P>
<P>Transparency: -1: Doesn't omit any color. It leaves the image as it is.</P>

<P>0: The most frequently used color is omitted (usually the background color). This is the default.</P>
<P>1: The second most frequently used color is omitted.</P>
<P>Etc.</P>

<B><P>Atmosphere:</P></B>

<P>Sample:
<a href="http://paulbourke.net/dataformats/wld/Atmosphere.wld">Atmosphere.wld</a></P>

<B><P>The fields include</B>:</P>

<P>Atmosphere: The RGB (red, green, and blue) values that make up the color of the atmosphere.</P>

<P>Fog: Any floating point number between 0 and 2. This number determines the amount of fog in the world. If the dimensions of the world are small, this number should be closer to 0, and if the world is big, this number should be closer to 2.</P>
<P>A good starting point is 0.1; work from there.</P>

<P>Light: Any floating point number between 0 and 400. This number determines how bright the world should be.</P>

<B><P>Recursive Use of Objects:</P>
</B>
<P>Sample: 
<a href="http://paulbourke.net/dataformats/wld/Recursive.wld">Recursive.wld</a></P>

<P>In this sample, the main module consists of one object (round table), which consists of five objects (four legs and a base) , which finally consists of the actual polygons.</P>

</td></tr></table></center>
</BODY>
</HTML>
