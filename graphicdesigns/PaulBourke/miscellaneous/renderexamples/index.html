<html>
<head>
<link rel=StyleSheet href="../../pdbstyle.css" type="text/css" media=all>
<title>Spiral Vase by Dennis Miller</title>
</head>
<body>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<script language="JavaScript">
<!--
   if (self.location.href != top.location.href) {
      top.location.href = self.location.href;
   }
-->
</script>


<center><table width=800><tr><td>

<center>
<h1>Various distributed rendering examples</h1>
The following are examples of distributed rendering of either single high resolution
images or animation sequences. <p>
Compiled by <a href="../index.html">Paul Bourke</a>
</center>
<p><br><p>

<center>
<h3>Spiral Vase</h3>
Model and animation by Dennis Miller<br>
Copyright &copy; 1999<p>
Software: PovRay and MPI<br>
Custom distributed animation tools by <a href="index.html">Paul Bourke</a><br>
CPU cycles from a 64 node Dec Alpha farm<br>
September 1999
</center>

<center>
<img src="http://paulbourke.net/miscellaneous/renderexamples/dmiller1.gif" border=1 width=600 height=400 border=1><p>
<img src="http://paulbourke.net/miscellaneous/renderexamples/dmiller2.gif" border=1 width=600 height=400 border=1><p>
<img src="http://paulbourke.net/miscellaneous/renderexamples/dmiller3.gif" border=1 width=600 height=400 border=1><p>
<img src="http://paulbourke.net/miscellaneous/renderexamples/dmiller4.gif" border=1 width=600 height=400 border=1><p>
</center>

<p align="justify">
There are a number of ways one can render an animation using a standard
package (such as PovRay) and exploit a collection of computers. For
efficiency a prime objective is to ensure the machines are all busy
during the time it takes to render the entire animation. The most
straightforward way of distributing the frames is to send the first N
frames to the first computer, the second N frames to the next computer
and so on, where N is the total number of frames divided by the numbers
of computers available.
</p>
<center>
<img src="http://paulbourke.net/miscellaneous/renderexamples/clip1.gif" width=471 height=100>
</center>
<p align="justify">
The problem with this approach is that most animations don't have a uniform
rendering time per frame. The above example illustrates this point, the
frames at the start of the animation take seconds to render while other
frames take many minutes. Sending contiguous time chunks to each computer
means that many of the computers will be standing idle while the animation
will not be complete until those processing the more demanding pieces
are finished.
A much more balanced approach is to interleave the frames as illustrated
below
</p>
<center>
<img src="http://paulbourke.net/miscellaneous/renderexamples/clip2.gif" width=532 height=157>
</center>
<p align="justify">
There are a number of ways this can be accomplished using PovRay, the method
chosen here was to create an ini file containing all relevant/required
settings including Initial_Clock, Final_Clock, Initial_Frame, and Final_Frame.
Scripts are then created that invoke PovRay on each machine (using rsh)
with the appropriate +SFn and +EFn command line arguments with the appropriate 
value of n.
</p>

<p align="justify">
An alternative is to to develop tools using one of the parallel processing
tools available, for example, MPI or PVM. Using this approach a "master"
processes can additionally check the load on the available machines
and only distribute the next frame given some suitably low value. This
can be particularly important in a multi-user environment where simply
"nicing" the rendering may not be user friendly enough, for example, the
renderings may require significant resources such as memory.
</p>

<p><br><br><br><p>


<center>
<h3>Waves</h3>
Model and animation by Dennis Miller</a><br> Copyright &copy; 1999
<p>

Software: PovRay and MPI<br>
Custom distributed animation tools by 
<a href="../index.html">Paul Bourke</a><br>
CPU cycles from a 64 node Dec Alpha farm<br>
September 1999
</center>

<center>
<img src="http://paulbourke.net/miscellaneous/renderexamples/wave1.jpeg" border=1 width=600 height=400><p>
<img src="http://paulbourke.net/miscellaneous/renderexamples/wave2.jpeg" border=1 width=600 height=400><p>
<img src="http://paulbourke.net/miscellaneous/renderexamples/wave3.jpeg" border=1 width=600 height=400><p>
<img src="http://paulbourke.net/miscellaneous/renderexamples/wave4.jpeg" border=1 width=600 height=400><p>
<img src="http://paulbourke.net/miscellaneous/renderexamples/wave5.jpeg" border=1 width=600 height=400><p>
</center>

<p><br><p>
<p><br><br><br><p>


<center>
<h3>Water Sun</h3>
Model and animation by Dennis Miller<br>
Copyright &copy; 2000
<p>

Software: MegaPov and MPI<br>
Custom distributed animation tools by 
<a href="../index.html">Paul Bourke</a><br>
CPU cycles from a 64 node Dec Alpha farm<br>
April 2000
</center>

<center>
<img src="http://paulbourke.net/miscellaneous/renderexamples/watersun1.jpeg" border=1 width=720 height=480><p>
</center>

<p><br><br><br><p>


<center>
<h3>Spacecraft Hangar</h3>
Model and animation by 
<a href="http://www.wis.co.uk/justin/">Justin Watkins</a><br>
<b>"Scout craft taking off from a maintenance hangar on Luna Base 4"</b><br>
Copyright &copy; 1999<p>
Software: PovRay and MPI<br>
Custom distributed animation tools by <a href="index.html">Paul Bourke</a><br> 
CPU cycles from a 64 node Dec Alpha farm<br>
September 1999
</center>

<center>
<img src="http://paulbourke.net/miscellaneous/renderexamples/hangar1.gif" border=1 width=600 height=450><p>
<img src="http://paulbourke.net/miscellaneous/renderexamples/hangar2.gif" border=1 width=600 height=450><p>
<img src="http://paulbourke.net/miscellaneous/renderexamples/hangar3.gif" border=1 width=600 height=450><p>
<img src="http://paulbourke.net/miscellaneous/renderexamples/hangar4.gif" border=1 width=600 height=450><p>
</center>

<p><br><br><br><p>


<center>
<h3>Glass Cloud</h3>
Model and animation by Morgan Larch<br>
Copyright &copy; 1999
<p>

Software: PovRay and MPI<br>
Custom distributed animation tools by <a href="index.html">Paul Bourke</a><br>
CPU cycles from a 64 node Dec Alpha farm<br>
September 1999
</center>

<center>
<img src="http://paulbourke.net/miscellaneous/renderexamples/morgan1.gif" border=1 width=600 height=450><p>
<img src="http://paulbourke.net/miscellaneous/renderexamples/morgan2.gif" border=1 width=600 height=450><p>
<img src="http://paulbourke.net/miscellaneous/renderexamples/morgan3.gif" border=1 width=600 height=450><p>
</center>

<p><br><br><br><p>


<center>
<h3>Addict</h3>
Modelling/rendering by 
Rob Richens<br>
Copyright &copy; 2001
<p>

Concept and direction by Dale Kern.<br>
Rendered using PovRay<br>
Additional software: Poser 2<bR>
Trees, Makelamp, and Grass macros by Giles Tran.<br>
Spray macro by Chris Colefax.
<p>
</center>

<center>
<a href="http://paulbourke.net/miscellaneous/renderexamples/addict.png"><img src="http://paulbourke.net/miscellaneous/renderexamples/addict.jpg" border=1 width=500 height=375><p>
</a>
</center>
<p>

<center>
Distributed rendering by <a href="index.html">Paul Bourke</a><br>
Using locally developed scripts and
CPU cycles on a 32 processor PIII and 64 processor Dec Alpha farm.<br>
Astrophysics and Supercomputing, Swinburne University of Technology.<br>
November 2001
</center>


<p><br><br><br><p>


<center>
<h3>Escape</h3>
Modelling/rendering by Rob Richens<br>
Copyright &copy; 2006<p>
Concept and direction by Dale Kern.<br>
Rendered using PovRay, Additional software: Poser 2<p>
</center>

<center>
<a href="http://paulbourke.net/miscellaneous/renderexamples/escape.png"><img src="http://paulbourke.net/miscellaneous/renderexamples/escape.jpg" border=1 width=500 height=375></a>
</center>
<p>

<center>
Distributed rendering by <a href="index.html">Paul Bourke</a><br>
Using locally developed scripts and the PBS batch queue system.<br>
The image is rendered across a large number of processors<br>
as a series of narrow strips which are reassembled at the end.<br>
CPU cycles from a 176 CPU SGI Altix, IVEC, Western Australia.<br>
November 2006<p>
</center>

<p><br><br><br><p>


<table width=100%><tr><td>
<center>
<h3>Parallel Rendering</h3>
<h3>Using POVRAY on a Computer Cluster</h3>
Written by <a href="../index.html">Paul Bourke</a><br>
Example model courtesy of St&egrave;fan Viljoen<br>
Trees by Paul Dawson, lens flare and city by Chris Colefax.<br>
August 1999
</center>
</td><td align="right" width=200>
<img src="http://paulbourke.net/miscellaneous/renderexamples/overfsmall.gif" border=1>
</td></tr></table>

<p align="justify">
Given a number of computers and a demanding POVRAY scene to render, there are
a number of techniques to distribute the rendering among the available
resources. If one is rendering an animation
then obviously each computer can render a subset of the total number of
frames. The frames can be sent to each computer in contiguous chunks or
in an interleaved order, in either case a preview (every N'th frame)
of the animation can generally be
viewed as the frames are being computed. Typically an interleaved order
is preferable since parts of the animation that may be more computationally
demanding are split more evenly over the available computing resources.
</p>

<p align="justify">
In many cases even single frames can take a significant time to render.
This can occur for all sorts of reasons: complicated geometry, sophisticated
lighting (eg: radiosity), high antialiasing rates, 
or simply a large image size. The usual way to render such scenes
on a collection of computers is to split the final image up into pieces,
rendering each piece on a different computer and sticking the pieces
together at the end. POVRAY supports this rendering by the ini file
directives
</p>

<ul>
Height=n<br>
Width=n<br>
Start_Row=n<br>
End_Row=n<br>
Start_Column=n<br>
End_Column=n<br>
</ul>

<p align="justify">
There are a couple of different ways an image may be split up, by row,
column, or in a checker pattern.
</p>
<center><img src="http://paulbourke.net/miscellaneous/renderexamples/chunks.gif" width=594 height=145></center>

<p align="justify">
It turns out that it is normally easier to split the
image up into chunks by row, these are the easiest to paste together
automatically at the end of the rendering. Unfortunately, the easiest
file formats do deal with in code are TGA and PPM, in both these cases
writing a "nice" utility to patch the row chunks together is frustrated
by an error that POVRAY makes when writing the images for partial frames. If the
whole image is 800 x 600 say and we render row 100 to 119, the PPM
file should have the dimensions in its header state that the file is
800 x 20. Unfortunately it states that the image is 800 x 600 which
is obviously wrong and causes most image reading programs to fail!
I'd like to hear any justification there might be for this apparently
trivial error by POVRAY. [A fix for this has been submitted by Jean-Fran&ccedil;ois Wauthy
for PNG files, see <a href="http://paulbourke.net/miscellaneous/renderexamples/pngfix.c">pngfix.c</a>]
</p>

For example the ini file might contain the following<br>
<ul>
Height=600<br>
Width=800<br>
Start_Row=100<br>
End_Row=119<br>
</ul>

<p align="justify">
A crude C utility to patch together a collection of PPM files of the
form filename_nnnn.ppm, is given here <a href="http://paulbourke.net/miscellaneous/renderexamples/combineppm.c">(combineppm.c)</a>.
You can easily modify it for any
file naming conventions you choose that are different from those used
here.
</p>

<p align="justify">
So, the basic procedure if you have N machines on which to render your
scene is to create N ini files, each one rendering the appropriate row chunk.
Each ini file creates one output image file, in this case, in PPM format.
When all the row chunks are rendered the image files are stuck together.
</p>

<p align="justify">
How you submit the ini files to the available machines will be left up the
reader as it is likely to be slightly different in each environment. Two
common methods are: using rsh with the povray command line prompt, or 
writing a simple application for parallel libraries such as MPI or PVM.
The later two have the advantage that they can offer a degree of 
automatic error recovery if a row chunk fails to render for some reason.
</p>

<p align="justify">
The following crude C code <a href="http://paulbourke.net/miscellaneous/renderexamples/makeset.c">(makeset.c)</a> 
illustrates how the ini files might be automatically created. Of course
you can add any other options you like to the ini file.
The basic arithmetic for the start and stop row chunks is given below,
note that POVRAY starts its numbering from row 1 not 0!
</p>
<ul>
Start_Row=(i * HEIGHT) / N + 1<br>
End_Row=((i + 1) * HEIGHT) / N
</ul>

<p align="justify">
With regard to performance and efficiency.....if each row chunk takes about
the same time to render then one gets a linear improvement with the number
of processors available. (This assumes that the rendering time is much longer
compared to the scene loading time). Unfortunately this is not always the
case, the rows across the sky might take a trivial length of time to render
while the rows that intersect the interesting part of the scene might take
a lot longer. In this case the machines that rendered the fast portions
will stand idle for most of the time. For example consider the following
scene rendered simultaneously in equal height 
slices on 48 machines, there is over
a factor 1000 in the rendering time for the dark row chunks compared to the
lighter shaded row chunks. In this case the cause is easy to determine,
any row with a tree blows out the rendering time.
</p>
<center><img src="http://paulbourke.net/miscellaneous/renderexamples/rendertime.gif" width=473 height=615></center>

<p align="justify">
One way around this is to split the scene into many more
row chunks than there are computers and write a utility that submits jobs
to machines as they become free. This isn't hard to do if you base your
rendering around rsh and it is reasonably easy with MPI or PVM once
you understand how to use those libraries.
</p>

<table width=100% cellspacing=0 cellpadding=0><tr><td valign=top>
<p align="justify">
Another and perhaps neater way is to create row chunks of different
heights according to the estimated rendering time. The script used to
render the final image can be modified to render a much smaller image
with the same number of row chunks. An estimate of the time for the
different rows can be used to create narrow row chunks in the complex
regions and wide row chunks in the fast rendering regions. So, for the
example above, the bottom part of the image might be rendered with
row chunks only a few pixels high while the top portion would be rendered
with much taller chunks.
</p>
</td><td valign=top width=150 align=right>
<img src="http://paulbourke.net/miscellaneous/renderexamples/rowchunks.gif" width=191 height=142>
</td></tr></table>

<p align="justify">
<b>Note</b><br>
There is an inefficiency as the chunks become narrower and antialiasing is
used. PovRay will normally reuse traced rays when it can for adjacent
pixels, for example, the filled circles below are only calculated once
when PovRay is calculating the pixels shown (blue) but they will calculated
twice if the image is split and the pixels calculated separately.
</p>
<center><img src="http://paulbourke.net/miscellaneous/renderexamples/antialias.gif" width=356 height=324></center>
<p>

<p align="justify">
All these techniques assume one has a scene that takes a significant
time to render. The experimentation described above was performed on
a scene provided by Stefan Viljoen that for fairly obvious reasons (trees)
is extremely CPU demanding. If you would like to experiment yourself,
the model files are provided here (<a href="http://paulbourke.net/miscellaneous/renderexamples/overf.tar.gz">overf.tar.gz</a>).
The scene, as provided, rendered with the following ini file took
just over 16 hours on a farm of 48 identical DEC XP1000 workstations.
</p>
<ul>
Width=1200<br>
Height=900<br>
Antialias=On<br>
Antialias_Threshold=0.3<br>
Output_File_Name=overf.ppm<br>
Input_File_Name=overf.pov<br>
Output_File_Type=P<br>
Quality=9<br>
Radiosity=off<br>
</ul>

A reduced version of the rendering is shown below<p>
<center><img src="http://paulbourke.net/miscellaneous/renderexamples/overf.jpeg" border=1 width=600 height=450></center><p>

<p><br><br><br><p> 


<center>
<h3>Load Balancing for Distributed PovRay Rendering</h3>
Written by <a href="../index.html">Paul Bourke</a>
<p>
<a href="http://paulbourke.net/miscellaneous/renderexamples/gena.pov">MegaPovPlus model</a> graciously contributed by Gena Obukhov.
<p>
Rendered using MegaPovPlus on the <br>
Swinburne University Astrophysics and Supercomputing farm of <br>
64+ Dec Alpha processors.<p>
August 2000
</center>

<table width=100%><tr><td valign="justify">
<p align="justify">
When distributing rendering among various machines in a farm,
cluster, or SMP machine it is critical to get the most out of
the available processors. Keeping all processors busy is
known as "load balancing".
</p>

<p align="justify">
To illustrate why some sort of load balancing is desirable consider the
following image rendered in PovRay. The whole image at a reasonable
resolution takes in the order of hundreds of hours to render, the details
aren't important suffice to say there are often scenes that
require significant rendering time. 
</p>

<p align="justify">
One way to render this scene on a number of computers is to split it
into N column strips and send each strip to a different machine.
In this example the strips are shown in red, each is 1/16 of the 
image wide since the scene is distributed to 16 machines.
The strips as they are completed are stitched back together to
form the complete image. The first thing one finds with this and
any other scheme for splitting up an image is that some pieces
render faster than others, often the differences are significant.
</p>
</td><td valign="justify" align="right">
<a href="http://paulbourke.net/miscellaneous/renderexamples/equalsplit.jpg">
<img width="300" height="263" src="http://paulbourke.net/miscellaneous/renderexamples/equalsplitsmall.jpg"></a>
</td></tr></table>
<p>

<table width=100%><tr><td valign="top">
<a href="http://paulbourke.net/miscellaneous/renderexamples/loadsplit.jpg">
<img width="300" height="263" src="http://paulbourke.net/miscellaneous/renderexamples/loadsplitsmall.jpg"></a>
</td><td valign="top">
<p align="justify">
The profile at the top of the above image gives the approximate
rendering time for each strip. For this scene it is easy to see that the
rendering time is dependent on the number of "bubbles" in the strip.
So, by splitting up the image in these equal size portions the whole image
isn't ready until the slowest strip has finished, in this case the
second strip from the left. More importantly, the machines rendering the
"easy" strips are sitting idle (a mortal sin in parallel processing)!
</p>

<p align="justify">
A straightforward way of remedying the situation is to divide up the
strips such that their width is inversely 
related to the rendering time (time consuming strips are small
and less time consuming strips are wide). This is shown
below along with the resulting  new time profile in green. 
The flatter the profile the better the load averaging and the faster the 
rendering is completed.
</p>
</td></tr></table>

<p align="justify">
The only remaining
issue is how does one determine or estimate the time profile and therefore
the width of each strip. The approach taken was to pre-render a small image,
64 pixels wide say, render it in one pixel wide columns timing each column.
The time estimates from this preview were fitted by a Bezier curve which
is then used to compute the strip width for the large rendering. A continuous
fit such as a Bezier is required since the determination of the strip
width is most easily done by integrating the time curve and splitting
it into N equal area segments.
</p>

<b>More processes isn't always better</b><p>
<p align="justify">
As a word of warning, when distributing strips to machines in a rendering
farm, more machines doesn't necessarily mean faster rendering times. This
can come about when there is a significant model sizes and the model
files reside on one central disk.
Consider a scene that takes 2 hours to render and 1 minute to load.
As the number of machines (N) is increased the rendering time (assuming
perfect load balancing) drops by 1/N but the model loading  is limited
by the disk bandwidth and when saturated the rendering machines will
wait for a time proportional to N.
This is a slightly surprising result and is relevant to many rendering 
projects where the scene descriptions (especially textures) can be large.
Note that a common option is to stagger the times that the rendering
machines start so they are not all reading from disk. While this
certainly helps the performance of the individual nodes it doesn't
improve overall rendering time.
</p>

<b>Antialiasing warning</b><p>
<p align="justify">
There is a further
consideration when rendering strips in PovRay, that is, antialiasing.
The default antialiasing mode is "type 1" which is 
adaptive, non-recursive super-sampling. A quote from the manual
"POV-Ray initially traces one ray per pixel. If the colour of a pixel differs
from its neighbours (to the left or above) by more than a threshold value then 
the pixel is super-sampled by shooting a
given, fixed number of additional rays."
The important thing here is that this form of antialiasing isn't symmetric
but depends on the left/top transition. If this is used when rendering the
strips the images won't perfectly combine when joined together. This can be
seen below, the scene is split into two halves, the image on the left uses
type 1 and the one on the right uses type 2, note the thin band at the seam
on the image on the left.
</p>
<table width=100%><tr><td width=50%>
<center>
<img width="300" height="500" src="http://paulbourke.net/miscellaneous/renderexamples/type1.png"><br>
Sampling_Method=1
</center>
</td><td width=50%>
<center>
<img src="http://paulbourke.net/miscellaneous/renderexamples/type2.png" width="300" height=500"><br>
Sampling_Method=2
</center>
</td></tr></table><p>

<p align="justify">
Another solution is to simply render the image at a higher resolution
without any antialiasing and subsample the final image with an appropriate
filter, eg: Gaussian.
</p>

<p><br><br><br><p> 


<table width=100%><tr><td valign="top">
<center>
<h3>Insomnia</h3>
July-August 2002
First Place Winner, July-August 2002<br>
<a href="http://www.irtc.org/">Internet Raytracing Competition</a>
<p>
Design and model (PovRay 3.5) by 
Gena Obukhov<br>
August 2002<p>
Rendered by <a href="../index.html">Paul Bourke</a> at<br>
Swinburne University Astrophysics and Supercomputing.
</center>

<p align="justify">
Radiosity is well known to be a CPU intensive process, certainly
this model using radiosity in PovRay 3.5 is no exception. It was rendered
across 110 (mostly P4) processors running Linux which form the Swinburne
Astrophysics cluster. The final image rendered at 1024x768
(with reasonable level of antialiasing) took about 2 hours. Load
averaging was achieved by distributing 2 pixel rows to each
processor, all the processors finished within 5 minutes of each other.
The software to achieve this was developed inhouse, it consists of
scripts to create multiple PovRay command files 
(essentially strips made by +SRnnnn +ERnnnn), a batch system that distributes
these command files to all the nodes of the cluster as they become idle, 
and finally a script to put all the images
pieces together at the end.
</p>
PovRay 3.5 radiosity settings<br>
<center><table><tr><td>
<pre>global_settings {
   radiosity {
      pretrace_start 0.08
      pretrace_end   0.01
      count 500
      nearest_count 10
      error_bound 0.02
      recursion_limit 1
      low_error_factor 0.2
      gray_threshold 0.0
      minimum_reuse 0.015
      brightness 1
      adc_bailout 0.01/2
   }
}
sky_sphere{
   pigment { color rgb <0.1,0.4,1>*1.45 }
}
</pre>
</td></tr></table>
</td><td width=10>
&nbsp;
</td><td valign="top">
<a href="http://paulbourke.net/miscellaneous/renderexamples/noradiosity.jpg">
<img src="http://paulbourke.net/miscellaneous/renderexamples/s_noradiosity.gif"></a><br>
<font size=-1>No radiosity</font>
<p>
<a href="http://paulbourke.net/miscellaneous/renderexamples/radiosity.jpg">
<img src="http://paulbourke.net/miscellaneous/renderexamples/s_radiosity.gif"></a><br>
<font size=-1>Radiosity</font>
<p>
(Click above for higher resolution version)
</td></tr></table>

</td></tr></table></center>
</body>
</html>





