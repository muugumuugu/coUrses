<html>
<head>
<link rel=StyleSheet href="../../pdbstyle.css" type="text/css" media=all>
<title>Miscellaneous Transformations and Projections</title>
</head>
<body>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<script language="JavaScript">
<!--
   if (self.location.href != top.location.href) {
      top.location.href = self.location.href;
   }
-->
</script>


<center><table width=800><tr><td>

<center>
<h1>Miscellaneous transformations and projections</h1>
<b>
In what follows are various transformations and projections, mostly as they
apply to computer graphics.
</b>
<p>
See also:<br>
<a href="../../panorama/cubemaps/index.html">Mapping to/from cube maps</a><br>
<a href="../../dome/fish2/index.html">Converting fisheye images to other projections</a><br>
</center>
<p><br><br><br><p>


<center>
<h1>Spherical Projections (Stereographic and Cylindrical)</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
EEG data courtesy of Dr Per Line<br>
December 1996, Updated December 1999
</center>

<h3>Stereographic</h3>

<p align="justify">
The stereographic projection is one way of projecting the points 
that lie on a spherical surface onto a plane. Such projections are
commonly used in Earth and space mapping where the geometry is often
inherently spherical and needs to be displayed on a flat surface such
as paper or a computer display. Any attempt to map a sphere onto a plane
requires distortion, stereographic projections are no exception and indeed
it is not an ideal approach if minimal distortion is desired. 
</p>

<p align="justify">
A physical model of stereographic projections is to imagine
a transparent sphere sitting on a plane. 
If we call the point at which the sphere touches the plane the south
pole then we place a light source at the north pole. 
Each ray from the light passes through a point on the sphere and then strikes
the plane, this is the stereographic projection of the point on the
sphere.
</p>

<p align="justify">
In order to derive the formulae for the projection of a point (x,y,z)
lying on the sphere assume the sphere is centered at the origin and is
of radius r. The plane is all the points z = -r, and the light source
is at point (0,0,r). The cross section of this arrangement is shown below
in what is commonly called a Schlegal diagram.
</p>

<center><img src="stereographic1.gif" width="467" height="308"></center><p>

<p align="justify">
Consider the equation of the line from P1 = (0,0,r) through a point
P2 = (x,y,z) on the sphere, 
<br>
<dd>P = P1 + mu (P2 - P1) . . . . . . (1)</dd>
<br>
Solving this for mu for the z component yields
<br>
<dd>r + mu (z - r) = -r</dd>
<br>
or
<br>
<dd>mu = 2r / (r - z)</dd>
<br>
This is then substituted into (1) to obtain the projection of any 
point (x,y,z)
</p>

<b>Note</b><p>
<ul>
<li>The south pole is at the center of the projected points<p>
<li>Lines of latitude project to concentric circles about (0,0,-r)<p>
<li>Lines of longitude project to rays from the point (0,0,-r)<p>
<li>There is little distortion near the south pole<p>
<li>The equator projects to a circle of radius 2r<p>
<li>The distortion increases the closer one gets to the north pole finally
  becoming infinite at the north pole.<p>
</ul>

<b>Example</b>

<p align="justify">
The following example is taken from the mapping of EEG data recorded on
an approximate hemisphere (human head). The data can be rendered on a virtual
hemisphere but as such the whole field is not readily visible from
any particular viewpoint. The best option is to view the data from
the top of the head but the effects around the rim are hard to
interpret due to the compression of information as a result of
the curvature of the surface.
</p>

<center><img src="stereographic2.gif" width="600" height="293"></center><p>

<p align="justify">
The following shows a planar projection from the hemisphere on the
left and the same data with a stereographic projection. The compression
near the rim is clearly reduced greatly improving the visibility of
the results in that region.
</p> 

<center><img src="stereographic3.gif" width="600" height="357"></center><p>

<p align="justify">
Note that in the above, after the projection has been performed,
the resulting disk is scaled by a factor of 0.5 in order to retain
the same dimensions as the hemisphere.
</p>

<h3>Cylindrical projection</h3>
Also sometimes known as a <b>cylindric</b> projection.<p>

<p align="justify">
The general cylindrical projection is one where lines of latitude are 
projected to equally spaced parallel lines and lines of longitude
are projected onto not necessarily equally spaced parallel lines. 
The diagram below illustrates the basic projection,
a line is projected 
from the centre of the sphere through each point on the sphere
until it intersects the cylinder.
</p>

<center><img src="cylindrical.gif" width="737" height="544"></center><p>

<p align="justify">
The equations are quite straightforward, if the cylinder is unwrapped
and the horizontal axis is x and the vertical axis is y (origin in the
vertical center and on the left side horizontally) then:
</p>
<center>
x = constant * alpha<br>
y = constant * tan(beta)<br>
</center>
<p>

<h3>Mercator projection</h3>

<p align="justify">
A Mercator projection is similar in appearance to a cylindrical projection
but has a different distortion in the spacing of the lines of longitude. 
Like the cylindrical projection north and south are always vertical and east
and west are always horizontal. Also it cannot represent the poles because the
mathematics have an infinity singularity there.
This is one of the more common projections used in mapping the Earth onto a flat surface. 
There is not a single Mercator projection because one can choose the maximum
value for the latitudes, a common convention is illustrated below.
</p>

<center><table><tr><td>
	<a href="earth.jpg"><img src="earth_s.jpg" width=500 height=250 border=1></a><br>
	Spherical or Equirectangular projection
</td><td width=20>
	&nbsp;
</td><td>
   <a href="earth_m.jpg"><img src="earth_ms.jpg" width=250 height=250 border=1></a><br>
	Mercator projection
</td></tr></table></center><p>

<p align="justify">
The equations for longitude and latitude in terms of normalised image coordinates (x,y)
(-1..1) are as follows.
</p>

<dd>
longitude = x * pi<br>
latitude = atan(exp(-2 * pi * y))
</dd><p>

<p align="justify">
The reverse mapping is
</p>

<dd>
x = longitude / pi<br>
y = ln((1 + sin(latitude))/(1 - sin(latitude))) / (4 pi)
</dd><p>

<center><table><tr><td>
   <a href="latitude.jpg"><img src="latitude_s.jpg" width=400 height=400 border=1></a>
</td><td width=20>
   &nbsp;
</td><td>
   <a href="longitude.jpg"><img src="longitude_s.jpg" width=400 height=400 border=1></a>
</td></tr></table></center><p>

<p align="justify">
Cylindrical projections in general have an increased vertical stretching
as one moves towards either of the poles. Indeed, the poles themselves
can't be represented (except at infinity). This stretching is reduced
in the >Mercator projection by the natural logarithm scaling.
</p>

<h3>Direct Polar, known as Spherical or Equirectangular Projection</h3>

<p align="justify">
While not strictly a projection, a common way of representing spherical
surfaces in a rectangular form is to simply use the polar angles directly
as the horizontal and vertical coordinates. Since longitude varies over
2 pi and latitude only over pi, such polar maps are normally presented
in a 2:1 ratio of width to height. The most noticeable distortion in
these maps is the horizontal stretching that occurs as one approaches the
poles from the equator, this culminates in the poles (a single point)
being stretched to the whole width of the map.
</p>

An example of such a map is given below for the Earth.<p>
<center><img src="earth.jpg" width=600 height=300></center><p>

<p align="justify">
While such maps are rarely used in cartography, they are very popular
in computer graphics since it is the standard way of texture mapping a 
sphere.....hence the popularity of maps of the Earth as shown above.
</p>


<p<br><br><br><p>


<center>
<h1>Hammer-Aitoff map projection</h1>
<h3>Conversion to/from longitude/latitude</h3>
Written by <a href="../index.html">Paul Bourke</a><br>
April 2005
</center>

<p align="justify">
An Aitoff map projection (attributed to David Aitoff circa 1889)
is a class of azimuthal projection, basically an azimuthal
equidistant projection where the longitude values are doubled (squeezing 2pi into pi) and the 
resulting 2D map is stretched in the horizontal axis to form a 2:1 ellipse. 
In a normal azimuthal projection all distances are preserved from the tangent plane point,
this is not the case for a Aitoff projection, except along the vertical and horizontal axis.
A modification to the Aitoff projection is the Hammer-Aitoff projection which has the
property of preserving equal area over the whole map.
</p>

<b>Conversion from longitude/latitude to Hammer-Aitoff coordinates (x,y)</b><p>
Consider longitude to range between -pi and pi, latitude between -pi/2 and pi/2.
<center>
<table><tr><td>
z<sup>2</sup> = 1 + cos(latitude) cos(longitude/2)
<p>
x = cos(latitude) sin(longitude/2) / z
<p>
y = sin(latitude) / z
</td></tr></table>
</center>
<p>
(x,y) are each normalised coordinates, -1 to 1.

<p><b>Conversion of Hammer-Aitoff coordinates to longitude/latitude</b><p>
<center>
<table><tr><td>
z<sup>2</sup> = 1 - x<sup>2</sup>/2 - y<sup>2</sup>/2
<p>
longitude = 2 atan(sqrt(2) x z / (2 z<sup>2</sup> - 1))
<p>
latitude = asin(sqrt(2) y z)
</td></tr></table>
</center>
<p>
The Hammer-Aitoff map is limited to where (x longitude) >= 0.
<p>

<p><b>Example: Conversion of longitude/latitude to Hammer-Aitoff coordinates</b><p>
<center><table><tr><td>
<a href="grid.gif"><img src="grid_s.gif" width=350 height=175></a><br>
Grid test pattern, eg: spherical panoramic map
</td><td>
<a href="aitoff1.gif"><img src="aitoff1_s.gif" width=350 height=175></a><br>
Resulting Hammer-Aitoff projection
</td></tr></table></center><p>

<b>Example: Conversion of Hammer-Aitoff coordinates to longitude/latitude</b><p>
<center><table><tr><td>
<a href="aitoff2.jpg"><img src="aitoff2_s.jpg" width=350 height=175></a><br>
Cosmic microwave background
</td><td>
<a href="polar.jpg"><img src="polar_s.jpg" width=350 height=175></a><br>
Spherical projection
</td></tr></table></center><p>

<p><br><br><br><p>

<center>
<h1>Transformations on the plane</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
January 1987
</center>
<p>

The following describes the 2d transformation of a point on a plane
<center><p>
<b>P</b> = ( x , y ) -> <b>P'</b> = ( x' , y' )
</center><p>

<h3>Translation</h3>
A translation (shift) by T<sub>x</sub> in the x direction and T<sub>y</sub>
in the y direction is 
<center><p>
x' = x + T<sub>x</sub><br>
y' = y + T<sub>y</sub>
</center><p>

<h3>Scaling</h3>
A scaling by S<sub>x</sub> in the x direction and S<sub>y</sub> in the
y directions about the origin is
<center><p>
x' = S<sub>x</sub> x<br>
y' = S<sub>y</sub> y
</center><p>
If S<sub>x</sub> and S<sub>y</sub> are not equal this results in
a stretching along the axis of the larger scale factor.
<br>
To scale about a particular point, first translate to the origin,
scale, and translate back to the original position. For example, to
scale about the point (x<sub>0</sub>,y<sub>0</sub>)
<center><p>
x' = x<sub>0</sub> + S<sub>x</sub> ( x - x<sub>0</sub> )<br>
y' = y<sub>0</sub> + S<sub>y</sub> ( y - y<sub>0</sub> )
</center><p>

<h3>Rotation</h3>
Rotation about the origin by an angle A in a clockwise direction is
<center><p>
x' = x cos(A) + y sin(A)<br>
y' = y cos(A) - x sin(A)
</center><p>
To rotate about a particular point apply the same technique as described
for scaling, translate the coordinate system to the origin, rotate, and
the translate back.

<h3>Reflection</h3>
Reflection about the x axis
<center><p>
x' = x<br>
y' = - y
</center><p>
Reflection about the y axis
<center><p>
x' = - x<br>
y' = y
</center><p>
Reflections about an arbitrary line involve possibly a translation 
so that a point on the line passes through the origin,
a rotation of the line to align it with one of the axis, a
reflection, inverse rotation and inverse translation.

<h3>Shear</h3>
A shear by SH<sub>x</sub> in the x axis is accomplished with
<center><p>
x' = SH<sub>x</sub> x <br>
y' = y
</center><p>
A shear by SH<sub>y</sub> in the y axis is accomplished with
<center><p>
x' = x<br>
y' = SH<sub>y</sub> y
</center><p>

<p><br><br><br><p>


<center>
<h1>Coordinate System Transformation</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
June 1996
</center>
<p>

There are three prevalent coordinate systems for describing geometry
in 3 space, Cartesian, cylindrical, and spherical (polar). They all provide
a way of uniquely defining any point in 3D.
<p>

The following illustrates the three systems.
<br>
<center><img src="coords1.gif"></center>
<p>

Equations for converting between Cartesian and cylindrical coordinates<br>
<center><img src="coords2.gif"></center>
<p>

Equations for converting between cylindrical and spherical coordinates<br>
<center><img src="coords3.gif"></center>
<p>

Equations for converting between Cartesian and spherical coordinates<br>
<center><img src="coords4.gif"></center>
<p>

<p><br><br><br><p>


<table width=100% cellpadding=0 cellspacing=0 border=0>
<tr><td width=50%>
<center>
<h1>Euler Angles</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
June 2000<p>
<a href="Aij-to-Eulerangles.pdf">Extraction of Euler angles from general rotation matrix</a><br>
by R.D. Kriz</a> (2006).
</center>
</td><td width=50%>
<center><img src="axes.gif" width=176 height=272></center>
</td></tr></table>
</p>

<p align="justify">
Rotations about each axis are often used to transform between different coordinate
systems, for example, to direct the virtual camera in a flight simulator. These
angles often go by different names, in the discussion here I will use a right
hand coordinate system (y "forward", x to the right, and z upwards). As such
rotation about the z axis will be referred to as direction, rotation about the
y axis is roll (sometimes called bank), and rotation about the x axis is pitch.
Further, a rotation will be considered positive if it is clockwise when looking
down the axis towards the origin. Other conventions will be left as an exercise
for the reader.
</p>

The three rotation matrices are given below, note that they seem asymmetric
with respect to the sign of the sin() term.<p>

Rotation by t<sub>x</sub> about the x axis<br>
<center>
<table><tr>
<td valign="center"><img src="lbracket.gif" width=7 height=85></td>
<td>
	<table>
	<tr><td>x'</td></tr><tr><td>y'</td></tr><tr><td>z'</td></tr>
	</table>
</td>
<td valign="center"><img src="rbracket.gif" width=7 height=85></td>
<td valign="center">&nbsp;=&nbsp;</td>
<td valign="center"><img src="lbracket.gif" width=7 height=85></td>
<td>
	<table>
	<tr>
	<td align="center">1</td>
	<td align="center">0</td>
	<td align="center">0</td>
	</tr>
	<tr>
	<td align="center">0</td>
	<td align="center">cos(t<sub>x</sub>)</td>
	<td align="center">sin(t<sub>x</sub>)</td>
	</tr>
	<tr>
	<td align="center">0</td>
	<td align="center">-sin(t<sub>x</sub>)</td>
	<td align="center">cos(t<sub>x</sub>)</td>
	</tr>
	</table>
</td>
<td valign="center"><img src="rbracket.gif" width=7 height=85></td>
<td valign="center"><img src="lbracket.gif" width=7 height=85></td>
<td>
	<table>
	<tr><td>x</td></tr>
	<tr><td>y</td></tr>
	<tr><td>z</td></tr>
	</table>
</td>
<td valign="center"><img src="rbracket.gif" width=7 height=85></td>
</tr></table>
</center><p>

Rotation by t<sub>y</sub> about the y axis<br>
<center>
<table><tr>
<td valign="center"><img src="lbracket.gif" width=7 height=85></td>
<td>
   <table>
   <tr><td>x'</td></tr><tr><td>y'</td></tr><tr><td>z'</td></tr>
   </table>
</td>
<td valign="center"><img src="rbracket.gif" width=7 height=85></td>
<td valign="center">&nbsp;=&nbsp;</td>
<td valign="center"><img src="lbracket.gif" width=7 height=85></td>
<td>
   <table>
   <tr>
   <td align="center">cos(t<sub>y</sub>)</td>
   <td align="center">0</td>
   <td align="center">-sin(t<sub>y</sub>)</td>
   </tr>
   <tr>
   <td align="center">0</td>
   <td align="center">1</td>
   <td align="center">0</td>
   </tr>
   <tr>
   <td align="center">sin(t<sub>y</sub>)</td>
   <td align="center">0</td>
   <td align="center">cos(t<sub>y</sub>)</td>
   </tr>
   </table>
</td>
<td valign="center"><img src="rbracket.gif" width=7 height=85></td>
<td valign="center"><img src="lbracket.gif" width=7 height=85></td>
<td>
   <table>
   <tr><td>x</td></tr>
   <tr><td>y</td></tr>
   <tr><td>z</td></tr>
   </table>
</td>
<td valign="center"><img src="rbracket.gif" width=7 height=85></td>
</tr></table>
</center><p>

Rotation angle t<sub>z</sub> about the z axis<br>
<center>
<table><tr>
<td valign="center"><img src="lbracket.gif" width=7 height=85></td>
<td>
   <table>
   <tr><td>x'</td></tr><tr><td>y'</td></tr><tr><td>z'</td></tr>
   </table>
</td>
<td valign="center"><img src="rbracket.gif" width=7 height=85></td>
<td valign="center">&nbsp;=&nbsp;</td>
<td valign="center"><img src="lbracket.gif" width=7 height=85></td>
<td>
   <table>
   <tr>
   <td align="center">cos(t<sub>z</sub>)</td>
   <td align="center">sin(t<sub>z</sub>)</td>
   <td align="center">0</td>
   </tr>
   <tr>
   <td align="center">-sin(t<sub>z</sub>)</td>
   <td align="center">cos(t<sub>z</sub>)</td>
   <td align="center">0</td>
   </tr>
   <tr>
   <td align="center">0</td>
   <td align="center">0</td>
   <td align="center">1</td>
   </tr>
   </table>
</td>
<td valign="center"><img src="rbracket.gif" width=7 height=85></td>
<td valign="center"><img src="lbracket.gif" width=7 height=85></td>
<td>
   <table>
   <tr><td>x</td></tr>
   <tr><td>y</td></tr>
   <tr><td>z</td></tr>
   </table>
</td>
<td valign="center"><img src="rbracket.gif" width=7 height=85></td>
</tr></table>
</center><p>

<p align="justify">
A characteristic of applying these transformations is that the order
is important. If the rotation matrices above are called R<sub>x</sub>(t),
R<sub>y</sub>(t), and R<sub>z</sub>(t) respectively then applying the
rotations in the order R<sub>z</sub>(t) R<sub>x</sub>(t) R<sub>y</sub>(t)
will in general result in a different result to another order, say
R<sub>x</sub>(t) R<sub>y</sub>(t) R<sub>z</sub>(t). In what follows a
particular order will be discussed and the other combinations will be
left up to the reader to derive based on the same approach. 
The particular order of rotations applied here
is to rotate about the y axis first (roll), they the x axis (pitch), then
the z axis (direction). This is perhaps the most common order is usage
in games and flight simulators.
</p>
<center><table>
<tr>
<td valign="center"><img src="lbracket.gif" width=7 height=85></td>
<td>
   <table>
   <tr><td>x'</td></tr>
   <tr><td>y'</td></tr>
   <tr><td>z'</td></tr>
   </table>
</td>
<td valign="center"><img src="rbracket.gif" width=7 height=85></td>
<td valign="center">= R<sub>z</sub>(t) R<sub>x</sub>(t) R<sub>y</sub>(t)
<td valign="center"><img src="lbracket.gif" width=7 height=85></td>
<td>
   <table>
   <tr><td>x</td></tr>
   <tr><td>y</td></tr>
   <tr><td>z</td></tr>
   </table>
</td>
<td valign="center"><img src="rbracket.gif" width=7 height=85></td>
</tr>
</table>
</center><p>

The single (combined) matrix is<p>
<center><table><tr>
<td valign="center"><img src="lbracket.gif" width=7 height=85></td>
<td>
   <table>
   <tr>
   <td align="center">
cos(t<sub>z</sub>) cos(t<sub>y</sub>) +
sin(t<sub>z</sub>) sin(t<sub>x</sub>) sin(t<sub>y</sub>)&nbsp;&nbsp;&nbsp;
	</td>
   <td align="center">
sin(t<sub>z</sub>) cos(t<sub>x</sub>)&nbsp;&nbsp;&nbsp;
	</td>
   <td align="center">
-cos(t<sub>z</sub>) sin(t<sub>y</sub>) +
sin(t<sub>z</sub>) sin(t<sub>x</sub>) cos(t<sub>y</sub>)
	</td>
   </tr>
   <tr>
   <td align="center">
-sin(t<sub>z</sub>) cos(t<sub>y</sub>) +
cos(t<sub>z</sub>) sin(t<sub>x</sub>) sin(t<sub>y</sub>)&nbsp;&nbsp;&nbsp;
	</td>
   <td align="center">
cos (t<sub>z</sub>) cos(t<sub>x</sub>)&nbsp;&nbsp;&nbsp;
	</td>
   <td align="center">
sin(t<sub>z</sub>) sin(t<sub>y</sub>) +
cos(t<sub>z</sub>) sin(t<sub>x</sub>) cos(t<sub>y</sub>)
	</td>
   </tr>
   <tr>
   <td align="center">
cos(t<sub>x</sub>) sin(t<sub>y</sub>)&nbsp;&nbsp;&nbsp;
	</td>
   <td align="center">
-sin(t<sub>x</sub>)&nbsp;&nbsp;&nbsp;
	</td>
   <td align="center">
cos(t<sub>x</sub>) cos(t<sub>y</sub>)
	</td>
   </tr>
   </table>
</td>
<td valign="center"><img src="rbracket.gif" width=7 height=85></td>
</tr></table>
</center><p>

<p>
One other requirement is given a new coordinate system how does one
derive the corresponding three Euler angles. If the orthonormal vectors
of the new coordinate system are X,Y,Z then the transformation matrix
from (1,0,0), (0,1,0), (0,0,1) to the new coordinate system is
</p>

<center><table><tr>
<td valign="center"><img src="lbracket.gif" width=7 height=85></td>
<td>
   <table>
   <tr>
   <td align="center">X<sub>x</sub></td>
   <td align="center">Y<sub>x</sub></td>
   <td align="center">Z<sub>x</sub></td>
   </tr>
   <tr>
   <td align="center">X<sub>y</sub></td>
   <td align="center">Y<sub>y</sub></td>
   <td align="center">Z<sub>y</sub></td>
   </tr>
   <tr>
   <td align="center">X<sub>z</sub></td>
   <td align="center">Y<sub>z</sub></td>
   <td align="center">Z<sub>z</sub></td>
   </tr>
   </table>
</td>
<td valign="center"><img src="rbracket.gif" width=7 height=85></td>
</tr></table><p></center>

Matching the elements of the two matrices above firstly gives<br>
<center>Y<sub>z</sub> = -sin(t<sub>x</sub>)</center><br>
so<br>
<center>t<sub>x</sub> = asin(-Y<sub>z</sub>)</center>
<p>

Also<br>
<center>cos(t<sub>x</sub>) (-sin(t<sub>y</sub>), cos((t<sub>y</sub>)) = 
(X<sub>z</sub>, Z<sub>z</sub>)</center><br>
so<br>
<center>t<sub>y</sub> = atan2(X<sub>z</sub>, Z<sub>z</sub>))</center>
<p>

And lastly<br>
<center>cos(t<sub>x</sub>) (sin(t<sub>z</sub>, cos(t<sub>z</sub>)) =
(Y<sub>x</sub>, Y<sub>y</sub>)</center><br>
so<br>
<center>t<sub>z</sub> = atan2(Y<sub>x</sub>, Y<sub>y</sub>)</center>
<p>

<b>Note:</b><p>
<ul>
<li><p align="justify">
The "programmers" function atan2() has been used above which uses the
sign of the two arguments to calculate the correct quadrant of the result, this
is in contrast to the mathematical tan() function. 
</p>
<li><p align="justify">
While the above gives particular values for t<sub>x</sub>, t<sub>y</sub>, and 
t<sub>z</sub> there are a number of cases where the solution is not unique.
That is, there are multiple combinations of Euler angles that will give the
same coordinate transformation.
</p>
</ul>

<p><br><br><br><p>


<center>
<h1>Converting between left and right hand coordinate systems</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
May 2001
</center>
<p>

<p align="justify">
Computer based modelling and rendering software seem to be split evenly
between whether they use a left hand or right hand coordinate system,
for example OpenGL uses a right hand system and PovRay a left hand system.
This document describes bow to convert model coordinates 
and/or camera attributes when transferring models from one package to another.
Each system is shown below, the difference involves how the cross product
is defined...using the so-called left or right hand rule.
</p>
<center><img src="leftright1.gif"></center>
<p align="justify">
Note that the exact orientation of the axes above is not relevant,
y need not be "pointing up", z need not be pointing "into the page".
All axes orientations are equivalent to one of the above after
a suitable rotation.
</p>

<p align="justify">
There are two ways to convert models between systems so that
the rendered results are identical. The first involves
inverting the x value (any single axes will do) of all 
vertices in the model and camera settings, the second uses the model
and camera coordinates without change but requires
a flipping of any rendered image horizontally.
In what follows, the symbols p, d, and u will represent the vectors
position, view direction, and up vector respectively.
</p>

<b>Method 1</b> - inverting the x coordinates<br>
<center><img src="leftright2.gif"></center>
<p>

<b>Method 2</b> - flipping image horizontally<br>
<p align="justify">
In this case the coordinates of the model and camera are used
unchanged when transferring from one system to the other. As can
be seen in the example below, the image ends up being horizontally
flipped.
</p>
<center><img src="leftright3.gif"></center>
<p align="justify">
This is usually the preferred method, perhaps mainly because it avoids
worrying about which system one is using until the end of the
process, the image flipping can be built into post processing image
tools. Also, it means that if one makes a mistake regarding which
system is being using it doesn't affect the rendered result nearly
as seriously than if one got made a mistake in the first method.
</p>

<p align="justify">
You may wonder why it is the horizontal axis that is flipped, what
is so special about it? That arises because the flip is actually
about the up vector which is traditionally vertical on the rendered
image.
</p>

<p><br><br><br><p>


<center>
<h1>Classification of 3D to 2D projections</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
December 1994
</center>

<p align="justify"> 
The following classifies the most common projections used to represent 3D
geometry on a 2D surface. Each projection type has a brief comment describing
its unique characteristic.
</p>

<center><IMG SRC="projections1.gif" width="480" height="589"></center><p>

<h3>Oblique projections</h3>

<table width=100%><tr><td valign="top">
<p align="justify">
An oblique projection is a parallel projection where the projecting 
lines are not perpendicular to the projection plane.
</p>
The precise projection is defined by two angles 
<IMG SRC="obliqueproj11.gif" width="10" height="8">
and 
<IMG SRC="obliqueproj10.gif" width="11" height="10">.
<br>
Two common projections are:<p>
<ul>
<li>Cavalier projection 
tan(<IMG SRC="obliqueproj11.gif" width="10" height="8">) =1 or 
<IMG SRC="obliqueproj11.gif" width="10" height="8"> = 45 degrees
<p>
<li>Cabinet projection tan(<IMG SRC="obliqueproj11.gif" width="10" height="8">)
= 2 or 
<IMG SRC="obliqueproj11.gif" width="10" height="8"> = 63.4 degrees
<p>
</ul>
</td><td>
<center><IMG SRC="obliqueproj1.gif" width="407" height="218"></center>
</td></tr></table><p>

<table width=100%><tr><td valign="top">
<p align="justify">
For either one of the above projections values of 
<IMG SRC="obliqueproj10.gif" width="11" height="10">
most commonly employed are 45 degrees and 30 degrees. 
Coordinate transformations for a general oblique projection are
</p>
</td><td>
<center><IMG SRC="obliqueproj9.gif" width="122" height="94"></center>
</td></tr></table><p>

<b>Note:</b><p>
<ul>
<li><p align="justify"> 
The first two transformations for xp and yp are all that is required to
derive the transformation from 3D onto the 2D projection plane. The third
trivial) transformation for z illustrates how an oblique projection is
equivalent to a z axis shear followed by a parallel orthographic projection
onto a x-y projection plane.
</p>
<li><p align="justify"> 
The x and y coordinate values within each z plane are shifted by an amount
proportional to the z value of the plane. 
(ie: cos(<IMG SRC="obliqueproj10.gif" width="11" height="10">)
/ tan(<IMG SRC="obliqueproj11.gif" width="10" height="8">))
so angles, distances, and parallel lines in any z plane are projected
accurately, without distortion.
</p>
</ul>

<b>Examples</b><p>

<center>
<table cellpadding=10><tr><td valign="top">
Cavalier projection 
<IMG SRC="obliqueproj10.gif" width="11" height="10"> = 45
</td><td>
<IMG SRC="obliqueproj13.gif" width="245" height="245">
</td></tr><tr><td>
Cavalier projection 
<IMG SRC="obliqueproj10.gif" width="11" height="10"> = 30
</td><td>
<IMG SRC="obliqueproj15.gif" width="267" height="215">
</td></tr><tr><td>
Cabinet projection 
<IMG SRC="obliqueproj10.gif" width="11" height="10"> = 45
</td><td>
<IMG SRC="obliqueproj17.gif" width="194" height="194">
</td></tr><tr><td>
Cabinet projection 
<IMG SRC="obliqueproj10.gif" width="11" height="10"> = 30
</td><td>
<IMG SRC="obliqueproj19.gif" width="206" height="180"><p>
</td></tr></table><p>
</center>

<p><br><br><br><p>


<center>
<h1>Correction of Planar (Stretch) Distortion</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
November 1989
</center>

<p align="justify">
The following mathematics and illustrations came from a project to undistort
photographs taken of a flat piece of land. The photographs were taken
from various angles to the ground and thus needed to be "straightened" so that
relative area measures could be taken. The same technique could of course be
used to intentionally distort rectangular areas.
</p>

<p align="justify">
The conventional (Cartesian) method of uniquely specifying a point in 2
dimensions is by two coordinates. For the unit square below these two
coordinates will be called mu and delta, they are the relative distances along
the horizontal and vertical edges of the square.
</p>

<center><IMG SRC="distort1.gif"></center><p>

<p align="justify">
If the square above is linearly distorted (stretched) the internal coordinate
mesh is also distorted but the relative distances (mu and delta) of a point P
along two connected edges remains the same.
</p>

<center><IMG SRC="distort2.gif"></center><p>

<p align="justify">
To undistort any point P within the polygon we need to find the ratios mu and
delta.  Point A is given by:
</p>

<center><IMG SRC="distort3.gif"></center><p>

Point B is given by<p>

<center><IMG SRC="distort4.gif"></center><p>

For the point P along the line AB<p>

<center><IMG SRC="distort5.gif"></center><p>

Substituting for A and B, equation 1<p>

<center><IMG SRC="distort6.gif"></center><p>

<p align="justify">
This gives two equations, one for the x coordinate and the other for the y
coordinate, equation 2,3
</p>

<center><IMG SRC="distort7.gif"></center><p>

<p align="justify">
Dividing equation (2) by (3) removes delta, solving for mu gives a quadratic of
the form
</p>

<center><IMG SRC="distort8.gif"></center><p>

where<p>

<center><IMG SRC="distort9.gif"></center><p>

After solving the quadratic for mu, delta can be calculated from (1) above. 


<p><br><br><br><p>


<table width=100% cellpadding=4><tr><td valign="top">
<center>
<h1>Anamorphic Projections</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
January 1991<p>
Source: <a href="glues.h">glues.h</a> and <a href="glues.c">glues.c</a>.
</center>
 
<p align="justify">
Anamorphism is a Macintosh utility which takes a line drawing as a PICT file
and performs various non-linear distortions upon it. The distortions available
have been chosen from those which have been used historically by artists (and
forgers).
</p>
</td><td>
<IMG SRC="anamorphism1.gif" width="353" height="352">
</td></tr></table><p>

<p align="justify">
Each of the different distortions will be illustrated by using the following
simple diagram.
</p>

<center><IMG SRC="anamorphism2.gif" width="297" height="297"></center><p>

<p align="justify">
For the following examples an additional grid will be placed over the image to
further illustrate the nature of the distortion. Each type of distortion has
controls associated with it, these are indicated by black "blobs" at the
current position of the control points. To vary these parameters simply click
and drag the control points.
</p>

<center>
<table><tr><td valign="justify">
Cylindrical
</td><td>
<center><IMG SRC="anamorphism3.gif" width="297" height="297"></center>
</td></tr><tr><td>
Conical
</td><td>
<center><IMG SRC="anamorphism4.gif" width="297" height="297"></center>
</td></tr><tr><td>
Spherical
</td><td>
<center><IMG SRC="anamorphism5.gif" width="297" height="297"></center>
</td></tr><tr><td>
Parabolic
</td><td>
<center><IMG SRC="anamorphism6.gif" width="297" height="297"></center>
</td></tr><tr><td>
Rectonical
</td><td>
<center><IMG SRC="anamorphism7.gif" width="297" height="297"></center>
</td></tr></table><p>
</center>

<b>Notes</b><p>
<ul>
<li><p align="justify">
The only PICT drawing primitives which can be used are line segments.
</p>
<li><p align="justify">
Since the distortions are non linear, the distorted points alone a line
segment do not lie in a straight line between the distorted end points of the
line segment. Thus each line is split into a number of line segments in order
to approximate the generally curved nature of the distorted lines. The result
of this is distorted drawings with a much larger number of line segments.
</p>
</ul>

<center>
Reflective balls in the main street of Adelaide, Australia.<p>
<img src="adelaideballs.jpeg" width="320" height="592">
<img src="adelaideballs2.jpeg" width="320" height="592">
</center><p>

<br><br><br>

<center>
<h1>Mappings in the Complex Plane</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
July 1997
</center>

<p align="justify">
The following illustrates the general form of various mappings
in the complex plane. The mappings are applied to part of a 
unit disk centered at the origin as shown on the left hand side.
The circle is filled with rays from the origin and arcs centered
about the origin. 
A series of coloured rays further illustrate the mapping orientation.
</p>

<center>
<table cellspacing=10><tr><td width=50%>
<h3>z</h3><img src="360.gif">
</td><td width=50%>
<h3>exp(z)</h3><img src="exp.gif">
</td></tr><tr><td>
<h3>z</h3><img src="180.gif">
</td><td width=50%>
<h3>log(z)</h3><img src="log.gif">
</td></tr><tr><td>
<h3>z</h3><img src="180.gif">
</td><td width=50%>
<h3>sqrt(z)</h3><img src="sqrt.gif">
</td></tr><tr><td>
<h3>z</h3><img src="90.gif">
</td><td width=50%>
<h3>asin(z)</h3><img src="asin.gif">
</td></tr><tr><td>
<h3>z</h3><img src="90.gif">
</td><td width=50%>
<h3>acos(z)</h3><img src="acos.gif">
</td></tr><tr><td>
<h3>z</h3><img src="360.gif">
</td><td width=50%>
<h3>atan(z)</h3><img src="atan.gif">
</td></tr><tr><td>
<h3>z</h3><img src="360.gif">
</td><td width=50%>
<h3>sin(z)</h3><img src="sin.gif">
</td></tr><tr><td>
<h3>z</h3><img src="180.gif">
</td><td width=50%>
<h3>cos(z)</h3><img src="cos.gif">
</td></tr><tr><td>
<h3>z</h3><img src="360.gif">
</td><td width=50%>
<h3>tan(z)</h3><img src="tan.gif">
</td></tr><tr><td>
<h3>z</h3><img src="360.gif">
</td><td width=50%>
<h3>sinh(z)</h3><img src="sinh.gif">
</td></tr><tr><td>
<h3>z</h3><img src="180.gif">
</td><td width=50%>
<h3>cosh(z)</h3><img src="cosh.gif">
</td></tr><tr><td>
<h3>z</h3><img src="360.gif">
</td><td width=50%>
<h3>tanh(z)</h3><img src="tanh.gif">
</td></tr><tr><td>
<h3>z</h3><img src="180.gif">
</td><td width=50%>
<h3>z<sup>2</sup></h3><img src="square.gif">
</td></tr><tr><td>
<h3>z</h3><img src="180.gif">
</td><td width=50%>
<h3>z<sup>2</sup> + z</h3><img src="z2z.gif">
</td></tr><tr><td>
<h3>z</h3><img src="180.gif">
</td><td width=50%>
<h3>1 / (z + 1)<h3><img src="1dzp1.gif">
</td></tr><tr><td>
<h3>z</h3><img src="180.gif">
</td><td width=50%>
<h3>(z - 1) / (z + 1)<h3><img src="zm1zp1.gif">
</td></tr><tr><td>
<h3>z</h3><img src="180.gif">
</td><td width=50%>
<h3>(z<sup>2</sup> - 1) / (z<sup>2</sup> + 1)<h3><img src="z2m1z2p1.gif">
</td></tr><tr><td>
<h3>z</h3><img src="180.gif">
</td><td width=50%>
<h3>(z - a) / (z + b)<h3><img src="logzazb.gif">
</td></tr><tr><td>
<h3>z</h3><img src="180.gif">
</td><td width=50%>
<h3>(z<sup>2</sup> + z - 1) / (z<sup>2</sup> + z + 1)
<h3><img src="z2zm1z2zp1.gif">
</td></tr><tr><td>
<h3>z</h3><img src="180.gif">
</td><td width=50%>
<h3>(z<sup>2</sup> + z + 1) / (z + 1)
<h3><img src="z2zp1zp1.gif">
</td></tr></table>
</center><p>

<!--
<table width=50% align=right><tr><td width=100%>
<p align="justify">
Mapping software written by myself, interface using the FORMs
library, rendering with GeomView, conducted on a SGI Indigo-2.
</p>
<img src="mapping.gif">
</td></tr></table>
-->

<p><br><br><br><p>


<center>
<h1>World to Screen Projection Transformation</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
December 1994
</center>

<p align="justify">
The representation by computer of 3 dimensional forms is normally restricted to
the projection onto a plane, namely the 2 dimensional computer screen or
hard copy device. The following is a procedure that transforms points in 3
dimensional space to screen coordinates given a particular coordinate system,
camera and projection plane models. This discussion describes the mathematics
required for a perspective projection including clipping to the projection
pyramid with a front and back cutting plane. It assumes the projection plane to
be perpendicular to the view direction vector and thus it does not allow for
oblique projections.
</p>

<p align="justify">
Included in the appendices is source code (written in the C programming
language) implementing all the processes described.
</p>

<b>Coordinate system</b><br>
<p align="justify">
In what follows a so called right handed coordinate system is used, it has the
positive x axis to the right, the positive z axis upward, and the positive y
axis forward (into the screen or page).
</p>
<center><IMG SRC="transform1.gif"></center>
<p align="justify">
Conversion between this and other coordinate systems simply involves the
swapping and/or negation of the appropriate coordinates.
</p>

<b>Camera model</b><br>
<p align="justify">
The camera is fundamentally defined by its position (from), a point along the
positive view direction vector (to), a vector defining "up" (up), and a
horizontal and vertical aperture (angleh, anglev).<p>
These parameters are illustrated in the following figure.
<br>
<center><IMG SRC="transform2.gif"></center>
<p>
One obvious restriction is that the view direction must not be collinear with
the up vector. In practical implementations, including the one given in the
appendices, the up vector need not be a unit vector.
</p>

<p align="justify">
Other somewhat artificial variables in the camera model used here are front and
back clipping planes, a perspective/oblique projection flag, and a
multiplicative zoom factor. The clipping planes are defined as positive
distances along the view direction vector, in other words they are
perpendicular to the view direction vector. As expected all geometry before the
front plane and beyond the back plane is not visible. All geometry which
crosses these planes is clipped to the appropriate plane. Thus geometry visible
to a camera as described here lies within a truncated pyramid.
</p>
<center><IMG SRC="transform3.gif"></center>
<p>

<b>Screen model</b><br>
<p align="justify">
The projection plane (computer screen or hard copy device) can be defined in
many ways. Here the central point, width and height are used. The following
will further assume the unfortunate convention, common in computer graphics
practice, that the positive vertical axis is downward. The coordinates of the
projection space will be referred to as (h,v).
</p>
<center><IMG SRC="transform4.gif"></center>
<p align="justify">
Note that normally in computer windowing systems the window area is defined as
an rectangle between two points (left,top) and (right,bottom). Transforming
this description into the definition used here is trivial, namely
</p>
   horizontal center = (left + right) / 2<br>
   vertical center = (top + bottom) / 2<br>
   width = right - left<br>
   height = bottom - top<p>
<p align="justify">
The units need not be specified although they are generally pixel's, it is
assumed that there are drawing routines in the same units. It is also assumed
that the computer screen has a 1:1 aspect ratio, a least as far as the drawing
routines are concerned.
</p>

<p align="justify">
A relationship could be made between the ratio of the horizontal and vertical
camera aperture and the horizontal and vertical ratio of the display area. Here
it will be assumed that the display area (eg: window) has the same proportions
as the ratio of the camera aperture. In practice this simply means that when
the camera aperture is modified, the window size is also modified so as to
retain the correct proportions.
</p>

<b>Algorithm</b><br>
The procedure for determining where a 3D point in world coordinates would
appear on the screen is as follows:
<br>
<center><IMG SRC="transform5.gif"></center>
<p>
Transforming a line segment involves determining which piece, if any, of the
line segment intersects the view volume. The logic is shown below.
<br>
<center><IMG SRC="transform6.gif"></center>
<p>

<b>Clipping</b>
<p align="justify">
Two separate clipping processes occur. The first is clipping to the front and
back clipping planes and is done after transforming to eye coordinates. The
second is clipping to the view pyramid and is performed after transforming to
normalised coordinates at which point it is necessary to clip 2D line segments
to a square centered at the origin of length and height of 2.
</p>
<center><IMG SRC="transform7.gif"></center>
<p>

<b>Source code</b><br>
<a href="transform.c">transform.c</a>, 
<a href="transform.h">transform.h</a>.

<p><br><br><br><p>

<center>
<h1>Triangle coordinates</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
September 2020
</center>

<p align="justify">
In the following a point P is decomposed into two components, u<sub>a</sub>
and u<sub>2</sub>. The following shows the conventions and symbols used here.
</p>

<center>
	<img src="triangle1.png" width=600 height=536 border=0>
</center><p>

<p align="justify">
If the system is translated to place P<sub>0</sub> at the origin then the point P
in question can be written as.
</p>

<center>
   <img src="triangle2.png" width=144 height=27 border=0>
</center><p>

<p align="justify">
In matrix form.
</p>

<center>
   <img src="triangle3.png" width=209 height=53 border=0>
</center><p>

<p align="justify">
Which is solved as.
</p>

<center>
   <img src="triangle4.png" width=227 height=56 border=0>
</center><p>

<p align="justify">
Which expands as follows.
</p>

<center>
   <img src="triangle5.png" width=399 height=60 border=0>
</center><p>

<p><br><br><br><p>

<center>
<h1>Mapping from box to warped box</h1>
Written by <a href="../index.html">Paul Bourke</a><br>
December 2020
</center>
<p align="justify">
The following illustrates the (simple) maths for mapping a point in a box
(axis aligned) into a warped box. The warped box is defined by the values of
the 8 vertices, noting that the vertices of each face need to be coplanar.
The following applies the x cut first then y and finally z. But the cuts
can be made in any order with the same result.
</p>
<center>
	<a href="drawing.pdf">
	<img src="drawing_s.jpg" width=700 height=984 border=1></a>
</center><p>
<p align="justify">
While the above is normally used to warp points within the original box, the
maths applies perfectly well for points outside the box, as if the warped box 
also distorts the whole of space. Points within the box have u<sub>x</sub>,
u<sub>y</sub> and u<sub>z</sub> in the range of 0 to 1. Values outside this
range correspond to points outside the box.
</p>

</td></tr></table></center><p>
</body>
</html>

