<!--
<html>
<head>
<title>Scratchapixel</title>

<link rel="stylesheet" type="text/css" href="/css/scratchapixel2.css"/>
<link rel="stylesheet" type="text/css" href="/css/page.css"/>
<link rel="stylesheet" type="text/css" href="/css/code.css"/>
<link href='http://fonts.googleapis.com/css?family=Noto+Sans' rel='stylesheet' type='text/css'/>
<link href='http://fonts.googleapis.com/css?family=Open+Sans:700,400,300' rel='stylesheet' type='text/css'/>

<script type="text/javascript"
	src="/scratchapixelSDK.js">
</script>

</head>
<html>
<body onload="onload();">
<div class="code-column">
-->

<html>

<!-- Mirrored from www.scratchapixel.com/code.php?id=36&origin=/lessons/advanced-rendering/introduction-acceleration-structure by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 01 Aug 2021 17:19:54 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<!-- title should be set at this point in page.php -->
<title>Introduction to Acceleration Structures (source code)</title>

<meta name='author' content="Scratchapixel">
<meta name='copyright' content="&copy; 2009-2016 Scratchapixel">
<meta name='keywords' content='Introduction to Acceleration Structures, source code'>
<meta name='date' content=''>

<link rel="stylesheet" type="text/css" href="css/scratchapixel.css"/>
<link rel="stylesheet" type="text/css" href="css/page.css"/>

<link href='../fonts.googleapis.com/css16e1.css?family=Noto+Sans' rel='stylesheet' type='text/css'/>
<link href='../fonts.googleapis.com/css9908.css?family=Open+Sans:700,400,300' rel='stylesheet' type='text/css'/>

<!-- using the material icons from Google http://google.github.io/material-design-icons/ -->
<link rel="stylesheet" href="../fonts.googleapis.com/icone91f.css?family=Material+Icons">

<script type="text/x-mathjax-config">
MathJax.Hub.Config(
	{tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}, 
	displayAlign: "left",
	displayIndent: "1em",
	"HTML-CSS": { scale: 90 },
	jax: ["input/TeX","input/MathML","input/AsciiMath","output/HTML-CSS","output/NativeMML"],
	extensions: ["tex2jax.js","mml2jax.html","asciimath2jax.html","MathMenu.html","MathZoom.js"],
	TeX: {
		extensions: ["AMSmath.js","AMSsymbols.html","noErrors.html","noUndefined.js"]
	}}
);
</script>

<script type="text/javascript" src="../cdn.mathjax.org/mathjax/latest/MathJaxdda6.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/javascript"
	src="scratchapixelSDK.js">
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','../www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42771397-1', 'auto');
  ga('send', 'pageview');
</script>

<!-- 
https://developers.facebook.com/docs/plugins/share-button/
Include the JavaScript SDK on your page once, ideally right after the opening <body> tag.
-->

<script>
  window.fbAsyncInit = function() {
	FB.init({
	  appId      : '1535346446701691',
	  xfbml      : true,
	  version    : 'v2.1'
	});
  };

  (function(d, s, id){
	 var js, fjs = d.getElementsByTagName(s)[0];
	 if (d.getElementById(id)) {return;}
	 js = d.createElement(s); js.id = id;
	 js.src = "../connect.facebook.net/en_US/sdk.js";
	 fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script>

<script>
	!function(d,s,id) {
		var js,fjs=d.getElementsByTagName(s)[0];
		if(!d.getElementById(id)) {
			js=d.createElement(s);js.id=id;
			js.src="../platform.twitter.com/widgets.js";
			fjs.parentNode.insertBefore(js,fjs);
		}
	}(document,"script","twitter-wjs");
</script>

<link rel='stylesheet' type='text/css' href='css/responsive.css'/>
</head>

<style>
.full-page1
{
	position: relative;
	margin: 0; padding: 0; 
	width: 100%; 
	border: 1px solid red;
	color: white;
}

.full-page-header-table1
{
	display: table; 
	width: 100%;
	border: 1px solid orange;
}
</style>

<div style='display: table; width: 100%;'>
	<!-- 
		This should be the content of the top menu bar. So if you want to reuse
		this, just create a table div above and insert the section.
		The height here doesn't mater because it's controlled by the inner table.
-->
<div style='display: table-row;  height: 40px; width: 100%; background-color: #1565C0; color: white;'>
	<!-- we center the cell in the middle of the row -->
	<div style='display: table-cell; width: 100%; border: 1px none orange; vertical-align: middle; text-align: center;'>
		
		<div style='display: inline-block; position: relative; border: 1px none black; width: 670px; margin: 0 auto; padding: 0;'>			
			<!-- 
				This is our logo 
			-->
			<div style='display: inline-block; border: 2px none green;'>
				<span style='font-size: 18px; font-weight: 800;'><a href='index-2.html' style='text-decoration: none; color: white;'>Scratchapixel 2.0</a></span>
			</div>
			<!-- 
				This is login 
				The only way you can vertically center stuff here is by forcing the height of the div
				and the eight of the text to be the same
			-->
			<div style='border: 2px none green; position: absolute; right: 0;  top: 0; bottom: 0px; height: 20px; line-height: 20px; margin: auto 0;'>
				<a style="color: white; text-decoration: none;" href="https://www.facebook.com/v2.5/dialog/oauth?client_id=1682406642074489&amp;state=6241aa28239e903f6cad376e5bc19dd1&amp;response_type=code&amp;sdk=php-sdk-5.4.0&amp;redirect_uri=https%3A%2F%2Fwww.scratchapixel.com%2Ffb-callback.php%3F&amp;scope=email">Sign in</a>			</div>
			
		</div>
	</div>
</div></div>

<body onload="onload();">

<div id='fb-root'></div> <!-- that's required by FB -->
<div class="page-content">
<article><div class='lesson-title' style='padding: 0px; margin: 20px 0px 10px 0px;'><a href='lessons/advanced-rendering/introduction-acceleration-structure.html'>Introduction to Acceleration Structures</a></div><div style='box-sizing: border-box; padding: 20px 0px 0px 0px; display: inline-block; border-top: 1px none grey; width: 100%;'><div>This project contains the following files (right-click files you'd like to download):</div><a oncontextmenu='onMouseDownCodeCtxt(this, "code/upload/acceleration/acceleration.cpp")' style='display: inline-block; margin: 10px 10px 10px 0px; color: rgb(50, 100, 200);' href='code10ea.html?id=36&amp;origin=/lessons/advanced-rendering/introduction-acceleration-structure&amp;src=0'>acceleration.cpp</a><a oncontextmenu='onMouseDownCodeCtxt(this, "code/upload/acceleration/teapotdata.h")' style='display: inline-block; margin: 10px 10px 10px 0px; color: rgb(50, 100, 200);' href='codec95e.html?id=36&amp;origin=/lessons/advanced-rendering/introduction-acceleration-structure&amp;src=1'>teapotdata.h</a></div><div name='code' class='code'>//[header]
// Example of Acceleration Structures for Ray-Tracing (BBox, BVH and Grid)
//[/header]
//[compile]
// Download the acceleration.cpp and teapotdata.h file to a folder.
// Open a shell/terminal, and run the following command where the files is saved:
//
// clang++ -std=c++14 -o acceleration acceleration.cpp -O3 -DACCEL_BBOX
//
// clang++ -std=c++14 -o acceleration acceleration.cpp -O3 -DACCEL_BVH
//
// clang++ -std=c++14 -o acceleration acceleration.cpp -O3 -DACCEL_GRID
//
// You can use c++ if you don't use clang++
//
// Run with: ./acceleration. Open the file ./image.png in Photoshop or any program
// reading PPM files.
//[/compile]
//[ignore]
// Copyright (C) 2016  www.scratchapixel.com
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
//[/ignore]

#include &lt;atomic&gt;
#include &lt;memory&gt;
#include &lt;cassert&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;limits&gt;
#include &lt;cmath&gt;
#include &lt;chrono&gt;
#include &lt;queue&gt;

#ifndef M_PI
#define M_PI (3.14159265358979323846)
#endif

const float kEpsilon = 1e-8;
const float kInfinity = std::numeric_limits&lt;float&gt;::max();

std::atomic&lt;uint32_t&gt; numPrimaryRays(0);
std::atomic&lt;uint32_t&gt; numRayTriangleTests(0);
std::atomic&lt;uint32_t&gt; numRayTriangleIntersections(0);
std::atomic&lt;uint32_t&gt; numRayBBoxTests(0);
std::atomic&lt;uint32_t&gt; numRayBoundingVolumeTests(0);

template&lt;typename T&gt;
class Vec3
{
public:
    Vec3() : x(0), y(0), z(0) {}
    Vec3(T xx) : x(xx), y(xx), z(xx) {}
    Vec3(T xx, T yy, T zz) : x(xx), y(yy), z(zz) {}
    Vec3 operator * (const T&amp; r) const { return Vec3(x * r, y * r, z * r); }
    Vec3 operator + (const Vec3&amp; v) const { return Vec3(x + v.x, y + v.y, z + v.z); }
    Vec3 operator - (const Vec3&amp; v) const { return Vec3(x - v.x, y - v.y, z - v.z); }
    template&lt;typename U&gt;
    Vec3 operator / (const Vec3&lt;U&gt;&amp; v) const { return Vec3(x / v.x, y / v.y, z / v.z); }
    friend Vec3 operator / (const T r, const Vec3&amp; v)
    { return Vec3(r / v.x, r / v.y, r / v.z); }
    const T&amp; operator [] (size_t i) const { return (&amp;x)[i]; }
    T&amp; operator [] (size_t i) { return (&amp;x)[i]; }
    T length2() const{ return x * x + y * y + z * z; }
    friend Vec3 operator * (const float&amp;r, const Vec3&amp; v)
    { return Vec3(v.x * r, v.y * r, v.z * r); }
    friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os, const Vec3&lt;T&gt;&amp; v)
    { os &lt;&lt; v.x &lt;&lt; &quot; &quot; &lt;&lt; v.y &lt;&lt; &quot; &quot; &lt;&lt; v.z &lt;&lt; std::endl; return os; }
	T x, y, z;
};

template&lt;typename T&gt;
Vec3&lt;T&gt; cross(const Vec3&lt;T&gt;&amp; a, const Vec3&lt;T&gt;&amp; b)
{
    return Vec3&lt;T&gt;(a.y * b.z - a.z * b.y,
                   a.z * b.x - a.x * b.z,
                   a.x * b.y - a.y * b.x);
}

template&lt;typename T&gt;
T dot(const Vec3&lt;T&gt;&amp; va, const Vec3&lt;T&gt;&amp; vb)
{ return va.x * vb.x + va.y * vb.y + va.z * vb.z; }

template&lt;typename T&gt;
void normalize(Vec3&lt;T&gt;&amp; vec)
{
    T len2 = vec.length2();
    if (len2 &gt; 0) {
        T invLen = 1 / sqrt(len2);
        vec.x *= invLen, vec.y *= invLen, vec.z *= invLen;
    }
}

template&lt;typename T&gt;
class Matrix44
{
public:
    Matrix44() { /* ... define identity matrix ... */ }
    Matrix44(T m00, T m01, T m02, T m03,
             T m10, T m11, T m12, T m13,
             T m20, T m21, T m22, T m23,
             T m30, T m31, T m32, T m33)
    {
        m[0][0] = m00; m[0][1] = m01; m[0][2] = m02; m[0][3] = m03;
        m[1][0] = m10; m[1][1] = m11; m[1][2] = m12; m[1][3] = m13;
        m[2][0] = m20; m[2][1] = m21; m[2][2] = m22; m[2][3] = m23;
        m[3][0] = m30; m[3][1] = m31; m[3][2] = m32; m[3][3] = m33;
    }
    Matrix44 inverse() const { Matrix44 matInv = *this; return matInv; }
    T* operator [] (size_t i) { return &amp;m[i][0]; }
    const T* operator [] (size_t i) const { return &amp;m[i][0]; }
    T m[4][4] = {{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 1}};
};

template&lt;typename T&gt;
void matVecMult(const Matrix44&lt;T&gt;&amp; m, Vec3&lt;T&gt;&amp; v)
{
    Vec3&lt;T&gt; vt;
    vt.x = v.x * m[0][0] + v.y * m[1][0] + v.z * m[2][0],
    vt.y = v.x * m[0][1] + v.y * m[1][1] + v.z * m[2][1],
    vt.z = v.x * m[0][2] + v.y * m[1][2] + v.z * m[2][2];

    v = vt;
}

template&lt;typename T&gt;
void matPointMult(const Matrix44&lt;T&gt;&amp; m, Vec3&lt;T&gt;&amp; p)
{
    Vec3&lt;T&gt; pt;
    pt.x = p.x * m[0][0] + p.y * m[1][0] + p.z * m[2][0] + m[3][0];
    pt.y = p.x * m[0][1] + p.y * m[1][1] + p.z * m[2][1] + m[3][1];
    pt.z = p.x * m[0][2] + p.y * m[1][2] + p.z * m[2][2] + m[3][2];
    T w  = p.x * m[0][3] + p.y * m[1][3] + p.z * m[2][3] + m[3][3];
    if (w != 1) {
        pt.x /= w, pt.y /= w, pt.z /= w;
    }

    p = pt;
}

using Vec3f = Vec3&lt;float&gt;;
using Vec3b = Vec3&lt;bool&gt;;
using Vec3i = Vec3&lt;int32_t&gt;;
using Vec3ui = Vec3&lt;uint32_t&gt;;
using Matrix44f = Matrix44&lt;float&gt;;

template&lt;typename T = float&gt;
class BBox
{
public:
    BBox() {}
    BBox(Vec3&lt;T&gt; min_, Vec3&lt;T&gt; max_)
    {
        bounds[0] = min_;
        bounds[1] = max_;
    } 
    BBox&amp; extendBy(const Vec3&lt;T&gt;&amp; p)
    {
        if (p.x &lt; bounds[0].x) bounds[0].x = p.x;
        if (p.y &lt; bounds[0].y) bounds[0].y = p.y;
        if (p.z &lt; bounds[0].z) bounds[0].z = p.z;
        if (p.x &gt; bounds[1].x) bounds[1].x = p.x;
        if (p.y &gt; bounds[1].y) bounds[1].y = p.y;
        if (p.z &gt; bounds[1].z) bounds[1].z = p.z;

        return *this;
    }
    /*inline */ Vec3&lt;T&gt; centroid() const { return (bounds[0] + bounds[1]) * 0.5; }
    Vec3&lt;T&gt;&amp; operator [] (bool i) { return bounds[i]; }
    const Vec3&lt;T&gt; operator [] (bool i) const { return bounds[i]; }
    bool intersect(const Vec3&lt;T&gt;&amp;, const Vec3&lt;T&gt;&amp;, const Vec3b&amp;, float&amp;) const;
    Vec3&lt;T&gt; bounds[2] = { kInfinity, -kInfinity }; 
};

template&lt;typename T&gt;
bool BBox&lt;T&gt;::intersect(const Vec3&lt;T&gt;&amp; orig, const Vec3&lt;T&gt;&amp; invDir, const Vec3b&amp; sign, float&amp; tHit) const
{
    numRayBBoxTests++;
    float tmin, tmax, tymin, tymax, tzmin, tzmax; 
     
    tmin  = (bounds[sign[0]    ].x - orig.x) * invDir.x;
    tmax  = (bounds[1 - sign[0]].x - orig.x) * invDir.x; 
    tymin = (bounds[sign[1]    ].y - orig.y) * invDir.y; 
    tymax = (bounds[1 - sign[1]].y - orig.y) * invDir.y;

    if ((tmin &gt; tymax) || (tymin &gt; tmax)) 
        return false; 
     
    if (tymin &gt; tmin) 
        tmin = tymin; 
    if (tymax &lt; tmax) 
        tmax = tymax; 
                     
    tzmin = (bounds[sign[2]    ].z - orig.z) * invDir.z; 
    tzmax = (bounds[1 - sign[2]].z - orig.z) * invDir.z; 

    if ((tmin &gt; tzmax) || (tzmin &gt; tmax)) 
        return false; 
     
    if (tzmin &gt; tmin)
        tmin = tzmin; 
    if (tzmax &lt; tmax) 
        tmax = tzmax; 

    tHit = tmin;

    return true; 
}

template&lt;typename T&gt; inline T clamp(const T &amp;v, const T &amp;lo, const T &amp;hi)
{ return std::max(lo, std::min(v, hi)); }

class GeomPrimitive
{
public:
    GeomPrimitive(Matrix44f objectToWorld_) : 
        objectToWorld(objectToWorld_), worldToObject(objectToWorld.inverse()) 
    {}
    virtual ~GeomPrimitive() {}
    virtual bool intersect(const Vec3f&amp;, const Vec3f&amp;, float &amp;) const = 0;
    Matrix44f objectToWorld;
    Matrix44f worldToObject;
    BBox&lt;&gt; bbox;
    uint32_t test;
};

class Mesh : public GeomPrimitive
{
public:
	Mesh(
        uint32_t numPolygons,
        const std::vector&lt;uint32_t&gt;&amp; polygonNumVertsArray,
        const std::vector&lt;uint32_t&gt;&amp; polygonIndicesInVertexPool,
        std::vector&lt;Vec3f&gt; vertexPool_,
        Matrix44f objectToWorld_ = Matrix44f()) : 
        GeomPrimitive(objectToWorld_), 
        vertexPool(vertexPool_)
	{
        // pass by value (move constructor shouldn't even be called here ?
        for (uint32_t i = 0; i &lt; vertexPool.size(); ++i) {
            matPointMult(objectToWorld, vertexPool[i]);
            bbox.extendBy(vertexPool[i]);
        }
        // compute total number of triangles
        for (uint32_t i = 0; i &lt; numPolygons; ++i) {
            assert(polygonNumVertsArray[i] &gt;= 3);
            numTriangles += polygonNumVertsArray[i] - 2;
        }
        // create array to store the triangle indices in the vertex pool
        triangleIndicesInVertexPool.reserve(numTriangles * 3);
        mailbox.reserve(numTriangles); // should all be initialized with 0
        // for each face
        for (uint32_t i = 0, offset = 0, currTriangleIndex = 0; i &lt; numPolygons; ++i) {
            // for each triangle in the face
            for (uint32_t j = 0; j &lt; polygonNumVertsArray[i] - 2; ++j) {
                triangleIndicesInVertexPool[currTriangleIndex    ] = polygonIndicesInVertexPool[offset        ];
                triangleIndicesInVertexPool[currTriangleIndex + 1] = polygonIndicesInVertexPool[offset + j + 1];
                triangleIndicesInVertexPool[currTriangleIndex + 2] = polygonIndicesInVertexPool[offset + j + 2];
                currTriangleIndex += 3;
            }
            offset += polygonNumVertsArray[i];
        }
    }
    bool intersect(const Vec3f&amp;, const Vec3f&amp;, float &amp;t) const;
    uint32_t numTriangles = { 0 };
    std::vector&lt;uint32_t&gt; triangleIndicesInVertexPool;
    std::vector&lt;Vec3f&gt; vertexPool;

    // [comment]
    // Mailboxes are used by the Grid acceleration structure
    // [/comment]
    mutable std::vector&lt;uint32_t&gt; mailbox;
};

// use Moller-Trumbor method
bool rayTriangleIntersect(
    const Vec3f&amp; orig, const Vec3f &amp;dir,
    const Vec3f&amp; v0, const Vec3f&amp; v1, const Vec3f&amp; v2,
    float &amp;t, float &amp;u, float &amp;v)
{
    numRayTriangleTests++;
    Vec3f v0v1 = v1 - v0; 
    Vec3f v0v2 = v2 - v0; 
    Vec3f pvec = cross(dir, v0v2); 
    float det = dot(v0v1, pvec); 

    // ray and triangle are parallel if det is close to 0
    if (fabs(det) &lt; kEpsilon) return false;
    
    float invDet = 1 / det; 
     
    Vec3f tvec = orig - v0; 
    u = dot(tvec, pvec) * invDet; 
    if (u &lt; 0 || u &gt; 1) return false; 
                 
    Vec3f qvec = cross(tvec, v0v1); 
    v = dot(dir, qvec) * invDet; 
    if (v &lt; 0 || u + v &gt; 1) return false; 
                             
    t = dot(v0v2, qvec) * invDet; 
    
    numRayTriangleIntersections++;

    return true; 
}

bool Mesh::intersect(const Vec3f&amp; rayOrig, const Vec3f&amp; rayDir, float &amp;tNear) const
{
    // naive approach, loop over all triangles in the mesh and return true if one 
    // of the triangles at least is intersected
    float t, u, v;
    uint32_t intersectedTriIndex;
    bool intersected = false;
    // tNear should be set inifnity first time this function is called and it 
    // will get eventually smaller as the ray intersects geometry
    for (uint32_t i = 0; i &lt; numTriangles; ++i) {
        if (rayTriangleIntersect(rayOrig, rayDir, 
            vertexPool[triangleIndicesInVertexPool[i * 3]],
            vertexPool[triangleIndicesInVertexPool[i * 3 + 1]],
            vertexPool[triangleIndicesInVertexPool[i * 3 + 2]], t, u, v) &amp;&amp; t &lt; tNear)
        {
            tNear = t;
            intersectedTriIndex = i;
            intersected = true;
        }
    }

    return intersected;
}

#include &quot;teapotdata.h&quot;

Vec3f evalBezierCurve(const Vec3f *P, const float &amp;t) 
{ 
    float b0 = (1 - t) * (1 - t) * (1 - t); 
    float b1 = 3 * t * (1 - t) * (1 - t); 
    float b2 = 3 * t * t * (1 - t); 
    float b3 = t * t * t; 
                     
    return P[0] * b0 + P[1] * b1 + P[2] * b2 + P[3] * b3; 
} 
 
Vec3f evalBezierPatch(const Vec3f *controlPoints, const float &amp;u, const float &amp;v) 
{ 
    Vec3f uCurve[4]; 
    for (size_t i = 0; i &lt; 4; ++i) 
        uCurve[i] = evalBezierCurve(controlPoints + 4 * i, u); 

    return evalBezierCurve(uCurve, v); 
}

Vec3f derivBezier(const Vec3f *P, const float &amp;t) 
{ 
    return -3 * (1 - t) * (1 - t) * P[0] + 
        (3 * (1 - t) * (1 - t) - 6 * t * (1 - t)) * P[1] + 
        (6 * t * (1 - t) - 3 * t * t) * P[2] + 
        3 * t * t * P[3]; 
}

Vec3f dUBezier(const Vec3f* controlPoints, float u, float v)
{ 
    Vec3f P[4]; 
    Vec3f vCurve[4]; 
    for (size_t i = 0; i &lt; 4; ++i) { 
        P[0] = controlPoints[i]; 
        P[1] = controlPoints[4 + i]; 
        P[2] = controlPoints[8 + i]; 
        P[3] = controlPoints[12 + i]; 
        vCurve[i] = evalBezierCurve(P, v); 
    } 

    return derivBezier(vCurve, u);
}

Vec3f dVBezier(const Vec3f* controlPoints, float u, float v) 
{ 
    Vec3f uCurve[4]; 
    for (size_t i = 0; i &lt; 4; ++i) { 
        uCurve[i] = evalBezierCurve(controlPoints + 4 * i, u); 
    } 

    return derivBezier(uCurve, v); 
}

std::vector&lt;std::unique_ptr&lt;const Mesh&gt;&gt; createUtahTeapot()
{
    Matrix44f rotate90(1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1);
    std::vector&lt;std::unique_ptr&lt;const Mesh&gt;&gt; meshes;
    uint32_t width = 8, height = 8;
    uint32_t numPolygons = width * height;
    std::vector&lt;uint32_t&gt; polyNumVertsArray(numPolygons, 4);
    std::vector&lt;uint32_t&gt; polyIndicesInVertPool(numPolygons * 4);
    // set indices 
    for (uint32_t y = 0, offset = 0; y &lt; height; ++y) {
        for (uint32_t x = 0; x &lt; width; ++x, offset += 4) {
            // counter-clockwise to get the normal pointing in the right direction
            polyIndicesInVertPool[offset    ] = (width + 1) * y + x;
            polyIndicesInVertPool[offset + 3] = (width + 1) * y + x + 1;
            polyIndicesInVertPool[offset + 2] = (width + 1) * (y + 1) + x + 1;
            polyIndicesInVertPool[offset + 1] = (width + 1) * (y + 1) + x;
        }
     }
    Vec3f controlPoints[16];
    for (uint32_t i  = 0; i &lt; kTeapotNumPatches; ++i) {
        std::vector&lt;Vec3f&gt; vertPool((width + 1) * (height + 1));
        for (uint32_t j = 0; j &lt; 16; ++j) {
            controlPoints[j].x = teapotVertices[teapotPatches[i][j] - 1][0], 
            controlPoints[j].y = teapotVertices[teapotPatches[i][j] - 1][1], 
            controlPoints[j].z = teapotVertices[teapotPatches[i][j] - 1][2]; 
        }
        for (uint32_t y = 0, currVertIndex = 0; y &lt;= height; ++y) {
            float v = y / (float)height;
            for (uint32_t x = 0; x &lt;= width; ++x, ++currVertIndex) {
                float u = x / (float)width;
                vertPool[currVertIndex] = evalBezierPatch(controlPoints, u, v);
                matVecMult(rotate90, vertPool[currVertIndex]);
                Vec3f dU = dUBezier(controlPoints, u, v);
                Vec3f dV = dVBezier(controlPoints, u, v);
                Vec3f N = cross(dU, dV);
            }
        }
        
        meshes.emplace_back(new Mesh(numPolygons, polyNumVertsArray, polyIndicesInVertPool, vertPool));
    }

    return meshes;
}

void makeScene(std::vector&lt;std::unique_ptr&lt;const Mesh&gt;&gt;&amp; meshes)
{
    meshes = std::move(createUtahTeapot());
}

template&lt;typename T&gt;
inline
T degToRad(const T&amp; angle) { return angle / 180.f * M_PI; }

struct Options
{
    float fov = { 90 };
    uint32_t width = { 640 };
    uint32_t height = { 480 };
    Matrix44f cameraToWorld, worldToCamera;
};

// [comment]
// The most basic acceleration class (the parent class of all the other acceleration structures)
// could have a *pure* virtual intersect() method but instead we decided in this implementation
// to have it supporting the basic ray-mesh intersection routine.
// [/comment]
class AccelerationStructure
{
public:
    // [comment]
    // We transfer owner ship of the mesh list to the acceleration structure. This makes
    // more sense from a functional/structure stand point because the objects/meshes themselves
    // should be destroyed/deleted when the acceleration structure is being deleted
    // Ideally this means the render function() itself should be bounded (in terms of lifespan)
    // to the lifespan of the acceleration structure (aka we should wrap the accel struc instance
    // and the render method() within the same object, so that when this object is deleted,
    // the render function can't be called anymore.
    // [/comment]
    AccelerationStructure(std::vector&lt;std::unique_ptr&lt;const Mesh&gt;&gt;&amp; m) : meshes(std::move(m)) {}
    virtual ~AccelerationStructure() {}
    virtual bool intersect(const Vec3f&amp; orig, const Vec3f&amp; dir, const uint32_t&amp; rayId, float&amp; tHit) const
    {
        // [comment]
        // Because we don't want to change the content of the mesh itself, just get a point to it so
        // it's safer to make it const (which doesn't mean we can't change its assignment just that
        // we can't do something like intersectedMesh-&gt;color = blue. You would get something like:
        // &quot;read-only variable is not assignable&quot; error message at compile time)
        // [/comment]
        const Mesh* intersectedMesh = nullptr;
        float t = kInfinity;
        for (const auto&amp; mesh: meshes) {
            if (mesh-&gt;intersect(orig, dir, t) &amp;&amp; t &lt; tHit) {
                intersectedMesh = mesh.get();
                tHit = t;
            }
        }

        return (intersectedMesh != nullptr);
    }
protected:
    const std::vector&lt;std::unique_ptr&lt;const Mesh&gt;&gt; meshes;
};

// [comment]
// Implementation of the ray-bbox method. If the ray intersects the bbox of a mesh then
// we test if the ray intersects the mesh contained by the bbox itself.
// [/comment]
class BBoxAcceleration : public AccelerationStructure
{
public:
    BBoxAcceleration(std::vector&lt;std::unique_ptr&lt;const Mesh&gt;&gt;&amp; m) : AccelerationStructure(m) {}
    
    // [comment]
    // Implement the ray-bbox acceleration method. The method consist of intersecting the
    // ray against the bbox of the mesh first, and if the ray inteesects the boudning box
    // then test if the ray intersects the mesh itsefl. It is obvious that the ray can't
    // intersect the mesh if it doesn't intersect its boudning volume (a box in this case)
    // [/comment]
    virtual bool intersect(const Vec3f&amp; orig, const Vec3f&amp; dir, const uint32_t&amp; rayId, float&amp; tHit) const
    {
        const Mesh* intersectedMesh = nullptr;
        const Vec3f invDir = 1 / dir;
        const Vec3b sign(dir.x &lt; 0, dir.y &lt; 0, dir.z &lt; 0);
        float t = kInfinity;
        for (const auto&amp; mesh : meshes) {
            // If you intersect the box
            if (mesh-&gt;bbox.intersect(orig, invDir, sign, t)) {
                // Then test if the ray intersects the mesh and if does then first check
                // if the intersection distance is the nearest and if we pass that test as well
                // then update tNear variable with t and keep a pointer to the intersected mesh
                if (mesh-&gt;intersect(orig, dir, t) &amp;&amp; t &lt; tHit) {
                    tHit = t;
                    intersectedMesh = mesh.get();
                }
            }
        }

        // Return true if the variable intersectedMesh is not null, false otherwise
        return (intersectedMesh != nullptr);
    }
};

// [comment]
// Implementation of the Bounding Volume Hieratchy (BVH) acceleration structure
// [/comment]
class BVH : public AccelerationStructure
{
    static const uint8_t kNumPlaneSetNormals = 7;
    static const Vec3f planeSetNormals[kNumPlaneSetNormals];
    struct Extents
    {
        Extents()
        {
            for (uint8_t i = 0;  i &lt; kNumPlaneSetNormals; ++i) 
                d[i][0] = kInfinity, d[i][1] = -kInfinity;
        }
        void extendBy(const Extents&amp; e)
        {
            
            for (uint8_t i = 0;  i &lt; kNumPlaneSetNormals; ++i) {
                if (e.d[i][0] &lt; d[i][0]) d[i][0] = e.d[i][0];
                if (e.d[i][1] &gt; d[i][1]) d[i][1] = e.d[i][1];
            } 
        }
        /* inline */
        Vec3f centroid() const
        {
            return Vec3f(
                d[0][0] + d[0][1] * 0.5,
                d[1][0] + d[1][1] * 0.5,
                d[2][0] + d[2][1] * 0.5);
        }
        bool intersect(const float*, const float*, float&amp;, float&amp;, uint8_t&amp;) const;
        float d[kNumPlaneSetNormals][2];
        const Mesh* mesh;
    };

    struct Octree
    {
        Octree(const Extents&amp; sceneExtents)
        {
            float xDiff = sceneExtents.d[0][1] - sceneExtents.d[0][0];
            float yDiff = sceneExtents.d[1][1] - sceneExtents.d[1][0];
            float zDiff = sceneExtents.d[2][1] - sceneExtents.d[2][0];
            float maxDiff = std::max(xDiff, std::max(yDiff, zDiff));
            Vec3f minPlusMax(
                sceneExtents.d[0][0] + sceneExtents.d[0][1],
                sceneExtents.d[1][0] + sceneExtents.d[1][1],
                sceneExtents.d[2][0] + sceneExtents.d[2][1]);
            bbox[0] = (minPlusMax - maxDiff) * 0.5;
            bbox[1] = (minPlusMax + maxDiff) * 0.5;
            root = new OctreeNode;
        }
        
        ~Octree() { deleteOctreeNode(root); }
    
        void insert(const Extents* extents) { insert(root, extents, bbox, 0); }
        void build() { build(root, bbox); };
        
        struct OctreeNode
        {
            OctreeNode* child[8] = { nullptr };
            std::vector&lt;const Extents *&gt; nodeExtentsList; // pointer to the objects extents
            Extents nodeExtents; // extents of the octree node itself
            bool isLeaf = true;
        };
        
        struct QueueElement
        {
            const OctreeNode *node; // octree node held by this element in the queue
            float t; // distance from the ray origin to the extents of the node
            QueueElement(const OctreeNode *n, float tn) : node(n), t(tn) {}
            // priority_queue behaves like a min-heap
            friend bool operator &lt; (const QueueElement &amp;a, const QueueElement &amp;b) { return a.t &gt; b.t; }
        };

        OctreeNode* root = nullptr; // make unique son don't have to manage deallocation
        BBox&lt;&gt; bbox;

    private:
    
        void deleteOctreeNode(OctreeNode*&amp; node)
        {
            for (uint8_t i = 0; i &lt; 8; i++) {
                if (node-&gt;child[i] != nullptr) {
                    deleteOctreeNode(node-&gt;child[i]);
                }
            }
            delete node;
        }
    
        void insert(OctreeNode*&amp; node, const Extents* extents, const BBox&lt;&gt;&amp; bbox, uint32_t depth)
        {
            if (node-&gt;isLeaf) {
                if (node-&gt;nodeExtentsList.size() == 0 || depth == 16) {
                    node-&gt;nodeExtentsList.push_back(extents);
                }
                else {
                    node-&gt;isLeaf = false;
                    // Re-insert extents held by this node
                    while (node-&gt;nodeExtentsList.size()) {
                        insert(node, node-&gt;nodeExtentsList.back(), bbox, depth);
                        node-&gt;nodeExtentsList.pop_back();
                    }
                    // Insert new extent
                    insert(node, extents, bbox, depth);
                }
            }
            else {
                // Need to compute in which child of the current node this extents should
                // be inserted into
                Vec3f extentsCentroid = extents-&gt;centroid();
                Vec3f nodeCentroid = (bbox[0] + bbox[1]) * 0.5;
                BBox&lt;&gt; childBBox;
                uint8_t childIndex = 0;
                // x-axis
                if (extentsCentroid.x &gt; nodeCentroid.x) {
                    childIndex = 4;
                    childBBox[0].x = nodeCentroid.x;
                    childBBox[1].x = bbox[1].x;
                }
                else {
                    childBBox[0].x = bbox[0].x;
                    childBBox[1].x = nodeCentroid.x;
                }
                // y-axis
                if (extentsCentroid.y &gt; nodeCentroid.y) {
                    childIndex += 2;
                    childBBox[0].y = nodeCentroid.y;
                    childBBox[1].y = bbox[1].y;
                }
                else {
                    childBBox[0].y = bbox[0].y;
                    childBBox[1].y = nodeCentroid.y;
                }
                // z-axis
                if (extentsCentroid.z &gt; nodeCentroid.z) {
                    childIndex += 1;
                    childBBox[0].z = nodeCentroid.z;
                    childBBox[1].z = bbox[1].z;
                }
                else {
                    childBBox[0].z = bbox[0].z;
                    childBBox[1].z = nodeCentroid.z;
                }
                
                // Create the child node if it doesn't exsit yet and then insert the extents in it
                if (node-&gt;child[childIndex] == nullptr)
                    node-&gt;child[childIndex] = new OctreeNode;
                insert(node-&gt;child[childIndex], extents, childBBox, depth + 1);
            }
        }
        
        void build(OctreeNode*&amp; node, const BBox&lt;&gt;&amp; bbox)
        {
            if (node-&gt;isLeaf) {
                for (const auto&amp; e: node-&gt;nodeExtentsList) {
                    node-&gt;nodeExtents.extendBy(*e);
                }
            }
            else {
                for (uint8_t i = 0; i &lt; 8; ++i) {
                        if (node-&gt;child[i]) {
                        BBox&lt;&gt; childBBox;
                        Vec3f centroid = bbox.centroid();
                        // x-axis
                        childBBox[0].x = (i &amp; 4) ? centroid.x : bbox[0].x;
                        childBBox[1].x = (i &amp; 4) ? bbox[1].x : centroid.x;
                        // y-axis
                        childBBox[0].y = (i &amp; 2) ? centroid.y : bbox[0].y;
                        childBBox[1].y = (i &amp; 2) ? bbox[1].y : centroid.y;
                        // z-axis
                        childBBox[0].z = (i &amp; 1) ? centroid.z : bbox[0].z;
                        childBBox[1].z = (i &amp; 1) ? bbox[1].z : centroid.z;
                        
                        // Inspect child
                        build(node-&gt;child[i], childBBox);
                        
                        // Expand extents with extents of child
                        node-&gt;nodeExtents.extendBy(node-&gt;child[i]-&gt;nodeExtents);
                    }
                }
            }
        }
    };

    std::vector&lt;Extents&gt; extentsList;
    Octree* octree = nullptr;
public:
    BVH(std::vector&lt;std::unique_ptr&lt;const Mesh&gt;&gt;&amp; m);
    bool intersect(const Vec3f&amp;, const Vec3f&amp;, const uint32_t&amp;, float&amp;) const;
    ~BVH() { delete octree; }
};

const Vec3f BVH::planeSetNormals[BVH::kNumPlaneSetNormals] = { 
    Vec3f(1, 0, 0),
    Vec3f(0, 1, 0), 
    Vec3f(0, 0, 1), 
    Vec3f( sqrtf(3) / 3.f,  sqrtf(3) / 3.f, sqrtf(3) / 3.f), 
    Vec3f(-sqrtf(3) / 3.f,  sqrtf(3) / 3.f, sqrtf(3) / 3.f), 
    Vec3f(-sqrtf(3) / 3.f, -sqrtf(3) / 3.f, sqrtf(3) / 3.f), 
    Vec3f( sqrtf(3) / 3.f, -sqrtf(3) / 3.f, sqrtf(3) / 3.f)
};

BVH::BVH(std::vector&lt;std::unique_ptr&lt;const Mesh&gt;&gt;&amp; m) : AccelerationStructure(m)
{
    Extents sceneExtents; // that's the extent of the entire scene which we need to compute for the octree
    extentsList.reserve(meshes.size());
    for (uint32_t i = 0; i &lt; meshes.size(); ++i) {
        for (uint8_t j = 0; j &lt; kNumPlaneSetNormals; ++j) {
            for (const auto vtx : meshes[i]-&gt;vertexPool) {
                float d = dot(planeSetNormals[j], vtx);
                // set dNEar and dFar
                if (d &lt; extentsList[i].d[j][0]) extentsList[i].d[j][0] = d;
                if (d &gt; extentsList[i].d[j][1]) extentsList[i].d[j][1] = d;
            }
        }
        sceneExtents.extendBy(extentsList[i]); // expand the scene extent of this object's extent
        extentsList[i].mesh = meshes[i].get(); // the extent itself needs to keep a pointer to the object its holds
    }

    // Now that we have the extent of the scene we can start building our octree
    // Using C++ make_unique function here but you don't need to, just to learn something... 
    octree = new Octree(sceneExtents);

    for (uint32_t i = 0; i &lt; meshes.size(); ++i) {
        octree-&gt;insert(&amp;extentsList[i]);
    }

    // Build from bottom up
    octree-&gt;build();
}

bool BVH::Extents::intersect(
    const float* precomputedNumerator,
    const float* precomputedDenominator,
    float&amp; tNear,   // tn and tf in this method need to be contained
    float&amp; tFar,    // within the range [tNear:tFar]
    uint8_t&amp; planeIndex) const
{
    numRayBoundingVolumeTests++;
    for (uint8_t i = 0; i &lt; kNumPlaneSetNormals; ++i) {
        float tNearExtents = (d[i][0] - precomputedNumerator[i]) / precomputedDenominator[i];
        float tFarExtents = (d[i][1] - precomputedNumerator[i]) / precomputedDenominator[i];
        if (precomputedDenominator[i] &lt; 0) std::swap(tNearExtents, tFarExtents);
        if (tNearExtents &gt; tNear) tNear = tNearExtents, planeIndex = i;
        if (tFarExtents &lt; tFar) tFar = tFarExtents;
        if (tNear &gt; tFar) return false;
    }

    return true;
}

bool BVH::intersect(const Vec3f&amp; orig, const Vec3f&amp; dir, const uint32_t&amp; rayId, float&amp; tHit) const
{
    tHit = kInfinity;
    const Mesh* intersectedMesh = nullptr;
    float precomputedNumerator[BVH::kNumPlaneSetNormals];
    float precomputedDenominator[BVH::kNumPlaneSetNormals];
    for (uint8_t i = 0; i &lt; kNumPlaneSetNormals; ++i) {
        precomputedNumerator[i] = dot(planeSetNormals[i], orig);
        precomputedDenominator[i] = dot(planeSetNormals[i], dir);
    }

    /*
    tNear = kInfinity; // set
    for (uint32_t i = 0; i &lt; meshes.size(); ++i) {
        numRayVolumeTests++;
        float tn = -kInfinity, tf = kInfinity;
        uint8_t planeIndex;
        if (extents[i].intersect(precomputedNumerator, precomputedDenominator, tn, tf, planeIndex)) {
            if (tn &lt; tNear) {
                intersectedMesh = meshes[i].get();
                tNear = tn;
                // normal = planeSetNormals[planeIndex];
            }
        }
    }
    */
    
    uint8_t planeIndex;
    float tNear = 0, tFar = kInfinity; // tNear, tFar for the intersected extents
    if (!octree-&gt;root-&gt;nodeExtents.intersect(precomputedNumerator, precomputedDenominator, tNear, tFar, planeIndex) || tFar &lt; 0)
        return false;
    tHit = tFar;
    std::priority_queue&lt;BVH::Octree::QueueElement&gt; queue;
    queue.push(BVH::Octree::QueueElement(octree-&gt;root, 0));
    while (!queue.empty() &amp;&amp; queue.top().t &lt; tHit) {
        const Octree::OctreeNode *node = queue.top().node;
        queue.pop();
        if (node-&gt;isLeaf) {
            for (const auto&amp; e: node-&gt;nodeExtentsList) {
                float t = kInfinity;
                if (e-&gt;mesh-&gt;intersect(orig, dir, t) &amp;&amp; t &lt; tHit) {
                    tHit = t;
                    intersectedMesh = e-&gt;mesh;
                }
            }
        }
        else {
            for (uint8_t i = 0; i &lt; 8; ++i) {
                if (node-&gt;child[i] != nullptr) {
                    float tNearChild = 0, tFarChild = tFar;
                    if (node-&gt;child[i]-&gt;nodeExtents.intersect(precomputedNumerator, precomputedDenominator, tNearChild, tFarChild, planeIndex)) {
                        float t = (tNearChild &lt; 0 &amp;&amp; tFarChild &gt;= 0) ? tFarChild : tNearChild;
                        queue.push(BVH::Octree::QueueElement(node-&gt;child[i], t));
                    }
                }
            }
        }
    }

    return (intersectedMesh != nullptr);
}

// [comment]
// Implementation of the Grid acceleration structure
// [/comment]
class Grid : public AccelerationStructure
{
    struct Cell
	{
        Cell() {}
        struct TriangleDesc
        {
            TriangleDesc(const Mesh* m, const uint32_t &amp;t) : mesh(m), tri(t) {}
            const Mesh* mesh;
            uint32_t tri;
        };
		
        void insert(const Mesh* mesh, uint32_t t)
        { triangles.push_back(Grid::Cell::TriangleDesc(mesh, t)); }
        
        bool intersect(const Vec3f&amp;, const Vec3f&amp;, const uint32_t&amp;, float&amp;, const Mesh*&amp;) const;
        
        std::vector&lt;TriangleDesc&gt; triangles;
    };
public:
    Grid(std::vector&lt;std::unique_ptr&lt;const Mesh&gt;&gt;&amp; m);
    ~Grid()
    {
        for (uint32_t i = 0; i &lt; resolution[0] * resolution[1] * resolution[2]; ++i)
            if (cells[i] != NULL) delete cells[i];
        delete [] cells;
    }
    bool intersect(const Vec3f&amp;, const Vec3f&amp;, const uint32_t&amp;, float&amp;) const;
    Cell **cells;
    BBox&lt;&gt; bbox;
    Vec3&lt;uint32_t&gt; resolution;
    Vec3f cellDimension;
};

Grid::Grid(std::vector&lt;std::unique_ptr&lt;const Mesh&gt;&gt;&amp; m) : AccelerationStructure(m)
{
    uint32_t totalNumTriangles = 0;
    for (const auto&amp; m : meshes) {
        bbox.extendBy(m-&gt;bbox[0]);
        bbox.extendBy(m-&gt;bbox[1]);
        totalNumTriangles += m-&gt;numTriangles;
    }
    // Create the grid
    Vec3f size = bbox[1] - bbox[0];
    float cubeRoot = std::powf(totalNumTriangles / (size.x * size.y * size.z), 1. / 3.f);
    for (uint8_t i = 0; i &lt; 3; ++i) {
        resolution[i] = std::floor(size[i] * cubeRoot);
        if (resolution[i] &lt; 1) resolution[i] = 1;
        if (resolution[i] &gt; 128) resolution[i] = 128;
    }
    cellDimension = size / resolution;

    // [comment]
    // Allocate memory - note that we don't create the cells yet at this
    // point but just an array of pointers to cell. We will create the cells
    // dynamically later when we are sure to insert something in them
    // [/comment]
    uint32_t numCells = resolution.x * resolution.y * resolution.z;
    cells = new Grid::Cell* [numCells];
    memset(cells, 0x0, sizeof(Grid::Grid*) * numCells);
    
    for (const auto&amp; m : meshes) {
        for (uint32_t i = 0, off = 0; i &lt; m-&gt;numTriangles; ++i, off += 3) {
            Vec3f min(kInfinity), max(-kInfinity);
            const Vec3f&amp; v0 = m-&gt;vertexPool[m-&gt;triangleIndicesInVertexPool[off]];
            const Vec3f&amp; v1 = m-&gt;vertexPool[m-&gt;triangleIndicesInVertexPool[off + 1]];
            const Vec3f&amp; v2 = m-&gt;vertexPool[m-&gt;triangleIndicesInVertexPool[off + 2]];
            for (uint8_t j = 0; j &lt; 3; ++j) {
                if (v0[j] &lt; min[j]) min[j] = v0[j];
                if (v1[j] &lt; min[j]) min[j] = v1[j];
                if (v2[j] &lt; min[j]) min[j] = v2[j];
                if (v0[j] &gt; max[j]) max[j] = v0[j];
                if (v1[j] &gt; max[j]) max[j] = v1[j];
                if (v2[j] &gt; max[j]) max[j] = v2[j];
            }
            // Convert to cell coordinates
            min = (min - bbox[0]) / cellDimension;
            max = (max - bbox[0]) / cellDimension;
            uint32_t zmin = clamp&lt;uint32_t&gt;(std::floor(min[2]), 0, resolution[2] - 1);
            uint32_t zmax = clamp&lt;uint32_t&gt;(std::floor(max[2]), 0, resolution[2] - 1);
            uint32_t ymin = clamp&lt;uint32_t&gt;(std::floor(min[1]), 0, resolution[1] - 1);
            uint32_t ymax = clamp&lt;uint32_t&gt;(std::floor(max[1]), 0, resolution[1] - 1);
            uint32_t xmin = clamp&lt;uint32_t&gt;(std::floor(min[0]), 0, resolution[0] - 1);
            uint32_t xmax = clamp&lt;uint32_t&gt;(std::floor(max[0]), 0, resolution[0] - 1);
            // Loop over the cells the triangle overlaps and insert
            for (uint32_t z = zmin; z &lt;= zmax; ++z) {
                for (uint32_t y = ymin; y &lt;= ymax; ++y) {
                    for (uint32_t x = xmin; x &lt;= xmax; ++x) {
                        uint32_t index = z * resolution[0] * resolution[1] + y * resolution[0] + x;
                        if (cells[index] == NULL) cells[index] = new Grid::Cell;
                        cells[index]-&gt;insert(m.get(), i);
                    }
                }
            }
        }
    }
}

bool Grid::Cell::intersect(
    const Vec3f&amp; orig, const Vec3f&amp; dir, const uint32_t&amp; rayId,
    float&amp; tHit, const Mesh*&amp; intersectedMesh) const
{
	float uhit, vhit;
	for (uint32_t i = 0; i &lt; triangles.size(); ++i) {
        // [comment]
        // Be sure that rayId is never 0 - because all mailbox values
        // in the array are initialized with 0 too
        // [/comment]
		if (rayId != triangles[i].mesh-&gt;mailbox[triangles[i].tri]) {
        triangles[i].mesh-&gt;mailbox[triangles[i].tri] = rayId;
        const Mesh *mesh = triangles[i].mesh;
        uint32_t j = triangles[i].tri * 3;
        const Vec3f &amp;v0 = mesh-&gt;vertexPool[mesh-&gt;triangleIndicesInVertexPool[j    ]];
        const Vec3f &amp;v1 = mesh-&gt;vertexPool[mesh-&gt;triangleIndicesInVertexPool[j + 1]];
        const Vec3f &amp;v2 = mesh-&gt;vertexPool[mesh-&gt;triangleIndicesInVertexPool[j + 2]];
        float t, u, v;
        if (rayTriangleIntersect(orig, dir, v0, v1, v2, t, u, v)) {
            if (t &lt; tHit) {
                tHit = t;
                uhit = u;
                vhit = v;
                intersectedMesh = triangles[i].mesh;
                }
            }
        }
    }

    return (intersectedMesh != nullptr);
}


bool Grid::intersect(const Vec3f&amp; orig, const Vec3f&amp; dir, const uint32_t&amp; rayId, float&amp; tHit) const
{
    const Vec3f invDir = 1 / dir;
    const Vec3b sign(dir.x &lt; 0, dir.y &lt; 0, dir.z &lt; 0);
    float tHitBox;
    if (!bbox.intersect(orig, invDir, sign, tHitBox)) return false;

    // initialization step
    Vec3i exit, step, cell;
    Vec3f deltaT, nextCrossingT;
    for (uint8_t i = 0; i &lt; 3; ++i) {
        // convert ray starting point to cell coordinates
        float rayOrigCell = ((orig[i] + dir[i] * tHitBox) -  bbox[0][i]);
        cell[i] = clamp&lt;uint32_t&gt;(std::floor(rayOrigCell / cellDimension[i]), 0, resolution[i] - 1);
        if (dir[i] &lt; 0) {
            deltaT[i] = -cellDimension[i] * invDir[i];
            nextCrossingT[i] = tHitBox + (cell[i] * cellDimension[i] - rayOrigCell) * invDir[i];
            exit[i] = -1;
            step[i] = -1;
        }
        else {
            deltaT[i] = cellDimension[i] * invDir[i];
            nextCrossingT[i] = tHitBox + ((cell[i] + 1)  * cellDimension[i] - rayOrigCell) * invDir[i];
            exit[i] = resolution[i];
            step[i] = 1;
        }
    }

    // Walk through each cell of the grid and test for an intersection if
    // current cell contains geometry
    const Mesh* intersectedMesh = nullptr;
    while (1) {
        uint32_t o = cell[2] * resolution[0] * resolution[1] + cell[1] * resolution[0] + cell[0];
        if (cells[o] != nullptr) {
            cells[o]-&gt;intersect(orig, dir, rayId, tHit, intersectedMesh);
            //if (intersectedMesh != nullptr) { ray.color = cells[o]-&gt;color; }
        }
        uint8_t k =
            ((nextCrossingT[0] &lt; nextCrossingT[1]) &lt;&lt; 2) +
            ((nextCrossingT[0] &lt; nextCrossingT[2]) &lt;&lt; 1) +
            ((nextCrossingT[1] &lt; nextCrossingT[2]));
        static const uint8_t map[8] = {2, 1, 2, 1, 2, 2, 0, 0};
        uint8_t axis = map[k];

        if (tHit &lt; nextCrossingT[axis]) break;
        cell[axis] += step[axis];
        if (cell[axis] == exit[axis]) break;
        nextCrossingT[axis] += deltaT[axis];
    }

    return (intersectedMesh != nullptr);
}

// [comment]
// Main Render() function. Loop over each pixel in the image and trace a primary
// ray starting from the camera origin and passing through the current pixel. If they
// ray intersects geometry in the scene return some color (the color of the object)
// otherwise nothing (black or the color of the background)
// [/comment]
void render(const std::unique_ptr&lt;AccelerationStructure&gt;&amp; accel, const Options&amp; options)
{
    std::unique_ptr&lt;Vec3f []&gt; buffer(new Vec3f[options.width * options.height]);
    Vec3f orig(0,0,5);
    matPointMult(options.cameraToWorld, orig);
    float scale = std::tan(degToRad&lt;float&gt;(options.fov * 0.5));
    float imageAspectRatio = options.width / static_cast&lt;float&gt;(options.height);
    assert(imageAspectRatio &gt; 1);
    uint32_t rayId = 1; // Start at 1 not 0!! (see Grid code and mailboxing)
    for (uint32_t j = 0; j &lt; options.height; ++j) {
        for (uint32_t i = 0; i &lt; options.width; ++i) {
            Vec3f dir((2 * (i + 0.5f) / options.width - 1) * scale * imageAspectRatio,
                      (1 - 2 * (j + 0.5) / options.height) * scale,
                      -1);
            matVecMult(options.cameraToWorld, dir);
            normalize(dir);
            numPrimaryRays++;
            float tHit = kInfinity;
            buffer[j * options.width + i] = (accel-&gt;intersect(orig, dir, rayId++, tHit)) ? Vec3f(1) :  Vec3f(0);
        }
    }

    // store to PPM file
    std::ofstream ofs;
    ofs.open(&quot;image.ppm&quot;);
    ofs &lt;&lt; &quot;P6\n&quot; &lt;&lt; options.width &lt;&lt; &quot; &quot; &lt;&lt; options.height &lt;&lt; &quot;\n255\n&quot;;
    for (uint32_t i = 0; i &lt; options.width * options.height; ++i) {
        Vec3&lt;uint8_t&gt; pixRgb;
        pixRgb.x = static_cast&lt;uint8_t&gt;(255 * std::max(0.f, std::min(1.f, buffer[i].x)));
        pixRgb.y = static_cast&lt;uint8_t&gt;(255 * std::max(0.f, std::min(1.f, buffer[i].y)));
        pixRgb.z = static_cast&lt;uint8_t&gt;(255 * std::max(0.f, std::min(1.f, buffer[i].z)));
        ofs &lt;&lt; pixRgb.x &lt;&lt; pixRgb.y &lt;&lt; pixRgb.z;
    }
    ofs.close();
}

void exportMesh(const std::vector&lt;std::unique_ptr&lt;const Mesh&gt;&gt;&amp; meshes)
{
    std::ofstream f;
    f.open(&quot;mesh.obj&quot;);
    uint32_t k = 0, off = 0;
    for (const auto&amp; mesh : meshes) {
        f &lt;&lt; &quot;g default&quot; &lt;&lt; std::endl;
        for (uint32_t i = 0; i &lt; mesh-&gt;vertexPool.size(); ++i) {
            f &lt;&lt; &quot;v &quot; &lt;&lt; mesh-&gt;vertexPool[i].x &lt;&lt; &quot; &quot; &lt;&lt; mesh-&gt;vertexPool[i].y &lt;&lt; &quot; &quot; &lt;&lt; mesh-&gt;vertexPool[i].z &lt;&lt; std::endl;
        }

        f &lt;&lt; &quot;g mesh&quot; &lt;&lt; k++ &lt;&lt; std::endl;
        for (uint32_t i = 0; i &lt; mesh-&gt;numTriangles; ++i) {
            f &lt;&lt; &quot;f &quot; &lt;&lt; mesh-&gt;triangleIndicesInVertexPool[i * 3] + 1 + off &lt;&lt; &quot; &quot; &lt;&lt; 
                         mesh-&gt;triangleIndicesInVertexPool[i * 3 + 1] + 1 + off &lt;&lt; &quot; &quot; &lt;&lt; 
                         mesh-&gt;triangleIndicesInVertexPool[i * 3 + 2] + 1 + off &lt;&lt; std::endl;
        }
        off += mesh-&gt;vertexPool.size();
    }

    f.close();
}

int main(int argc, char **argv)
{
    std::vector&lt;std::unique_ptr&lt;const Mesh&gt;&gt; meshes;
    makeScene(meshes);

    // [comment]
    // Create the acceleration structure
    // [/comment]
#if defined(ACCEL_BBOX)
    std::unique_ptr&lt;AccelerationStructure&gt; accel(new BBoxAcceleration(meshes));
#elif defined(ACCEL_BVH)
    std::unique_ptr&lt;AccelerationStructure&gt; accel(new BVH(meshes));
#elif defined(ACCEL_GRID)
    std::unique_ptr&lt;AccelerationStructure&gt; accel(new Grid(meshes));
#else
    std::unique_ptr&lt;AccelerationStructure&gt; accel(new AccelerationStructure(meshes));
#endif

    //exportMesh(meshes);
    uint32_t numTriangles = 0;
    for (const auto&amp; mesh : meshes) {
        numTriangles += mesh-&gt;numTriangles;
    }
    Options options;
    using Time = std::chrono::high_resolution_clock;
    using fsec = std::chrono::duration&lt;float&gt;;
    auto t0 = Time::now();
    render(accel, options);
    auto t1 = Time::now();
    fsec fs = t1 - t0;
    std::cout &lt;&lt; &quot;Render time                                 | &quot; &lt;&lt; fs.count() &lt;&lt; &quot; sec&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Total number of triangles                   | &quot; &lt;&lt; numTriangles &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Total number of primary rays                | &quot; &lt;&lt; numPrimaryRays &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Total number of ray-bbox tests              | &quot; &lt;&lt; numRayBBoxTests &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Total number of ray-boundvolume tests       | &quot; &lt;&lt; numRayBoundingVolumeTests &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Total number of ray-triangles tests         | &quot; &lt;&lt; numRayTriangleTests &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Total number of ray-triangles intersections | &quot; &lt;&lt; numRayTriangleIntersections &lt;&lt; std::endl;

    return 0;
}
</div><!-- end of code --></div><!-- end of code-column -->
</article>
</body>

<!-- Mirrored from www.scratchapixel.com/code.php?id=36&origin=/lessons/advanced-rendering/introduction-acceleration-structure by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 01 Aug 2021 17:19:54 GMT -->
</html>