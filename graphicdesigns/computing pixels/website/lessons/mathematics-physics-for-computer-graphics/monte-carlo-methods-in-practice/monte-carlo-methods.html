
<!-- 
NEED TO INSERT THE BODY AND ALL THE USEFUL STUFF HERE
-->

<html>

<!-- Mirrored from www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/monte-carlo-methods by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 01 Aug 2021 17:32:59 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<!-- title should be set at this point in page.php -->
<title>Monte Carlo Methods in Practice (Monte Carlo Methods)</title>

<meta name='author' content="Scratchapixel">
<meta name='copyright' content="&copy; 2009-2016 Scratchapixel">
<meta name='keywords' content='Monte Carlo simulation, Monte Carlo integration, random numbers, variance reduction, Quasi Monte Carlo'>
<meta name='date' content='2015-04-18 15:13:02'>

<link rel="stylesheet" type="text/css" href="../../../css/scratchapixel.css"/>
<link rel="stylesheet" type="text/css" href="../../../css/page.css"/>

<link href='../../../../fonts.googleapis.com/css16e1.css?family=Noto+Sans' rel='stylesheet' type='text/css'/>
<link href='../../../../fonts.googleapis.com/css9908.css?family=Open+Sans:700,400,300' rel='stylesheet' type='text/css'/>

<!-- using the material icons from Google http://google.github.io/material-design-icons/ -->
<link rel="stylesheet" href="../../../../fonts.googleapis.com/icone91f.css?family=Material+Icons">

<script type="text/x-mathjax-config">
MathJax.Hub.Config(
	{tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}, 
	displayAlign: "left",
	displayIndent: "1em",
	"HTML-CSS": { scale: 90 },
	jax: ["input/TeX","input/MathML","input/AsciiMath","output/HTML-CSS","output/NativeMML"],
	extensions: ["tex2jax.js","../../../indexf17c.html","../../../indexf17c.html","../../../indexf17c.html","MathZoom.js"],
	TeX: {
		extensions: ["AMSmath.js","../../../indexf17c.html","../../../indexf17c.html","noUndefined.js"]
	}}
);
</script>

<script type="text/javascript" src="../../../../cdn.mathjax.org/mathjax/latest/MathJaxdda6.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/javascript"
	src="../../../scratchapixelSDK.js">
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','../../../../www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42771397-1', 'auto');
  ga('send', 'pageview');
</script>

<!-- 
https://developers.facebook.com/docs/plugins/share-button/
Include the JavaScript SDK on your page once, ideally right after the opening <body> tag.
-->

<script>
  window.fbAsyncInit = function() {
	FB.init({
	  appId      : '1535346446701691',
	  xfbml      : true,
	  version    : 'v2.1'
	});
  };

  (function(d, s, id){
	 var js, fjs = d.getElementsByTagName(s)[0];
	 if (d.getElementById(id)) {return;}
	 js = d.createElement(s); js.id = id;
	 js.src = "../../../../connect.facebook.net/en_US/sdk.js";
	 fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script>

<script>
	!function(d,s,id) {
		var js,fjs=d.getElementsByTagName(s)[0];
		if(!d.getElementById(id)) {
			js=d.createElement(s);js.id=id;
			js.src="../../../../platform.twitter.com/widgets.js";
			fjs.parentNode.insertBefore(js,fjs);
		}
	}(document,"script","twitter-wjs");
</script>


	<!-- Open Graph data -->
	<meta property='fb:app_id' content='1535346446701691'/>
	<meta property='og:title' content='Monte Carlo Methods in Practice'/>
	<meta property='og:type' content='article'/>
	<meta property='og:url' content='https://www.scratchapixel.com//lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice'/>
	<meta property='og:image' content='https://www.scratchapixel.com/images/design/logo_scratchapixel2015.png'/>
	<meta property='og:description' content='Lesson summary: Monte Carlo integration is a fundamental technique for solving complex integrals used in rendering.'/> 
	<meta property='og:site_name' content='Scratchapixel'/>
	<meta property='fb:admins' content='1260067275'/>
	
</head>

<style>
.full-page1
{
	position: relative;
	margin: 0; padding: 0; 
	width: 100%; 
	border: 1px solid red;
	color: white;
}

.full-page-header-table1
{
	display: table; 
	width: 100%;
	border: 1px solid orange;
}
</style>

<div style='display: table; width: 100%;'>
	<!-- 
		This should be the content of the top menu bar. So if you want to reuse
		this, just create a table div above and insert the section.
		The height here doesn't mater because it's controlled by the inner table.
-->
<div style='display: table-row;  height: 40px; width: 100%; background-color: #1565C0; color: white;'>
	<!-- we center the cell in the middle of the row -->
	<div style='display: table-cell; width: 100%; border: 1px none orange; vertical-align: middle; text-align: center;'>
		
		<div style='display: inline-block; position: relative; border: 1px none black; width: 670px; margin: 0 auto; padding: 0;'>			
			<!-- 
				This is our logo 
			-->
			<div style='display: inline-block; border: 2px none green;'>
				<span style='font-size: 18px; font-weight: 800;'><a href='../../../indexf17c.html' style='text-decoration: none; color: white;'>Scratchapixel 2.0</a></span>
			</div>
			<!-- 
				This is login 
				The only way you can vertically center stuff here is by forcing the height of the div
				and the eight of the text to be the same
			-->
			<div style='border: 2px none green; position: absolute; right: 0;  top: 0; bottom: 0px; height: 20px; line-height: 20px; margin: auto 0;'>
				<a style="color: white; text-decoration: none;" href="https://www.facebook.com/v2.5/dialog/oauth?client_id=1682406642074489&amp;state=6241aa28239e903f6cad376e5bc19dd1&amp;response_type=code&amp;sdk=php-sdk-5.4.0&amp;redirect_uri=https%3A%2F%2Fwww.scratchapixel.com%2Ffb-callback.php%3F&amp;scope=email">Sign in</a>			</div>
			
		</div>
	</div>
</div></div>

<body onload="onload();">

<div id='fb-root'></div> <!-- that's required by FB -->
<div class="page-content">
<article><div id='sap-root'></div><!-- that's needed by scratchapixel see onload() --><div class='lesson-title'>Monte Carlo Methods in Practice</div><div style='width: 100%; margin: 0px; display: table; vertical-align: middle; border: 1px none red;'>
			<div style='display: table-row; height: 30px;'>
			<div style='margin: 0px; padding: 0px; border: 1px none blue ; display: table-cell; vertical-align: middle;'>
				<a href='https://twitter.com/share' class='twitter-share-button' data-lang='en'>Tweet</a>
			</div></div>
			<div style='display: table-row; height: 30px;'>
			<div style='padding: 0px; border: 1px none blue ; display: table-cell; vertical-align: middle;'>
				<div style='margin-top: 5px;' class='fb-like' data-share='true' data-width='450' data-show-faces='true'></div>
			</div></div></div><div class='chapter-table'><div class='chapter-row'><div class='chapter-cell'><b>Contents</b></div></div><div class='chapter-row'><div class='chapter-cell'><a style='text-decoration: none;' href="monte-carlo-methods.html"><b>Monte Carlo Methods</b></a></div></div><div class='chapter-row'><div class='chapter-cell'><a style='text-decoration: none;' href="monte-carlo-simulation.html">Monte Carlo Simulation</a></div></div><div class='chapter-row'><div class='chapter-cell'><a style='text-decoration: none;' href="monte-carlo-integration.html">Monte Carlo Integration</a></div></div><div class='chapter-row'><div class='chapter-cell'><a style='text-decoration: none;' href="monte-carlo-rendering-practical-example.html">Monte Carlo in Rendering (A Practical Example)</a></div></div><div class='chapter-row'><div class='chapter-cell'><a style='text-decoration: none;' href="generating-random-numbers.html">Generating Random Numbers</a></div></div><div class='chapter-row'><div class='chapter-cell'><a style='text-decoration: none;' href="variance-reduction-methods.html">Variance Reduction Methods: a Quick Introduction to Importance Sampling</a></div></div><div class='chapter-row'><div class='chapter-cell'><a style='text-decoration: none;' href="introduction-quasi-monte-carlo.html">Variance Reduction Methods: a Quick Introduction to Quasi Monte Carlo</a></div></div><div class='chapter-row'><div class='chapter-cell'><a style='text-decoration: none;' href="../../../codea0b6.html?id=31&amp;origin=/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice">Source Code</a></div></div></div><span style='display: inline-block; width: 100%; margin: 0px 0px 10px 0px;'><i>Keywords: Monte Carlo simulation, Monte Carlo integration, random numbers, variance reduction, Quasi Monte Carlo.</i></span><div class="question">
This lesson is complementary to the previous lesson 16. The lesson <a href="../monte-carlo-methods-mathematical-foundations.html">Mathematical Foundations of Monte Carlo Methods</a> is more about the concepts upon which Monte Carlo methods are built. In this lesson, we will talk about the methods themselves, and provide some practical examples.
</div>

<h2>Monte Carlo Methods: I Am Feeling (Un-)Lucky!</h2>

<p>In rendering, the term Monte Carlo (often abbreviated as MC) is often used, read or heard. But what does it mean? In fact, now that you spent a fair amount of time reviewing the concept of statistics and probabilities, you will realise (it might come as a deception to certain) that what it refers to, is in fact an incredibly simple idea. However simple, it is powerful and has some interesting properties that makes it very attractive for solving various problems. In short, Monte Carlo methods refer to a series of statistical methods essentially used to find solutions to things such as computing the expected values of a function, or integrating functions which can't be integrated analytically because they don't have a closed-form solution for example (we mentioned this term already in the <a href="../../../indexf17c.html">introduction to shading</a>). What we mean by statistical methods is that they use sampling techniques similar to those we studied in great details in the last chapters to compute these solutions. Why do we say <b>Monte Carlo methods</b>? Simply because the same principle can be used to solve different problems and to each one of these problems is associated a different technique or algorithm. What all these algorithm have in common is their use of random (or stochastic) sampling. As described by Russian mathematician Sobol:</p>

<div class="scratchquote">The Monte Carlo method is a numerical method of solving mathematical problems by random sampling (or by the simulation of random variables).
</div>

<p>MC methods all share the concept of using randomly drawn samples to compute a solution to a given problem. These problems generally come in two main categories:</p>

<ul>
<li><b>simulation</b>: Monte Carlo or random sampling is used to run a simulation. If you want to compute the time it will take to go from point A to point B, given some conditions such as the chances that it will rain on your journey or that it will snow, the chances that there will be a traffic jam, that you will have to stop on your way to get some gas, etc. you can set these conditions at the start of your simulation and run the simulation 1,000 times to get an estimated time. As usual, the higher the number of runs or trials (here 1,000), the better your estimate.</li>
<li><b>integration</b>: this is a technique useful for mathematicians. In the lesson Introduction to Shading, we learned in the chapter Introduction to the Mathematics of Shading, how to compute simple integrals using the Riemann sum technique. As simple at this can be, this approach can be quite computationally expensive as the dimension of the integral increases. MC integration though, while not having the greatest rate of convergence to the actual solution of the integral, can give us a way of getting a reasonably close result at a "cheaper" computational cost. </li>
</ul>

<div class="important">
<p>But let's rephrase this to emphasise something that is very important  about this method (actually what's truly and fundamentally exciting and beautiful about it). If it is true that the more samples you use, the closer the MC method gets to the actual solution, because we use random samples, a MC method can as well "just" randomly falls on the exact value by pure chance. In other words, on occasions, running a single MC simulation or integration will just give the right solution. However, on most occasions it won't, but averaging these results will nevertheless converge to the exact solution anyway (we've learned about this and the Law of Large Numbers in the previous chapters).</p>
</div>

<p>For example, given some conditions about the weather and time of the week and day you will be traveling from A to B, our first simulation gives us the time of 1 hour and 32 minutes. Now let's say that none of the other 1,000,000,000,000 simulations we ran using the exact same conditions gave you that number, but when averaging their results though we get 1 hour and 32 minutes. In other words, your first simulation gave you what seems to be the actual solution to your problem (what you might expect the average of one trillion simulations to be pretty close to). Of course you don't know that you get the right answer after only one trial, but this one of the great characteristic of the methods: we very few samples, sometimes, you may as well get the exact or very close to the exact solution.</p>

<div class="important">
<p>However in the strength of the MC methods also lies their main weakness. If by chance you sometimes get the right or close to the right solution with only a few samples, you may as well be unlucky at some other times, and need a very large number of samples before getting close to the right answer. Generally, the <b>rate of convergence</b> of MC methods (the rate by which the MC methods converge to the right result as the number of samples increases) is pretty low (not to say poor). We will talk about this again further in this chapter. This is another important characteristic of the MC methods you need to remember.</p>
</div>

<h2>Hit-or-Miss Monte Carlo Method</h2>

<div class="captionImage right" style="width: 300px;">
<img class="left" src="../../../images/upload/monte-carlo-methods/montecarlo2d41d.png?" />
<p class="caption left">Figure 1: estimating the area of a shape using the hit/miss method.</p>
</div>

<p>We will detail in the next chapters each technique (Monte Carlo simulation and integration) as well as provide an example of how MC methods are actually used in computer graphics and particularly in the field of rendering. However, before we get to this point, it is useful and easy to introduce the concept with a simple example. Imagine that we want to estimate the area of an arbitrary shape such as the one we drew in figure 1. All we know is the area of the rectangle containing this shape and defined by the boundary ac and ab. Because these boundaries define a simple rectangle, we know the area of this rectangle to be \(A = ab \times ac\). To estimate the area of the shape itself, we can use a technique called hit-or-miss (also sometimes called the rejection method). The idea is to "<b>throw</b>" a certain number of random points <b>uniformly</b> into the rectangle and count the number of these points contained falling within the shape (hits) while <b>rejecting</b> the others. Because points are randomly distributed over the area of the rectangle \(ab \times ab\), it is reasonable to assume that the area of the shape is <b>proportional</b> to the number of hits over the total number of thrown points (in other words, the ratio of hits to the total number of samples is an approximation of the ratio of the area of the shape to the area of the rectangle in which the shape in inscribed). Assuming we keep the total number of samples (thrown points) constant: the bigger the shape, the higher the number of hits and reciprocally, the smaller the shape the less hits. In other words we can write:</p>

$$A_{shape} \approx {N_{hits} \over N_{total} } \times A \text{ where } A = ab \times ac.$$

<div class="captionImage right" style="width: 300px;">
<img class="left" src="../../../images/upload/monte-carlo-methods/montecarlo3d41d.png?" />
<p class="caption left">Figure 2: samples need to be uniformly distributed over the area of the rectangle otherwise results are biased (as in the example). The concentric circles in this example indicates the density of samples.</p>
</div>

<p>This is a very basic and simple example of how random sampling is used to solve a given problem (this device was actually originally developed by von Neumann himself who you can see in the photograph at the end of this chapter). A few things should be noted. Of course, the more samples we use, the better the estimate. It is also important to note that the distribution of samples over the area of the rectangle needs to be uniform. If for whatever reasons more points where falling within a certain region of the rectangle (as in figure 2 where the density of samples increases as we get to the center of the figure), then the result would be biased (that is, the result would be different than the true solution by some offset). We will see in the next lesson on importance sampling, that uniform sampling is not an absolute condition to using MC methods. When we know that a non-uniform distribution is used, we can compensate for the bias that it would normally introduce by some other method. Why would we be interested in using non-uniform sampling then? Because, as we will see in the next lesson on importance sampling, this can be used as a <b>variance reduction</b> technique. Variance, as explained in the previous chapters, is a measure of the error between our estimate and the true solution. The only brute-force and most obvious way by which variance can be reduced in MC methods is by increasing \(N\), the total number of samples. However some other methods involving the way random samples are generated (see the chapter of Quasi or Pseudo Random Numbers at the end of this lesson) and importance sampling (in which non-uniform sampling distributions are used) can also be used to reduce variance. However (and before we study these more advanced methods), keep in mind that basic or naive Monte Carlo methods requires the samples to be uniformly distributed. Remember that a random number has a <b>uniform distribution</b> if all its possible outcomes have the same probability to occur (a property known as equiprobability).</p>

<div class="captionImage right" style="width: 300px;">
<img class="left" src="../../../images/upload/monte-carlo-methods/areaunitdiskd41d.png?" />
<p class="caption left">Figure 3: the area of the unit disk can be estimated using the hit-or-miss Monte Carlo method.</p>
</div>

<p>As a practical example, let's say we want to estimate the area of a unit disk using the hit-or-miss Monte Carlo method. We know the radius of the unit disk is 1 thus the unit circle is inscribed within a square of length 2. We could generate samples within this square and count the number of points falling within the disk. To test wether the point is inside (hit) or outside (miss) the disk, we simply need to measure the distance of the sample from the origin (the center of the unit disk) and check wether this distance is smaller (or equal) than the disk radius (which is equal to 1 for a unit disk). Note that because we can divide the disk in four equal sections (or quadrant) each inscribed in a unit square (figure 3) we can limit this test to the unit square and multiply the resulting number by four. To compute the area of a quarter of the unit disk, we then simply divide the total number of hits (the green dots in figure 7) by the total number of samples and multiply this ratio by the area of the unit square (which is equal to 1). The following C++ code implements this algorithm:</p>

<div name="code" class="code">#include &ltcstdlib&gt
#include &ltcstdio&gt
#include &ltrandom&gt
 
int main(int argc, char **argv)
{
    std::default_random_engine gen;
    std::uniform_real_distribution<float> distr;
    int N = (argc == 2) ? atoi(argv[1]) : 1024, hits = 0;
    for (int i = 0; i < N; i++) {
        float x = distr(gen);
        float y = distr(gen);
        float l = sqrt(x * x + y * y);
        if (l <= 1) hits++;
    }
    fprintf(stderr, "Area of unit disk: %f (%d)\n", float(hits) / N * 4, hits);

    return 0;
}</div>

<p>This code uses the function from the random C++11 random library to generate random numbers using a given random number generator (more information on generating random numbers on a computer can be found in one of the next chapters of this lesson) and a given probability distribution (in this case, a uniform distribution). Check the <a href="http://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution/uniform_real_distribution">documentation</a> for more information on these C++11 libraries (<a href="http://en.wikipedia.org/wiki/C++11">C++11</a> is, by 2013, the most recent version of the standard of the C++ programming language). If you compile and run this program, you should get:</p>

<div name="code" class="code">clang++ -o pi -O3 -std=c++11 -stdlib=libc++ pi.cpp
./pi 1000000
Area of unit disk: 3.141864 (785466)</div>

<p>As you can see, we get pretty close to the exact solution (which is \(\pi\) since the area of the unit disk is \(A = \pi r^2\) with \(r = 1\)), and as you increase the number of samples (which you can as an argument to the program), the estimate keeps getting closer to this number (as expected). If you used a 3D application in the past, you probably used random sampling already, maybe without knowing it. With this program though (and the next ones to follow) you can now actually say that you not only know what a MC method is but also implement a practical example of your own to illustrate such method.</p>

<h2>Why Do We Use Monte Carlo Methods?</h2>

<p>If you run the code to compute the area of the unit disk, you will find that we need about 100 million samples to approximate the number \(\pi\) to its fourth decimal (3.1415). Is it an efficient way of estimating the number \(\pi\)? The answer is clearly no. Then, why do we need Monte Carlo methods at all, if they don't seem that efficient? As already mentioned in previous lessons, we say that an equation has a closed-form solution when this solution can be expressed and thus computed analytically. However many equations do not have such closed-form solutions and even when they do, sometimes their complexity is such that they could only be solved given infinite time. Such problems or equations are said to be <b>intractable</b>. However it's often better to have some predictions about the possible outcomes of a given problem, than not having any prediction at all. And Monte Carlo methods are then sometimes the only practical methods by which estimates to these equations or problems can be made. As Metropolis and Ulam put it in their seminal paper on the Monte Carlo Method (see reference section):</p>

<div class="scratchquote">To calculate the probability of a successful outcome of a game of solitaire is a completely intractable task. [...] the practical procedure is to produce a large number of examples of any given game and then to examine the relative proportion of successes. [...] We can see at once that the estimate will never be confined within given limits with certainty, but only - if the number of trials is great - with great probability.</div>

<p>As we will see in the next chapters, many of these problems such as definite integrals can be efficiently solved by some numerical methods which are generally converging faster than MC methods (in other words, better methods). However as the dimension of the integrals increase, these methods often become computationally expensive where the Monte Carlo ones can still provide with reasonably good estimate at a fixed computational cost (defined by the number of samples spared in computing estimations). For this reason, for complex integrals, MC methods are generally a better solution (despite their pretty bad convergence rate).</p>

<p>Finally, Monte Carlo methods are generally incredibly simple to implement and very versatile. They can be used to solve a very wild range of problems, in pretty much every possible imaginable field. In Metropolis and Ulam's paper, we can read:</p>

<div class="scratchquote">The "solitaire" is meant here merely as an illustration for the whole class of combinatorial problems occurring in both pure mathematics and the applied sciences.</div>

<img class="left" style="width: 670px; margin-bottom: 12px;" src="../../../images/upload/monte-carlo-methods/von-Neumannd41d.png?" />

<p>As already suggested in the introduction, Monte Carlo methods' popularity and development have very much to do with the advent of computing technology in the 1940s to which von Neumann (picture above) was a pioneer. In a report on Monte Carlo method published in 1957 by the Los Alamos Scientific Laboratory, we could already read:</p>
<div class="scratchquote">The present state of development of high-speed digital, computers permits the use of samples of a size sufficiently large to ensure satisfactory accuracy in most practical problems.</div>

<p>This is important to understand, because on its own, while being a pretty simple idea, using MC without the help of a computer is a pretty tedious not to say an unusable approach to solving any sort of problems. A computer can execute all the calculations for us, which is why despite its poor convergence rate, Monte Carlo or stochastic sampling has become so popular. We just let computers do the tedious work for us.</p>

<p>Finally, let's conclude this chapter by saying that Monte Carlo methods have very much to do as well with the generation of random numbers (the first few chapters of this lesson were dedicated to studying random variables). To run a MC algorithm we first need to be able to generate random numbers (generally with a given probability distribution). For this reason, the development of algorithms for generating such "random" numbers (they appear random but generally they are not "truly" random which is why these algorithms are called <b>pseudorandom number generator</b>), has been an important field of research in computing technology. This topic will be further developed in one of the next chapters.</p>

<h2>What's Next?</h2>

<p>The rest of this lesson is focused on providing you with some practical examples of MC methods. The next chapter is focused on MC simulation. The one after that, is devoted to MC integration. We will then explain how MC is used in computer graphics and rendering in particular (with a practical example). Finally we will talk about the topic of generating random numbers on a computer, variance reduction methods and Quasi Monte Carlo (or QMC).</p>

<p>This work is provided to you for free and requires hours of work. If you find this content useful, please consider making a donation.</p></article></div><!-- end of page-content -->
			<div class='footer-prev-next'>
			<div class='footer-column'><div class='footer-prev-next-row'>
				<div class='footer-prev-next-cell' style='text-align: left;'></div>
				<div class='footer-prev-next-cell' style='text-align: center;'><p>Chapter 1 of  8</p></div>
				<div class='footer-prev-next-cell' style='text-align: right;'><p><a href='monte-carlo-simulation.html'>Next Chapter <i style='float: right;' class='material-icons'>arrow_forward</i></a></p></div>
			</div></div>
			</div>

</body>

<!-- Mirrored from www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/monte-carlo-methods by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 01 Aug 2021 17:33:58 GMT -->
</html>