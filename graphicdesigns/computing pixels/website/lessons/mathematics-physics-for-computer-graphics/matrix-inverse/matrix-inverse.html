
<!-- 
NEED TO INSERT THE BODY AND ALL THE USEFUL STUFF HERE
-->

<html>

<!-- Mirrored from www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/matrix-inverse/matrix-inverse by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 01 Aug 2021 17:35:45 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<!-- title should be set at this point in page.php -->
<title>Matrix Inverse (Matrix Inverse)</title>

<meta name='author' content="Scratchapixel">
<meta name='copyright' content="&copy; 2009-2016 Scratchapixel">
<meta name='keywords' content='Gauss-Jordan elimination, reduced row elimination, matrix inverse'>
<meta name='date' content='2015-10-08 15:43:04'>

<link rel="stylesheet" type="text/css" href="../../../css/scratchapixel.css"/>
<link rel="stylesheet" type="text/css" href="../../../css/page.css"/>

<link href='../../../../fonts.googleapis.com/css16e1.css?family=Noto+Sans' rel='stylesheet' type='text/css'/>
<link href='../../../../fonts.googleapis.com/css9908.css?family=Open+Sans:700,400,300' rel='stylesheet' type='text/css'/>

<!-- using the material icons from Google http://google.github.io/material-design-icons/ -->
<link rel="stylesheet" href="../../../../fonts.googleapis.com/icone91f.css?family=Material+Icons">

<script type="text/x-mathjax-config">
MathJax.Hub.Config(
	{tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}, 
	displayAlign: "left",
	displayIndent: "1em",
	"HTML-CSS": { scale: 90 },
	jax: ["input/TeX","input/MathML","input/AsciiMath","output/HTML-CSS","output/NativeMML"],
	extensions: ["tex2jax.js","../../../indexf17c.html","../../../indexf17c.html","../../../indexf17c.html","MathZoom.js"],
	TeX: {
		extensions: ["AMSmath.js","../../../indexf17c.html","../../../indexf17c.html","noUndefined.js"]
	}}
);
</script>

<script type="text/javascript" src="../../../../cdn.mathjax.org/mathjax/latest/MathJaxdda6.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/javascript"
	src="../../../scratchapixelSDK.js">
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','../../../../www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42771397-1', 'auto');
  ga('send', 'pageview');
</script>

<!-- 
https://developers.facebook.com/docs/plugins/share-button/
Include the JavaScript SDK on your page once, ideally right after the opening <body> tag.
-->

<script>
  window.fbAsyncInit = function() {
	FB.init({
	  appId      : '1535346446701691',
	  xfbml      : true,
	  version    : 'v2.1'
	});
  };

  (function(d, s, id){
	 var js, fjs = d.getElementsByTagName(s)[0];
	 if (d.getElementById(id)) {return;}
	 js = d.createElement(s); js.id = id;
	 js.src = "../../../../connect.facebook.net/en_US/sdk.js";
	 fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script>

<script>
	!function(d,s,id) {
		var js,fjs=d.getElementsByTagName(s)[0];
		if(!d.getElementById(id)) {
			js=d.createElement(s);js.id=id;
			js.src="../../../../platform.twitter.com/widgets.js";
			fjs.parentNode.insertBefore(js,fjs);
		}
	}(document,"script","twitter-wjs");
</script>


	<!-- Open Graph data -->
	<meta property='fb:app_id' content='1535346446701691'/>
	<meta property='og:title' content='Matrix Inverse'/>
	<meta property='og:type' content='article'/>
	<meta property='og:url' content='https://www.scratchapixel.com//lessons/mathematics-physics-for-computer-graphics/matrix-inverse'/>
	<meta property='og:image' content='https://www.scratchapixel.com/images/design/logo_scratchapixel2015.png'/>
	<meta property='og:description' content='Lesson summary: '/> 
	<meta property='og:site_name' content='Scratchapixel'/>
	<meta property='fb:admins' content='1260067275'/>
	
</head>

<style>
.full-page1
{
	position: relative;
	margin: 0; padding: 0; 
	width: 100%; 
	border: 1px solid red;
	color: white;
}

.full-page-header-table1
{
	display: table; 
	width: 100%;
	border: 1px solid orange;
}
</style>

<div style='display: table; width: 100%;'>
	<!-- 
		This should be the content of the top menu bar. So if you want to reuse
		this, just create a table div above and insert the section.
		The height here doesn't mater because it's controlled by the inner table.
-->
<div style='display: table-row;  height: 40px; width: 100%; background-color: #1565C0; color: white;'>
	<!-- we center the cell in the middle of the row -->
	<div style='display: table-cell; width: 100%; border: 1px none orange; vertical-align: middle; text-align: center;'>
		
		<div style='display: inline-block; position: relative; border: 1px none black; width: 670px; margin: 0 auto; padding: 0;'>			
			<!-- 
				This is our logo 
			-->
			<div style='display: inline-block; border: 2px none green;'>
				<span style='font-size: 18px; font-weight: 800;'><a href='../../../indexf17c.html' style='text-decoration: none; color: white;'>Scratchapixel 2.0</a></span>
			</div>
			<!-- 
				This is login 
				The only way you can vertically center stuff here is by forcing the height of the div
				and the eight of the text to be the same
			-->
			<div style='border: 2px none green; position: absolute; right: 0;  top: 0; bottom: 0px; height: 20px; line-height: 20px; margin: auto 0;'>
				<a style="color: white; text-decoration: none;" href="https://www.facebook.com/v2.5/dialog/oauth?client_id=1682406642074489&amp;state=6241aa28239e903f6cad376e5bc19dd1&amp;response_type=code&amp;sdk=php-sdk-5.4.0&amp;redirect_uri=https%3A%2F%2Fwww.scratchapixel.com%2Ffb-callback.php%3F&amp;scope=email">Sign in</a>			</div>
			
		</div>
	</div>
</div></div>

<body onload="onload();">

<div id='fb-root'></div> <!-- that's required by FB -->
<div class="page-content">
<article><div id='sap-root'></div><!-- that's needed by scratchapixel see onload() --><div class='lesson-title'>Matrix Inverse</div><div style='width: 100%; margin: 0px; display: table; vertical-align: middle; border: 1px none red;'>
			<div style='display: table-row; height: 30px;'>
			<div style='margin: 0px; padding: 0px; border: 1px none blue ; display: table-cell; vertical-align: middle;'>
				<a href='https://twitter.com/share' class='twitter-share-button' data-lang='en'>Tweet</a>
			</div></div>
			<div style='display: table-row; height: 30px;'>
			<div style='padding: 0px; border: 1px none blue ; display: table-cell; vertical-align: middle;'>
				<div style='margin-top: 5px;' class='fb-like' data-share='true' data-width='450' data-show-faces='true'></div>
			</div></div></div><div class='chapter-table'><div class='chapter-row'><div class='chapter-cell'><b>Contents</b></div></div><div class='chapter-row'><div class='chapter-cell'><a style='text-decoration: none;' href="matrix-inverse.html"><b>Matrix Inverse</b></a></div></div></div><span style='display: inline-block; width: 100%; margin: 0px 0px 10px 0px;'><i>Keywords: Gauss-Jordan elimination, reduced row elimination, matrix inverse.</i></span><p>In this lesson we will show how the inverse of a matrix can be computed using a technique known as the Gauss-Jordan (or reduced row) elimination. Computing the inverse of matrix implies a couple of things starting with the fact that the matrix is invertible in the first place (a matrix is not necessarily invertible). First, to be invertible a matrix has to be a <b>square matrix</b> (it has as many rows as it has columns for instance 2x2, 3x3, 4x4, etc.) and also the determinant of the matrix has to be different than zero (to learn about the determinant of a matrix check the Linear Algebra lesson in the Basic section). Any matrix that has a zero determinant is said to be singular (meaning it is not invertible).</p>

<p>To compute the inverse of the matrix M we will write M and also write next to it the identity matrix (an identity matrix is a square matrix with ones on the diagonal and zeros elsewhere). We say that we augment M by the identity. Then we will row reduced this <b>augmented</b> (or adjoined) matrix.</p>

<img class="" src="../../../images/upload/matrix-inverse/mi-eq1.png" />

<p>Before we get started, remember that a matrix can be seen as a system of linear equations which can solved using what we call <b>row elementary operations</b>. Row elementary operations have the property to preserve the solution set by the matrix. There are three such operations: you can swap the rows of a matrix (operation 1), multiply each coefficients of a row by a non zero constant (operation 2), and replace a row with the sum of itself and the multiple of another row (operation 3). These are illustrated with the following examples (row switching, row multiplication and row addition):</p>

<img class="" src="../../../images/upload/matrix-inverse/mi-rowop.png" />

<p>In the second example, we simply multiply all the coefficients of row 1 by 1/2 and the coefficients of row 3 by 2. In the third example, we add the coefficients from row 1 to the coefficients of row 2. The idea behind the Gauss-Jordan elimination is to use these elementary row operations to transform the 4x4 matrix on the left inside of the augmented matrix into the identity matrix (we say that M is row-reduced). By performing the same row operations to the 4x4 identity matrix on the right inside of the augmented matrix we obtain the inverse matrix.</p>

<h2>Step 1: set the row so that the pivot is different than zero</h2>

<p>The coefficients making the diagonal of the matrix are called the <b>pivots</b> of the matrix.</p>

<img class="img right" src="../../../images/upload/matrix-inverse/mi-pivotsd41d.png?" />

<p> As we mentioned earlier, the goal of the matrix inversion process is to use the row elementary operations to set the pivot of each column to 1 and all the other coefficients to 0 (at the end of this process we will get the identify matrix). To achieve this, the best is to row-reduced each column one after the other starting from the left. Proceeding from left to right, guarantees that as we proceed from column to column, we do not change the values of the columns which have been already row-reduced.</p>

<p><img class="img right" src="../../../images/upload/matrix-inverse/mi-columns.gif" /></p>

<p>The first thing we will do is to examine the value for the pivot coefficient for the current column (the column being processed). In order for our technique to work, this value has to be different than zero. If it is different than zero then we can directly move to step two. If it is equal to zero, we will need to find another row in the matrix for this column which value is different than zero, and swap these two rows (operation 1). However more than one row may have values different than zero ? So which one should we select ? We will pickup the row which absolute value is the highest.</p>

<img class="img right" src="../../../images/upload/matrix-inverse/mi-swap.gif" />

<p>In the example on the right, we are looking at the pivot coefficient of the second column. Because the value of that coefficient is zero, we swap row 2 with the rows of the second column which absolute value is the greatest (in this example row 3).</p>

<p>We use the Gauss-Jordan elimination method to transform the original matrix to the identity matrix and perform at the same time the same operations on another matrix (mat) which, at the beginning of the function (line 3), is set to the identity matrix (the Matrix class constructor set the matrix to the identity matrix by default). At the end of this process, our original matrix is set with the coefficient from the second matrix (line 39 in the final code). If we can't find another value for the pivot coefficient (that is if all the other values in the column are zero) then the matrix can't be inverted and is singular (line 11).</p>

<div name="code" class="code">Matrix&ltT, N&gt & invert()
{
    Matrix&ltT, N&gt mat;
    for (unsigned column = 0; column < N; ++column) {
        // Swap row in case our pivot point is not working
        if (m[column][column] == 0) {
            size_t big = column;
            for (unsigned row = 0; row < N; ++row)
                if (fabs(m[row][column]) > fabs(m[big][column])) big = row;
            // Print this is a singular matrix, return identity ?
            if (big == column) fprintf(stderr, "Singular matrix\n");
            // Swap rows                               
            else for (unsigned j = 0; j < N; ++j) {
                std::swap(m[column][j], m[big][j]);
                std::swap(mat.m[column][j], mat.m[big][j]);
            }
        }
        ...
    }
}</div>

<h2>Step 2: Set each row in the column to 0</h2>

<img class="img right" src="../../../images/upload/matrix-inverse/mi-reduce.png" />

<p>If the current column we are processing has a valid pivot coefficient, then we can proceed to the next step. We will reduce each coefficient of the column (apart from the pivot coefficient which we won't touch for now) to zero. In English that won't make much sense but here it is. Lets call 'm', the current cofficient (for the current column/row) that we want to reduce to zero. We will subtract m muliplied by each coefficient of the row which index is the same as the index of the current column, from each coefficients of the current row (operation 2 and 3). The technique will work if m itself is divided by the pivot coefficient value (line 4). This is illustrated for one coefficient in the following example. The second column is the current column. We want to reduce the first coefficient (row 0) from the current column (4.3) to zero. For each coefficient of the first row (say C0j), we take the corresponding coefficient (C1j) from the second row (because we are processing the second column), multiply this coefficient by the coefficient we want to reduce by zero (C02) divided by the pivot coefficient from the second column (C12) and subtract the resulting number from C0j.</p>

<p>In C++ code we get:</p>

<div name="code" class="code">// Set each row in the column to 0  
for (unsigned row = 0; row < N; ++row) {
    if (row != column) {
        T coeff = m[row][column] / m[column][column];
        if (coeff != 0) {
            for (unsigned j = 0; j < N; ++j) {
                m[row][j] -= coeff * m[column][j];
                mat.m[row][j] -=  coeff * mat.m[column][j];
            }
            // Set the element to 0 for safety
            m[row][column] = 0;
        }
    }
}</div>

<p>Note how we apply the same operation to the right hand side of the augmented matrix (line 8).</p>

<h2>Step 3: scale all the pivots coefficients to 1</h2>

<p>At the end of step 2, all the matrix coefficients should be 0 excepted the pivots coefficients which we need to set to 1. To do so, we simply need to scale the coefficients by their own value. Similarly to what we have done in step 2, we will loop over each row, then each column and divide the current coefficient by the pivot coefficient value of the current row:</p>

<div name="code" class="code">for (unsigned row = 0; row < N; ++row) {
    for (unsigned column = 0; column < N; ++column) {
        mat.m[row][column] /= m[row][row];
    }
}</div>

<p>Finally we just set the result of the current matrix with the result of our right inside matrix (mat in the code). We have inverted the matrix using the Gauss-Jordan elimination technique.</p>

<p>Here is the full code of the method:</p>

<div name="code" class="code">Matrix&ltT, N&gt & invert()
{
    Matrix&ltT, N&gt mat;
    for (unsigned column = 0; column < N; ++column) {
        // Swap row in case our pivot point is not working
        if (m[column][column] == 0) {
            unsigned big = column;
            for (unsigned row = 0; row < N; ++row)
                if (fabs(m[row][column]) > fabs(m[big][column])) big = row;
            // Print this is a singular matrix, return identity ?
            if (big == column) fprintf(stderr, "Singular matrix\n");
            // Swap rows                               
            else for (unsigned j = 0; j < N; ++j) {
                std::swap(m[column][j], m[big][j]);
                std::swap(mat.m[column][j], mat.m[big][j]);
            }
        }
        // Set each row in the column to 0  
        for (unsigned row = 0; row < N; ++row) {
            if (row != column) {
                T coeff = m[row][column] / m[column][column];
                if (coeff != 0) {
                    for (unsigned j = 0; j < N; ++j) {
                        m[row][j] -= coeff * m[column][j];
                        mat.m[row][j] -= coeff * mat.m[column][j];
                    }
                    // Set the element to 0 for safety
                    m[row][column] = 0;
                }
            }
        }
    }
    // Set each element of the diagonal to 1
    for (unsigned row = 0; row < N; ++row) {
        for (unsigned column = 0; column < N; ++column) {
            mat.m[row][column] /= m[row][row];
        }
    }
    *this = mat;
    return *this;
}</div>

<h2>What's Next?</h2>

<p>There are two other popular methods to compute the inverse of a matrix. One is very similar to the technique we have just described and use a combination of what is called forward elimination and backward substitution. The second technique is based on computing determinants and will be explained in a future revision of this lesson.</p></article></div><!-- end of page-content -->
			<div class='footer-prev-next'>
			<div class='footer-column'><div class='footer-prev-next-row'>
				<div class='footer-prev-next-cell' style='text-align: left;'></div>
				<div class='footer-prev-next-cell' style='text-align: center;'><p>Chapter 1 of  1</p></div>
				<div class='footer-prev-next-cell' style='text-align: right;'></div>
			</div></div>
			</div>

</body>

<!-- Mirrored from www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/matrix-inverse/matrix-inverse by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 01 Aug 2021 17:36:20 GMT -->
</html>