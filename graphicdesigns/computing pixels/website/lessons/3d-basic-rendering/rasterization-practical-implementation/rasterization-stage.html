
<!-- 
NEED TO INSERT THE BODY AND ALL THE USEFUL STUFF HERE
-->

<html>

<!-- Mirrored from www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/rasterization-stage by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 01 Aug 2021 17:10:55 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<!-- title should be set at this point in page.php -->
<title>Rasterization: a Practical Implementation (The Rasterization Stage)</title>

<meta name='author' content="Scratchapixel">
<meta name='copyright' content="&copy; 2009-2016 Scratchapixel">
<meta name='keywords' content='rasterizer, rasteriser, rasterisation, rasterization, visibility, frame-buffer, image-buffer, depth-buffer, z-buffer, pixel, raster element, perspective projection, NDC space, inside-outside test, coverage test, edge function, barycentric coordinates, counter-clockwise ordering, winding, face culling, vertex attribute, rasterization rules, top-left rule, hidden surface removal, interpolation, perspective correct interpolation, anti-aliasing'>
<meta name='date' content='2015-01-25 08:05:22'>

<link rel="stylesheet" type="text/css" href="../../../css/scratchapixel.css"/>
<link rel="stylesheet" type="text/css" href="../../../css/page.css"/>

<link href='../../../../fonts.googleapis.com/css16e1.css?family=Noto+Sans' rel='stylesheet' type='text/css'/>
<link href='../../../../fonts.googleapis.com/css9908.css?family=Open+Sans:700,400,300' rel='stylesheet' type='text/css'/>

<!-- using the material icons from Google http://google.github.io/material-design-icons/ -->
<link rel="stylesheet" href="../../../../fonts.googleapis.com/icone91f.css?family=Material+Icons">

<script type="text/x-mathjax-config">
MathJax.Hub.Config(
	{tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}, 
	displayAlign: "left",
	displayIndent: "1em",
	"HTML-CSS": { scale: 90 },
	jax: ["input/TeX","input/MathML","input/AsciiMath","output/HTML-CSS","output/NativeMML"],
	extensions: ["tex2jax.js","../../../indexf17c.html","../../../indexf17c.html","../../../indexf17c.html","MathZoom.js"],
	TeX: {
		extensions: ["AMSmath.js","../../../indexf17c.html","../../../indexf17c.html","noUndefined.js"]
	}}
);
</script>

<script type="text/javascript" src="../../../../cdn.mathjax.org/mathjax/latest/MathJaxdda6.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/javascript"
	src="../../../scratchapixelSDK.js">
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','../../../../www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42771397-1', 'auto');
  ga('send', 'pageview');
</script>

<!-- 
https://developers.facebook.com/docs/plugins/share-button/
Include the JavaScript SDK on your page once, ideally right after the opening <body> tag.
-->

<script>
  window.fbAsyncInit = function() {
	FB.init({
	  appId      : '1535346446701691',
	  xfbml      : true,
	  version    : 'v2.1'
	});
  };

  (function(d, s, id){
	 var js, fjs = d.getElementsByTagName(s)[0];
	 if (d.getElementById(id)) {return;}
	 js = d.createElement(s); js.id = id;
	 js.src = "../../../../connect.facebook.net/en_US/sdk.js";
	 fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script>

<script>
	!function(d,s,id) {
		var js,fjs=d.getElementsByTagName(s)[0];
		if(!d.getElementById(id)) {
			js=d.createElement(s);js.id=id;
			js.src="../../../../platform.twitter.com/widgets.js";
			fjs.parentNode.insertBefore(js,fjs);
		}
	}(document,"script","twitter-wjs");
</script>


</head>

<style>
.full-page1
{
	position: relative;
	margin: 0; padding: 0; 
	width: 100%; 
	border: 1px solid red;
	color: white;
}

.full-page-header-table1
{
	display: table; 
	width: 100%;
	border: 1px solid orange;
}
</style>

<div style='display: table; width: 100%;'>
	<!-- 
		This should be the content of the top menu bar. So if you want to reuse
		this, just create a table div above and insert the section.
		The height here doesn't mater because it's controlled by the inner table.
-->
<div style='display: table-row;  height: 40px; width: 100%; background-color: #1565C0; color: white;'>
	<!-- we center the cell in the middle of the row -->
	<div style='display: table-cell; width: 100%; border: 1px none orange; vertical-align: middle; text-align: center;'>
		
		<div style='display: inline-block; position: relative; border: 1px none black; width: 670px; margin: 0 auto; padding: 0;'>			
			<!-- 
				This is our logo 
			-->
			<div style='display: inline-block; border: 2px none green;'>
				<span style='font-size: 18px; font-weight: 800;'><a href='../../../indexf17c.html' style='text-decoration: none; color: white;'>Scratchapixel 2.0</a></span>
			</div>
			<!-- 
				This is login 
				The only way you can vertically center stuff here is by forcing the height of the div
				and the eight of the text to be the same
			-->
			<div style='border: 2px none green; position: absolute; right: 0;  top: 0; bottom: 0px; height: 20px; line-height: 20px; margin: auto 0;'>
				<a style="color: white; text-decoration: none;" href="https://www.facebook.com/v2.5/dialog/oauth?client_id=1682406642074489&amp;state=6241aa28239e903f6cad376e5bc19dd1&amp;response_type=code&amp;sdk=php-sdk-5.4.0&amp;redirect_uri=https%3A%2F%2Fwww.scratchapixel.com%2Ffb-callback.php%3F&amp;scope=email">Sign in</a>			</div>
			
		</div>
	</div>
</div></div>

<body onload="onload();">

<div id='fb-root'></div> <!-- that's required by FB -->
<div class="page-content">
<article><div id='sap-root'></div><!-- that's needed by scratchapixel see onload() --><div class='lesson-title'>Rasterization: a Practical Implementation</div><div class='chapter-table'><div class='chapter-row'><div class='chapter-cell'><b>Contents</b></div></div><div class='chapter-row'><div class='chapter-cell'><a style='text-decoration: none;' href="overview-rasterization-algorithm.html">An Overview of the Rasterization Algorithm</a></div></div><div class='chapter-row'><div class='chapter-cell'><a style='text-decoration: none;' href="projection-stage.html">The Projection Stage</a></div></div><div class='chapter-row'><div class='chapter-cell'><a style='text-decoration: none;' href="rasterization-stage.html"><b>The Rasterization Stage</b></a></div></div><div class='chapter-row'><div class='chapter-cell'><a style='text-decoration: none;' href="visibility-problem-depth-buffer-depth-interpolation.html">The Visibility Problem, the Depth Buffer Algorithm and Depth Interpolation</a></div></div><div class='chapter-row'><div class='chapter-cell'><a style='text-decoration: none;' href="perspective-correct-interpolation-vertex-attributes.html">Perspective Correct Interpolation and Vertex Attributes</a></div></div><div class='chapter-row'><div class='chapter-cell'><a style='text-decoration: none;' href="rasterization-practical-implementation.html">Rasterization: a Practical Implementation</a></div></div><div class='chapter-row'><div class='chapter-cell'><a style='text-decoration: none;' href="../../../code3559.html?id=26&amp;origin=/lessons/3d-basic-rendering/rasterization-practical-implementation">Source Code</a></div></div></div><h2>Rasterization: What Are We Trying to Solve?</h2>

<div class="scratchquote">Rasterization is the process by which a primitive is converted to a two-dimensional image. Each point of this image contains such information as color and depth. Thus, rasterizing a primitive consists of two parts. The first is to determine which squares of an integer grid in window coordinates are occupied by the primitive. The second is assigning a color and a depth value to each such square. (OpenGL Specifications)</div>

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/rasterization-triangle1d41d.png?"/><p class="caption left">Figure 1:  by testing if pixels in the image overlap the triangle, we can draw an image of that triangle. This is the principle of the rasterization algorithm.</p>
</div>

<p>In the previous chapter, we learned how to performed the first step of the rasterization algorithm in a way, which is to project the triangle from 3D space onto the canvas. This definition is not entirely accurate in fact, since what we actually really did was to transform the triangle from camera space to screen space, which as mentioned in the previous chapter, is also a three-dimensional space. However the x- and y-coordinates of the vertices in screen-space correspond to the position of the triangle vertices on the canvas, and by converting them from screen-space to NDC space and then finally from NDC-space to raster-space, what we actually get in the end are the vertices 2D coordinates in raster space. Finally, we also know that the z-coordinates of the vertices in screen-space holds the original z-coordinate of the vertices in camera space (inverted so that we deal with positive numbers rather than negatives ones).</p>

<p>What we need to do next, is to loop over the pixel in the image and find out if any of these pixels overlap the "projected image of the triangle" (figure 1). In graphics APIs specifications, this test is sometimes called the <b>inside-outside test</b> or the <b>coverage test</b>. If they do, we then set the pixel in the image to the triangle's color. The idea is simple but of course, we now need to come up with a method to find if a given pixel overlaps a triangle. This is essentially what we will study in this chapter. We will learn about the method that is typically used in rasterization to solve this problem. It uses a technique known as the <b>edge function</b> which we are now going to describe and study. This edge function is also going to provide valuable information about the position of the pixel within the projected image of the triangle known as <b>barycentric coordinates</b>. Barycentric coordinates play an essential role in computing the actual depth (or the z-coordinate) of the point on the surface of the triangle that the pixel overlaps. We will also explain what barycentric coordinates are in this chapter and how they are computed.</p>

<p>At the end of this chapter, you will be able to actually produce a very basic rasterizer. In the next chapter, we will actually look into the possible issues with this very naive implementation of the rasterization algorithm. We will list what these issues are as well as study how they are typically addressed.</p>

<p>A lot of research has been done to optimize the algorithm. The goal of this lesson is not to teach you how to write or develop an optimized and efficient renderer based on the rasterization algorithm. The goal of this lesson is to teach the basic principles of the rendering technique. Don't think though that the techniques we present in these chapters, are not actually used. They are used to some extent, but how they are actually implemented either on the GPU or in a CPU version of a production renderer, is just likely to be a highly optimized version of the same idea. What is truly important is to understand the principle and how it works in general. From there, you can study on your own about the different techniques which are used to speed up the algorithm. But the techniques presented in this lesson are generic and make up the foundations of any rasterizer.</p>

<p>Keep in mind that drawing a triangle (since triangle is primitive we will use in this case), is a two steps problem:</p>
<ul>
<li>We first need to find which pixels overlap the triangle.</li>
<li>We then need to define which colors should the pixels overlapping the triangle be set to, a process that is called <b>shading</b></li>
</ul>
<p>The rasterization stage deals essentially with the first step. The reason we say essentially rather than exclusively is because at the rasterisation stage, we will also compute something called <b>barycentric coordinates</b> which to some extent, are used in the second step.</p> 

<h2>The Edge Function</h2>

<p>As mentioned above, they are several possible methods to find if a pixel overlaps a triangle. It would be good to document older techniques, but in this lesson, will only present the method that is generally used today. This method was presented by Juan Pineda in 1988 and a paper called "<b>A Parallel Algorithm for Polygon Rasterization</b>" (see references in the last chapter).</p>

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/rasterization-triangle2d41d.png?"/><p class="caption left">Figure 2: the principle of Pineda's method is to find a function, so that when we test on which side of this line a given point is, the function returns a positive number when it is to the left of the line, a negative number when it is to the right of this line, and zero, when the point is exactly on the line.</p>
</div>

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/rasterization-triangle3d41d.png?"/><p class="caption left">Figure 3: points contained within the white area are all located to the right of all three edges of the triangle.</p>
</div>

<p>Before we look into Pineda's technique itself, we will first describe the principle of his method. Let's say that the edge of a triangle can be seen as a line splitting the 2D plane (the plane of the image) in two (as shown in figure 2). The principle of Pineda's method is to find a function which he called the <b>edge function</b>, so that when we test on which side of this line a given point is (the point P in figure 2), the function returns a negative number when it is to the left of the line, a positive number when it is to the right of this line, and zero, when the point is exactly on the line.</p>

<p>In figure 2, we applied this method to the first edge of the triangle (defined by the vertices v0-v1. Be careful the order is important). If we now apply the same method to the two other edges (v1-v2 and v2-v0), we then can clearly see that there is an area (the white triangle) within which all points are positive (figure 3). If we take a point within this area, then we will find that this point is to the right of all three edges of the triangle. If P is in fact a point in the centre of a pixel, we can then use this method to find if the pixel overlaps the triangle. If for this point, we find that the edge function returns a positive number for all three edges, then the pixel is contained in the triangle (or may lie on one of its edges). The function Pinada uses also happens to be linear which means that it can be computed incrementally but we will come back on this point later.</p>

<p>Now that we understand the principle, let's find out what that function is. The edge function is defined as (for the edge defined by vertices V0 and V1):</p>

$$E_{01}(P) = (P.x - v0.x) * (V1.y - V0.y) - (P.y - V0.y) * (V1.x - V0.x).$$

<p>As the paper mentions, this function has the useful property that its value is related to the position of the point (x,y) relative to the edge defined by the points V0 and V1:</p>
<ul>
<li>E(P) > 0 if P is to the "right" side</li>
<li>E(P) = 0 if P is exactly on the line</li>
<li>E(P) < 0 if P is to the "left " side</li>
</ul>
<p>In fact this function is equivalent in mathematics to the magnitude of the cross products between the vector (v1-v0) and (P-v0). We can also write these vectors in a matrix form (presenting this as a matrix has no other interest than just presenting the two vectors in a neat way):</p>

$$
\begin{vmatrix}
(P.x - V0.x) & (P.y - V0.y) \\  (V1.x - V0.x) & (V1.y - V0.y)
\end{vmatrix}
$$

<p>If we write that \(A = (P-V0)\) and \(B = (V1 - V0)\), then we can also write the vectors A and B as a 2x2 matrix:</p>

$$
\begin{vmatrix}
 A.x & A.y \\ B.x & B.y
\end{vmatrix}
$$

<p>The <b><a href="http://en.wikipedia.org/wiki/Determinant#2.C2.A0.C3.97.C2.A02_matrices">determinant</a></b> of this matrix can be computed as:</p>

$$A.x * B.y - A.y * B.x.$$

<p>If you now replace the vectors A and B with the vectors (P-V0) and (V1-V0) back again, you get:</p>

 $$(P.x - V0.x) * (V1.y - V0.y) - (P.y - V0.y) * (V1.x - V0.x).$$

<p>Which as you can see, is similar to the edge function we have defined above. In other words, the edge function can either be seen as the determinant of the 2x2 matrix defined by the components of the 2D vectors (P-v0) and (v1-v0) or also as the magnitude of the cross product of the vectors (P-V0) and (V1-V0). In fact both the determinant and the magnitude of the cross product of two vectors have the same geometric interpretation. Let's explain.</p>

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/cross-product-animd41d.gif?"/><p class="caption left">Figure 4: the cross-product of vector A (red) and B (blue) gives a vector C (green) perpendicular to the plane defined by A and B. The magnitude of vector C depends on the angle between A and B. It can either be positive or negative.</p>
</div>

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/cross-productd41d.png?"/><p class="caption left">Figure 5:  the area of the parallelogram is the absolute value of the determinant of the matrix formed by the vectors A and B (or the magnitude of the cross-product of the two vectors A and B).</p>
</div>

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/cross-product1d41d.png?"/><p class="caption left">Figure 6: the area of the parallelogram is the absolute value of the determinant of the matrix formed by the vectors A and B. If the angle \(theta\) is lower than \(pi\) then the "signed" area is positive. If the angle is greater than \(pi\) then the "signed" area is negative. The angle is computed with regards to the Cartesian coordinates defined by the vector A and D. They can be seen to seperate the plane in two halves.</p>
</div>

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/cross-product2d41d.gif?"/><p class="caption left">Figure 7: P is contained in the triangle if the edge function returns a positive number for the three indicated pairs of vectors.</p>
</div>

<p>Understanding what's actually happening is easier when we look at the result of a cross product between two 3D vectors (figure 4). In 3D, the cross-product returns another 3D vector which is perpendicular (or orthonormal) to the two original vectors. But as you can see in figure 4, the magnitude of that orthonormal vector also changes with the orientation of the two vectors with respect to each other. In figure 4, we assume a right-hand coordinate system. When the two vectors A (red) and B (blue) are either pointing exactly in the same direction or in opposite directions, the magnitude of the third vector C (in green) is zero. Vector A has coordinates (1,0,0) and is fixed. When vector B has coordinates (0,0,-1), then the green vector, vector C has coordinate (0,-1,0). If we were to find its "signed" magnitude, we would find that it is equal to -1. On the other hand, when vector B has coordinates (0,0,1), then C has coordinates (0,1,0) and its signed magnitude is equal to 1. In one case the "signed" magnitude is negative, and in the second case, the signed magnitude is positive. In fact, in 3D, the magnitude of a vector can be interpreted as the area of the parallelogram having A and B as sides as shown in figure 5 (read the Wikipedia article on the <a href="http://en.wikipedia.org/wiki/Cross_product#Geometric_meaning">cross product</a> to get more details on this interpretation):</p>

$$Area = || A \times B || = ||A|| ||B|| \sin(\theta).$$

<p>Obviously an area should always be positive, though the sign of the above equation provides an indication about the orientation of the vectors A and B with respect to each other. When with respect to A, B is within the half plane defined by vector A and a vector orthogonal to A (let's call this vector D; note that A and D form an 2D Cartesian coordinate system), then the result of the equation is positive. When B is within the opposite half plane, the result of the equation is negative (figure 6). Another way of explaining this result, is that the result is positive when the angle \(\theta\) is in the range \(]0,\pi[\) and negative when \(\theta\) is in the range \(]\pi, 2\pi[\). Note then when theta is exactly equals to 0 or \(\pi\) then the cross-product or the edge function returns 0.</p>

<p>To find if a point is inside a triangle, all we care about really is the sign of the function we used to compute the area of the parallelogram. However, the area itself also plays an important role in the rasterization algorithm; it is used to compute the barycentric coordinates of the point in the triangle, a technique we will study next. The cross product in 3D and 2D has the same geometric interpretation, thus the cross-product between two 2D vectors also returns the "signed" area of the parallelogram defined by the two vectors. The only difference is that in 3D, to compute the area of the parallelogram you need to use this equation:</p>

$$Area = || A \times B || = ||A|| ||B|| \sin(\theta),$$

<p>while in 2D, this area is given by the cross-product itself (which as mentioned before can also be interpreted as the determinant of a 2x2 matrix):

$$Area = A.x * B.y - A.y * B.x.$$

<p>From a practical point of view, all we need to do now, is test the sign of the edge function computed for each edge of the triangle and another vector defined by a point and the first vertex of the edge (figure 7).</p>

$$
\begin{array}{l}
E_{01}(P) = (P.x - V0.x) * (V1.y - V0.y) - (P.y - V0.y) * (V1.x - V0.x),\\
E_{12}(P) = (P.x - V1.x) * (V2.y - V1.y) - (P.y - V1.y) * (V2.x - V1.x),\\
E_{20}(P) = (P.x - V2.x) * (V0.y - V2.y) - (P.y - V2.y) * (V0.x - V2.x).
\end{array}
$$

<p>If all three tests are positive or equal to 0, then the point is inside the triangle (or lie on one of the edges of the triangle). If any one of the test is negative, then the point is outside the triangle. In code we get:</p>

<div name="code" class="code">bool edgeFunction(const Vec2f &a, const Vec3f &b, const Vec2f &c)
{
    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x) &gt= 0);
}

bool inside = true;
inside &= edgeFunction(V0, V1, p);
inside &= edgeFunction(V1, V2, p);
inside &= edgeFunction(V2, V0, p);

if (inside == true) {
    // point p is inside triangles defined by vertices v0, v1, v2
    ...
}</div>

<div class="question">Advanced: The edge function has the property of being linear. We refer you to the original paper if you wish to learn more about this property and how it can be used to optimise the algorithm. In short though, let's say that because of this property, the edge function can be run in parallel (several pixels can be tested at once). This makes the method ideal for a hardware implementation. This explains partially why pixels on the GPU are generally rendered as block of 2x2 pixels (pixels can be tested in a single cycle). Hint: you can also use SSE instructions and multi-threading to optimise the algorithm on the CPU.</div>

<h2>Alternative to the Edge Function</h2>

<p>There are obviously other ways than the edge function method to find if pixels overlap triangles, however as mentioned in the introduction of this chapter, we won't study them in this lesson. Just for reference though, the other common technique is called scanline rasterization. It is based on the Brenseham algorithm that is generally used to draw lines. GPUs use the edge method mostly because it is more generic than the scanline approach which is also more difficult to run in parallel that the edge method, but we won't provide more information on this topic in this lesson.</p>

<h2>Be Careful! Winding Order Matters</h2>

<div style="width: 400;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/windingd41d.png?"/><p class="caption left">Figure 8: clockwise and counter-clockwise winding.</p>
</div>

<p>One of the things we have been talking about yet, but which has a great importance in CG, is the order in which you declare the vertices making up the triangles. They are two possible conventions which you can see illustrated n the figure 8: <b>clockwise</b> or <b>counter-clockwise ordering</b> or <b>winding</b>. Winding is important because it essentially defines one important property of the triangle which is the orientation of its normal. Remember that the normal of the triangle can be computed from the cross product of the two vectors A=(V2-V0) and B=(V1-V0). Let's say that V0={0,0,0}, V1={1,0,0} and V2={0,-1,0} then (V1-V0)={1,0,0} and (V2-V0)={0,-1,0}. Let's now compute the cross product of these two vectors:</p>

$$
\begin{array}{l}
N = (V1-V0) \times (V2-V0)\\
N.x = a.y*b.z - a.z * b.y = 0*0 - 0*-1\\
N.y = a.z*b.x - a.x * b.z = 0*0 - 1*0\\
N.z = a.x*b.y - a.y * b.x = 1*-1 - 0*0 = -1\\
N=\{0,0,-1\}
\end{array}
$$

<p>However if you declare the vertices in counter-clockwise order, then V0={0,0,0}, V1={0,-1,0} and V2={1,0,0}, (V1-V0)={0,-1,0} and (V2-V0)={1,0,0}. Let's compute the cross product of these two vectors again:

$$
\begin{array}{l}
N = (V1-V0) \times (V2-V0)\\
N.x = a.y*b.z - a.z * b.y = 0*0 - 0*-1\\
N.y = a.z*b.x - a.x * b.z = 0*0 - 1*0\\
N.z = a.x*b.y - a.y * b.x = 0*0 - -1*1 = 1\\
N=\{0,0,1\}
\end{array}
$$

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/winding1d41d.png?"/><p class="caption left">Figure 9: the ordering defines the orientation of the normal.</p>
</div>

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/rasterization-triangle4d41d.png?"/><p class="caption left">Figure 10: the ordering defines if points inside the triangle are positive or negative.</p>
</div>

<p>As expected, the two normals are pointing in opposite directions. The orientation of the normal has a great importance for lots of different reasons, but one of the most important ones is called <b>face culling</b>. Most rasterizers and even ray-tracer for that matter may not render triangles whose normal is facing away from the camera.  This is called <a href="http://en.wikipedia.org/wiki/Back-face_culling">back-face culling</a>.  Most rendering APIs such as OpenGL or DirectX give the option to turn back-face culling off, however you should still be aware that vertex ordering plays a role in what's actually rendered, among many other things. And not surprisingly, the edge function is one of these other things. Before we get to explaining why it matters in our particular case, let's say that there is not particular rule when it comes to choosing the order. In reality so many details in a renderer implementation may change the orientation of the normal that you can't assume that by declaring vertices in a certain order, you will get the guarantee that the normal will be oriented a certain way. For instance rather that using the vectors (V1-V0) and (V2-V0) in the cross-product you could as have used (V0-V1) and (V2-V1) instead. It would have produced the same normal but flipped. Even if you use the vectors (V1-V0) and (V2-V0), <a href="../../mathematics-physics-for-computer-graphics/geometry/math-operations-on-points-and-vectors.html">remember</a> that the order of the vectors in the cross-product changes the sign of the normal: \(A \times B=-B \times A\). So the direction of your normal also depends of the order of the vectors in the cross-product. For all these reasons, don't try to assume that declaring vertices in one order rather than the other will give you one result or the other. What's important though, is that once you stick to the convention you have chosen. Generally, graphics APIs such as OpenGL and DirectX expect triangles to be declared in counter-clockwise order. We will also use counter-clockwise winding. Now let's see how ordering impacts the edge function.</p>

<p>Why does winding matter when it comes to the edge function? You may have noticed that since the beginning of this chapters, in all figures we have drawn the triangle vertices in clockwise order. We have also defined the edge function as:</p>

$$
\begin{array}{l}
E_{AB}(P) &=& (P.x - A.x) * (B.y - A.y) - \\
&& (P.y - A.y) * (B.x - A.x)
\end{array}
$$

<p>If we respect this convention, then points to the right of the line defined by the vertices A and B will be positive. For example a point to the right of V0V1, V1V2 or V2V0 would be positive. However, if we were to declare the vertices in counter-clockwise order, points to the right of an edged defined by vertices A and B would still be positive, but then they would be outside the triangle. In other words points overlapping the triangle would not be positive but negative.(figure 10). You can potentially still get the code working with positive numbers with a small change to the edge function:</p>

$$E_{AB}(P) = (A.x - B.x) * (P.y - A.y) - (A.y - B.y) * (P.x - A.x).$$

<p>Conclusion, depending on the ordering convention you use, you may need to use one version of the edge function or the other.<p>

<h2>Barycentric Coordinates</h2>

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/barycentric1d41d.png?"/><p class="caption left">Figure 11: the area of a parallelogram is twice the area of a triangle.</p>
</div>

<p>Computing barycentric coordinates is not necessary to get the rasterization algorithm working. For a really naive implementation of the rendering technique, all you need is to project the vertices and use a technique like the edge function that we described above, to find if pixels are inside triangles. These are the only two necessary steps to produce an image. However the result of the edge function which as we explained above, can be interpreted as the area of the parallelogram defined by vector A and B can actually directly be used to compute these barycentric coordinates. Thus, it makes sense to study the edge function and the barycentric coordinates at the same time.</p>

<p>Before we get any further though, let's explain what these barycentric coordinates are. First, they come in a set of <b>three floating point numbers</b> which in this lesson, we will denote \(\lambda_0\), \(\lambda_1\) and \(\lambda_2\). Many different conventions exist but Wikipedia uses the greek letter lambda as well (\(\lambda\)) which is also used by other authors (the greek letter omega \(\omega\) is also sometimes used). This doesn't matter, you can call them the way you want. In short, the coordinates can be used to define any point on the triangle in the following manner:</p>

$$P = \lambda_0 * V0 + \lambda_1 * V1 + \lambda_2 * V2.$$ 

<p>Where as usual, V0, V1 and V2 are the vertices of a triangle. These coordinates can take on any value, but for points which are inside the triangle (or lying on one of its edges) they can only be in the range [0,1] and the sum of the three coordinates is equal to 1. In other words:</p>

$$\lambda_0 + \lambda_1 + \lambda_2 = 1, \text{ for } P \in \triangle{V0, V1, V2}.$$

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/barycentric2d41d.png?"/><p class="caption left">Figure 12: how do we find the color of P?</p>
</div>

<p>This is a form of interpolation if you want. They are also sometimes defined as <b>weights</b> for the triangle's vertices (which is why in the code we will denote them with the letter w). A point overlapping the triangle can be defined as "a little bit of V0 plus a little bit of V1 plus a little bit of V2". Note that when any of the coordinates is 1 (which means that the others in this case are necessarily 0) then the point P is equal to one of the triangle's vertices. For instance if \(\lambda_2 = 1\) then P is equal to V2. Interpolating the triangle's vertices to find the position of a point inside the triangle is not that useful. But the method can also be used to interpolate across the surface of the triangle any quantity or variable that has been defined at the triangle's vertices. Imagine for instance that you have defined a color at each vertex of the triangle. Say V0 is red, V1 is green and V2 is blue (figure 12). What you want to do, is find how are these three colors interpolated across the surface of the triangle. If you know the barycentric coordinates of a point P on the triangle, then its color \(C_P\) (which is a combination of the triangle vertices' colors) is defined as:</p>

$$C_P = \lambda_0 * C_{V0} + \lambda_1 * C_{V1} + \lambda_2 * C_{V2}.$$ 

<p>This is a very handy technique which is going to be useful to shade triangles. Data associate with the vertices of triangles are called <b>vertex attribute</b>. This is a very common and very important technique in CG. <b>The most common vertex attributes are colors, normals and texture coordinates</b>. What this means in practice, is that generally when you define a triangle you don't only pass on to the renderer the triangle vertices but also its associated vertex attributes. For example if you want to shade the triangle you may need a color and normal vertex attribute, which means that each triangle will be defined by 3 points (the triangle vertex positions), 3 colors (the color of the triangle vertices) and 3 normals (the normal of the triangle vertices). Normals too can be interpolated across the surface of the triangle. Interpolated normals are used in a technique called <b><a href="http://en.wikipedia.org/wiki/Gouraud_shading">smooth shading</a></b> which was first introduced by Henri Gouraud. We will explain this technique later when we get to shading.</p>

<p>How do we find these barycentric coordinates? It turns out to be simple. As mentioned above when we presented the edge function, the result of the edge function can be interpreted as the area of the parallelogram defined by the vectors A and B. If you look at figure 8, you can easily see that the area of the triangle defined by the vertices V0, V1, and V2, is just half of the area of the parallelogram defined by the vectors A and B. The area of the triangle is thus half the area of the parallelogram which we know can be computed by the cross-product of the two 2D vectors A and B:</p>

$$Area_{\triangle{V0V1V2}}= {1 \over 2} {A \times B} = {1 \over 2}(A.x * B.y - A.y * B.x).$$

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/barycentric3d41d.png?"/><p class="caption left">Figure 13: connecting P to each vertex of the triangle forms three sub-triangles.</p>
</div>

<p>If the point P is inside the triangle, then you can see by looking at figure 3, that we can draw three sub-triangles: V0-V1-P (green), V1-V2-P (magenta) and V2-V0-P (cyan). It is quite obvious that the sum of the these three sub-triangle areas, is equal to the area of the triangle V0-V1-V2:</p>

$$
\begin{array}{l}
Area_{\triangle{V0V1V2}} =&Area_{\triangle{V0V1P}} + \\& Area_{\triangle{V1V2P}} + \\& Area_{\triangle{V2V0P}}.
\end{array}
$$

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/barycentric4d41d.png?"/><p class="caption left">Figure 14: the values for \(\lambda_0\), \(\lambda_1\) and \(\lambda_2\) depends on the position of P on the triangle.</p>
</div>

<p>Let's fist try to intuitively get a sense of how they work. This will be easier hopefully if you look at figure 14. Each image in the series, shows what happens to the sub-triangle as a point P which is originally on the edge defined by the vertices V1-V2, moves towards V0. At the beginning, P lies exactly on the edge V1-V2. In a way, this is similar to a basic linear interpolation between two points. In other words, we could write:</p>

$$P = \lambda_1 * V1 + \lambda_2 * V2$$

<p>With \(\lambda_1 + \lambda_2 = 1\) thus \(\lambda_2 = 1 - \lambda_1\). What's more interesting in this particular case is that if the generic equation for computing the position of P using barycentric coordinates is:</p>

$$P = \lambda_0 * V0 + \lambda_1 * V1 + \lambda_2 * V2.$$ 

<p>Thus, it clearly shows that in this particular case, \(\lambda_0\) is equal to 0.</p>

$$
\begin{array}{l}
P = \lambda_0 * V0 + \lambda_1 * V1 + \lambda_2 * V2,\\
P = 0 * V0 + \lambda_1 * V1 + \lambda_2 * V2,\\
P = \lambda_1 * V1 + \lambda_2 * V2.
\end{array}
$$ 

<p>This is pretty simple. Note also that in the first image, the red triangle is not visible. Note also that P is closer to the V1 than it is to V2. Thus, somehow, \(\lambda_1\) is necessarily greater than \(\lambda_2\). Note also that in the first image, the green triangle is clearly bigger than the blue triangle. So if we summarize: when the red triangle is not visible, \(\lambda_0\) is equal to 0. \(\lambda_1\) is greater than \(\lambda_2\) and the green triangle is bigger than the blue triangle. Thus somehow, there seems to be a relationship between the area of the triangles and the barycentric coordinates. Furthermore the red triangle seems associated to \(\lambda_0\) the green triangle to \(\lambda_1\) and the blue triangle to \(\lambda_2\).</p>

<ul>
<li>\(\lambda_0\) is proportional to the area of the red triangle,</li>
<li>\(\lambda_1\) is proportional to the area of the green triangle,</li>
<li>\(\lambda_2\) is proportional to the area of the blue triangle.</li>
</ul>

<p>Now, let's jump directly to the last image. In this case, P is equal to V0. This is only possible if \(\lambda_0\) is equal to 1 and the two other coordinates are equal to 0:</p>

$$
\begin{array}{l}
P = \lambda_0 * V0 + \lambda_1 * V1 + \lambda_2 * V2,\\
P = 1 * V0 + 0 * V1 + 0 * V2,\\
P = V0.
\end{array}
$$

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/barycentric5d41d.png?"/><p class="caption left">Figure 15: to compute one of the barycentric coordinates, use the area of the triangle defined by P and the edge opposite to the vertex for which the barycentric coordinate needs to be computed.</p>
</div>

<p>Note also that in this particular case, the blue and green triangles have disappeared and that the area of the triangle V0-V1-V2 is the same than the area of the red triangle. This confirms our intuition that there is a relationship between the area of the sub-triangles and the barycentric coordinates. Finally, from the above observation we can also say that each barycentric coordinate is somehow related to the area of the sub-triangle defined by the edge directly opposite to the vertex the barycentric coordinate is associated with, and the point P. In other words (figure 15):</p> 

<ul>
<li><span style="color:red">\(\lambda_0\) is associated with V0. The edge opposite V0 is V1-V2. V1-V2-P define the red triangle.</span></li>
<li><span style="color:green">\(\lambda_1\) is associated with V1. The edge opposite V1 is V2-V0. V2-V0-P define the green triangle.</span></li>
<li><span style="color:blue">\(\lambda_2\) is associated with V2. The edge opposite V2 is V0-V1. V0-V1-P define the blue triangle.</span></li>
</ul>

<p>If you haven't noticed yet, the area of the red, green and blue triangle are given by the respective edge functions that we have been using before to find if P is inside the triangle, divided by 2 (remember that the edge function itself gives the "signed" area of the parallelogram defined by the two vectors A and B, where A and B can be any of the three edges of the triangle):</p>

$$
\begin{array}{l}
\color{red}{Area_{tri}(V1,V2,P)}=&{1\over2}E_{12}(P),\\
\color{green}{Area_{tri}(V2,V0,P)}=&{1\over2}E_{20}(P),\\
\color{blue}{Area_{tri}(V0,V1,P)}=&{1\over2}E_{01}(P).\\
\end{array}
$$

<p>In fact, the barycentric coordinates can be computed as the ratio between the area of the sub-triangles and the area of the triangle V0V1V2:</p> 

$$\begin{array}{l}
\color{red}{\lambda_0 = \dfrac{Area(V1,V2,P) } {Area(V0,V1,V2)}},\\
\color{green}{\lambda_1 = \dfrac{Area(V2,V0,P)}{Area(V0,V1,V2)}},\\
\color{blue}{\lambda_2 = \dfrac{Area(V0,V1,P)}{Area(V0,V1,V2)}}.\\
\end{array}
$$

<p>What the division by the triangle area does, is essentially normalizing the coordinates. For example, when P has the same position than V0, then the area of the triangle V2V1P (the red triangle) is the same than the area of the triangle V0V1V2. Thus dividing one by the over gives 1, which is the value of the coordinate \(\lambda_0\). Since in this case, the green and blue triangles have area 0, \(\lambda_1\) and \(\lambda_2\) are equal to 0 and we get:</p>

$$P = 1 * V0 + 0 * V1 + 0 * V2 = V0.$$

<p>Which is what we expect.</p>
 
<p>To compute the area of a triangle we can use the edge function as mentioned before. This works for the sub-triangles as well as the main triangle V0V1V2. However the edge function returns the area of the parallelogram instead of the area of the triangle (figure 8) but since the barycentric coordinates are computed as the ratio between the sub-triangle area and the main triangle area, we can ignore the division by 2 (this division which is in the numerator and the denominator cancel out):</p>

$$\lambda_0 = \dfrac{Area_{tri}(V1,V2,P)}{Area_{tri}(V0,V1,V2)} = \dfrac{1/2 E_{12}(P)}{1/2E_{12}(V0)} =  \dfrac{E_{12}(P)}{E_{12}(V0)}.$$

Note that: \( E_{01}(V2) = E_{12}(V0) = E_{20}(V1) = 2 * Area_{tri}(V0,V1,V2)\).

<p>Let's see how it looks in code. We were already computing the edge functions before to test if points were inside triangles. Only, in our previous implementation we were just returning true or false depending on whether the result of the function was either positive or negative. To compute the barycentric coordinates, we need the actual result of the edge function. We can also use the edge function to compute the area (multiplied by 2) of the triangle. Here is a version of an implementation that tests if a point P is inside a triangle and if so, computes its barycentric coordinates:</p>

<div name="code" class="code">float edgeFunction(const Vec2f &a, const Vec3f &b, const Vec2f &c)
{
    return (c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x);
}

float area = edgeFunction(v0, v1, v2); // area of the triangle multiplied by 2
float w0 = edgeFunction(v1, v2, p); // signed area of the triangle v1v2p multiplied by 2
float w1 = edgeFunction(v2, v0, p); // signed area of the triangle v2v0p multiplied by 2
float w2 = edgeFunction(v0, v1, p); // signed area of the triangle v0v1p multiplied by 2

// if point p is inside triangles defined by vertices v0, v1, v2
if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
    // barycentric coordinates are the areas of the sub-triangles divided by the area of the main triangle
    w0 /= area;
    w1 /= area;
    w2 /= area;
}</div>

<p>Let's try this code to produce an actual image.</p>

<div class="question"><p>We know that:</p>
$$\lambda_0 + \lambda_1 + \lambda_2 = 1.$$
<p>We also know that we can compute any value across the surface of the triangle using the following equation:</p>
$$Z = \lambda_0 * Z0 + \lambda_1 * Z1 + \lambda_0 * Z2.$$
<p>The value that we interpolate in this case is Z which can be anything we want or as the name suggests, the z-coordinate of the triangle's vertices in camera space. We can re-write the first equation:</p>
$$\lambda_0 = 1 - \lambda_1 - \lambda_2.$$
<p>If we plug this equation in the equation to compute Z and simplify, we get:</p>
$$Z = Z0 + \lambda_1(Z1 - Z0) + \lambda_2(Z2 - Z0).$$
<p>\(Z1 - Z0\) and \(Z2 - Z0\) can generally be precomputed which simplifies the computation of Z to two additions and two multiplications. We mention this optimisation because GPUs use it and people may mention it for this reason essentially.</p>
</div>

<h2>Interpolate vs. Extrapolate</h2>

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/extrapolated41d.png?"/><p class="caption left">Figure 16: interpolation vs. extrapolation.</p>
</div>

<p>One thing worth noticing is that the computation of barycentric coordinates works independently from its position with respect to the triangle. In other words, the coordinates are valid if the point is inside our outside the triangle. When the point is inside, using the barycentric coordinates to evaluate the value of a vertex attribute is called interpolation, and when the point is outside, we speak of extrapolation. This an important detail because in some cases, we will have to evaluate the value of a given vertex attribute for points that potentially don't overlap triangles. To be more specific, this will be needed  to compute the derivatives of the triangle texture coordinates for example. These derivatives are used to filter textures properly. If you are interested in learning more about this particular topic we invite you to read the lesson on Texture Mapping. In the meantime, all you need to remember is that  barycentric coordinates are valid even when the point doesn't cover the triangle. You also need to know about the difference between vertex attribute extrapolation and interpolation.</p>

<h2>Rasterization Rules</h2>

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/top-leftd41d.png?"/><p class="caption left">Figure 17:  pixels may cover an edge shared by two triangles.</p>
</div>

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/top-left2d41d.png?"/><p class="caption left">Figure 18: If the geometry is semi-transparent, a dark edge may appear where pixels overlap the two triangles.</p>
</div>

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/top-left3d41d.png?"/><p class="caption left">Figure 19: top and left edges.</p>
</div>

<p>In some special cases, a pixel may overlap more than one triangle. This happens when a pixel lies exactly on an edge shared by two triangles as shown in figure 17. Such pixel would pass the coverage test for both triangles. If they are semi-transparent, a dark edge may appear where the pixels overlap the two triangles as a result of the way semi-transparent objects are combined with each other (imagine two super-imposed semi-transparent sheets of plastic. The surface is more opaque and looks darker than the individual sheets). You would get something similar to what you can see in figure 18, which is a darker line where the two triangles share an edge.</p>

<p>The solution to this problem is to come up with some sort of rule that guarantees that a pixel can never overlap twice two triangles sharing an edge. How do we do that? Most graphics APIs such as OpenGL and DirectX define something which they call the <b>top-left rule</b>. We already know the coverage test returns true if a point is either inside the triangle or if it lies on any of the triangle edges. What the top-left rule says though, is that the pixel or point is considered to overlap a triangle if it is either inside the triangle or lies on either a triangle top edge or any edge that is considered to be a left edge. What is a top and left edge? If you look at figure 19, you can easily see what we mean by top and left edge.</p>
<ul>
<li>A top edge is a edge that is perfectly horizontal and whose defining vertices are above the third one. Technically this means that the y-coordinates of the vector V[(X+1)%3]-V[X] is equal to 0 and that its x-coordinates is positive (greater than 0).</li>
<li>A left edge is essentially an edge that is going up. Keep in mind that in our case, vertices are defined in clockwise order. An edge is considered to go up if its respective vector V[(X+1)%3]-V[X] (where X can either be 0, 1, 2) has a positive y-coordinate.</li>
</ul>

<div class="question">Of course if you are using a counter-clockwise order, a top edge is an edge that is horizontal and whose x-coordinate is negative, and a left edge is an edge whose y-coordinate is negative.</div>

<p>In pseudo code we have:</p>

<div name="code" class="code">// Does it pass the top-left rule?
Vec2f v0 = { ... };
Vec2f v1 = { ... };
Vec2f v2 = { ... };

float w0 = edgeFunction(v1, v2, p); 
float w1 = edgeFunction(v2, v0, p); 
float w2 = edgeFunction(v0, v1, p); 

Vec2f edge0 = v2 - v1;
Vec2f edge1 = v0 - v2;
Vec2f edge2 = v1 - v0;

bool overlaps = true;

// If the point is on the edge, test if it is a top or left edge, 
// otherwise test if  the edge function is positive
overlaps &= (w0 == 0 ? ((edge0.y == 0 && edge0.x > 0) ||  edge0.y > 0) : (w0 > 0));
overlaps &= (w1 == 0 ? ((edge1.y == 0 && edge1.x > 0) ||  edge1.y > 0) : (w1 > 0));
overlaps &= (w1 == 0 ? ((edge2.y == 0 && edge2.x > 0) ||  edge2.y > 0) : (w2 > 0));

if (overlaps) {
    // pixel overlap the triangle
    ...
}</div>

<p>This version is valid as a proof of concept but highly unoptimized. The key idea is to first check wether any of the value return by the edge function is equal to 0 which means that the point lies on the edge. In this case, we test if the edge in question is a top-left edge. If it is, it returns true. If the value returned by the edge function is not equal to 0, we then return true if the value is greater than 0. We won't implement the top-left rule in the program provided with this lesson.</p>

<h2>Putting Things Together: Finding if a Pixel Overlaps a Triangle</h2>

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/raster2dd41d.png?"/><p class="caption left">Figure 20: example of vertex attribute linear interpolation using barycentric coordinates.</p>
</div>

<p>Let's test the different techniques we learned about in this chapter, in a program that produces an actual image. We will just assume that we have projected the triangle already (check the last chapter of this lesson for a complete implementation of the rasterization algorithm). We will also assign a color to each vertex of the triangle. Here is how the image is formed. We will loop over all the pixels in the image and test if they overlap the triangle using the edge function method. All three edges of the triangle are tested against the current position of the pixel, and if the edge function returns a positive number for all the edges then the pixel overlaps the triangle. We can then compute the pixel's barycentric coordinates and use these coordinates to shade the pixel by interpolating the color defined at each vertex of the triangle. The result of the frame-buffer is saved to a PPM file (that you can read with Photoshop). The output of the program is shown in figure 20.<p>

<div class="question">Note that one possible optimisation for this program would be to loop over the pixels contained in the bounding box of the triangle. We haven't made this optimization in this version of the program but you can make it yourself if you wish (using the code from the previous chapters). You can also check the source code of this lesson (available in the last chapter).</div>

<div class="question">Note also that in this version of the program, we move point P to the center of each pixel. You could as well use the pixel integer coordinates. You will find more details on this topic in the next chapter.</div>

<div name="code" class="code">// c++ -o raster2d raster2d.cpp
// (c) www.scratchapixel.com

#include &ltcstdio&gt
#include &ltcstdlib&gt
#include &ltfstream&gt

typedef float Vec2[2];
typedef float Vec3[3];
typedef unsigned char Rgb[3];

inline
float edgeFunction(const Vec2 &a, const Vec2 &b, const Vec2 &c)
{ return (c[0] - a[0]) * (b[1] - a[1]) - (c[1] - a[1]) * (b[0] - a[0]); }

int main(int argc, char **argv)
{
    Vec2 v0 = {491.407, 411.407};
    Vec2 v1 = {148.593, 68.5928};
    Vec2 v2 = {148.593, 411.407};
    Vec3 c0 = {1, 0, 0};
    Vec3 c1 = {0, 1, 0};
    Vec3 c2 = {0, 0, 1};
    
    const uint32_t w = 512;
    const uint32_t h = 512;
    
    Rgb *framebuffer = new Rgb[w * h];
    memset(framebuffer, 0x0, w * h * 3);
    
    float area = edgeFunction(v0, v1, v2);
    
    for (uint32_t j = 0; j &lt h; ++j) {
        for (uint32_t i = 0; i &lt w; ++i) {
            Vec2 p = {i + 0.5f, j + 0.5f};
            float w0 = edgeFunction(v1, v2, p);
            float w1 = edgeFunction(v2, v0, p);
            float w2 = edgeFunction(v0, v1, p);
            if (w0 &gt= 0 && w1 &gt= 0 && w2 &gt= 0) {
                w0 /= area;
                w1 /= area;
                w2 /= area;
                float r = w0 * c0[0] + w1 * c1[0] + w2 * c2[0];
                float g = w0 * c0[1] + w1 * c1[1] + w2 * c2[1];
                float b = w0 * c0[2] + w1 * c1[2] + w2 * c2[2];
                framebuffer[j * w + i][0] = (unsigned char)(r * 255);
                framebuffer[j * w + i][1] = (unsigned char)(g * 255);
                framebuffer[j * w + i][2] = (unsigned char)(b * 255);
            }
        }
    }
    
    std::ofstream ofs;
    ofs.open("./raster2d.ppm");
    ofs << "P6\n" << w << " " << h << "\n255\n";
    ofs.write((char*)framebuffer, w * h * 3);
    ofs.close();
    
    delete [] framebuffer;
    
    return 0; 
}</div>


<p>As you can see and in conclusion, we can say that the rasterization algorithm is in itself quite simple (and the basic implementation of this technique quite easy as well).</p>

<h2>Conclusion and What's Next?</h2>

<div style="width: 300;" class="captionImage right">
<img class="left"  src="../../../images/upload/rasterization/barycentric6d41d.png?"/><p class="caption left">Figure 21: barycentric coordinates are constant along lines parallel to an edge.</p>
</div>

<p>There are many interesting techniques and trivia related to the topics barycentric coordinates but this lesson is just an introduction to the rasterization algorithm thus we won't go any further. One trivia that is interesting to know though, is that barycentric coordinates are constant along lines parallel to an edge (as shown in figure 21).</p>

<p>In this lesson, we learned two important method and various concepts.</p>
<ul>
<li>First, we learned about the edge function and how it can be used to find if a point P overlaps a triangle. The edge function is computed for each edge of the triangle, and a second vector defined by the edge first vertex and another point P. If for all three edges, the function is positive, then point P overlaps the triangle.</li>
<li>Furthermore, we also learned that the result of the edge function can also be used to compute the barycentric coordinates of point P. These coordinates can be used to interpolate vertex data or vertex attribute across the surface of the triangle. They can be interpreted as weights for the various vertices. The most common vertex attribute are color, normal and texture coordinates.</li>
</ul></article></div><!-- end of page-content -->
			<div class='footer-prev-next'>
			<div class='footer-column'><div class='footer-prev-next-row'>
				<div class='footer-prev-next-cell' style='text-align: left;'><p><a href='projection-stage.html'><i style='float: left;' class='material-icons'>arrow_back</i>Previous Chapter</a></p></div>
				<div class='footer-prev-next-cell' style='text-align: center;'><p>Chapter 3 of  7</p></div>
				<div class='footer-prev-next-cell' style='text-align: right;'><p><a href='visibility-problem-depth-buffer-depth-interpolation.html'>Next Chapter <i style='float: right;' class='material-icons'>arrow_forward</i></a></p></div>
			</div></div>
			</div>

</body>

<!-- Mirrored from www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/rasterization-stage by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 01 Aug 2021 17:11:00 GMT -->
</html>