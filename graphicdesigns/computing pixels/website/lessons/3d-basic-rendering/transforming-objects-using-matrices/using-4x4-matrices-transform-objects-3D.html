
<!-- 
NEED TO INSERT THE BODY AND ALL THE USEFUL STUFF HERE
-->

<html>

<!-- Mirrored from www.scratchapixel.com/lessons/3d-basic-rendering/transforming-objects-using-matrices/using-4x4-matrices-transform-objects-3D by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 01 Aug 2021 18:12:07 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<!-- title should be set at this point in page.php -->
<title>Transforming Objects using Matrices (Using 4x4 Matrices to Transform Objects in 3D)</title>

<meta name='author' content="Scratchapixel">
<meta name='copyright' content="&copy; 2009-2016 Scratchapixel">
<meta name='keywords' content='transform, transformation, matrix, 4x4 matrix, matrices, geometry, vertex, vertices, mesh, triangle mesh, transforming normals'>
<meta name='date' content='2014-08-15 10:34:46'>

<link rel="stylesheet" type="text/css" href="../../../css/scratchapixel.css"/>
<link rel="stylesheet" type="text/css" href="../../../css/page.css"/>

<link href='../../../../fonts.googleapis.com/css16e1.css?family=Noto+Sans' rel='stylesheet' type='text/css'/>
<link href='../../../../fonts.googleapis.com/css9908.css?family=Open+Sans:700,400,300' rel='stylesheet' type='text/css'/>

<!-- using the material icons from Google http://google.github.io/material-design-icons/ -->
<link rel="stylesheet" href="../../../../fonts.googleapis.com/icone91f.css?family=Material+Icons">

<script type="text/x-mathjax-config">
MathJax.Hub.Config(
	{tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}, 
	displayAlign: "left",
	displayIndent: "1em",
	"HTML-CSS": { scale: 90 },
	jax: ["input/TeX","input/MathML","input/AsciiMath","output/HTML-CSS","output/NativeMML"],
	extensions: ["tex2jax.js","../../../indexf17c.html","../../../indexf17c.html","../../../indexf17c.html","MathZoom.js"],
	TeX: {
		extensions: ["AMSmath.js","../../../indexf17c.html","../../../indexf17c.html","noUndefined.js"]
	}}
);
</script>

<script type="text/javascript" src="../../../../cdn.mathjax.org/mathjax/latest/MathJaxdda6.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script type="text/javascript"
	src="../../../scratchapixelSDK.js">
</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','../../../../www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42771397-1', 'auto');
  ga('send', 'pageview');
</script>

<!-- 
https://developers.facebook.com/docs/plugins/share-button/
Include the JavaScript SDK on your page once, ideally right after the opening <body> tag.
-->

<script>
  window.fbAsyncInit = function() {
	FB.init({
	  appId      : '1535346446701691',
	  xfbml      : true,
	  version    : 'v2.1'
	});
  };

  (function(d, s, id){
	 var js, fjs = d.getElementsByTagName(s)[0];
	 if (d.getElementById(id)) {return;}
	 js = d.createElement(s); js.id = id;
	 js.src = "../../../../connect.facebook.net/en_US/sdk.js";
	 fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script>

<script>
	!function(d,s,id) {
		var js,fjs=d.getElementsByTagName(s)[0];
		if(!d.getElementById(id)) {
			js=d.createElement(s);js.id=id;
			js.src="../../../../platform.twitter.com/widgets.js";
			fjs.parentNode.insertBefore(js,fjs);
		}
	}(document,"script","twitter-wjs");
</script>


	<!-- Open Graph data -->
	<meta property='fb:app_id' content='1535346446701691'/>
	<meta property='og:title' content='Transforming Objects using Matrices'/>
	<meta property='og:type' content='article'/>
	<meta property='og:url' content='https://www.scratchapixel.com//lessons/3d-basic-rendering/transforming-objects-using-matrices'/>
	<meta property='og:image' content='https://www.scratchapixel.com/images/design/logo_scratchapixel2015.png'/>
	<meta property='og:description' content='Lesson summary: In the previous lessons, we learned about using 4x4 transformation matrices to change the camera position. In this lesson, we will learn how to use matrices to change the position, the scale and the rotation of objects in the scene.'/> 
	<meta property='og:site_name' content='Scratchapixel'/>
	<meta property='fb:admins' content='1260067275'/>
	
</head>

<style>
.full-page1
{
	position: relative;
	margin: 0; padding: 0; 
	width: 100%; 
	border: 1px solid red;
	color: white;
}

.full-page-header-table1
{
	display: table; 
	width: 100%;
	border: 1px solid orange;
}
</style>

<div style='display: table; width: 100%;'>
	<!-- 
		This should be the content of the top menu bar. So if you want to reuse
		this, just create a table div above and insert the section.
		The height here doesn't mater because it's controlled by the inner table.
-->
<div style='display: table-row;  height: 40px; width: 100%; background-color: #1565C0; color: white;'>
	<!-- we center the cell in the middle of the row -->
	<div style='display: table-cell; width: 100%; border: 1px none orange; vertical-align: middle; text-align: center;'>
		
		<div style='display: inline-block; position: relative; border: 1px none black; width: 670px; margin: 0 auto; padding: 0;'>			
			<!-- 
				This is our logo 
			-->
			<div style='display: inline-block; border: 2px none green;'>
				<span style='font-size: 18px; font-weight: 800;'><a href='../../../indexf17c.html' style='text-decoration: none; color: white;'>Scratchapixel 2.0</a></span>
			</div>
			<!-- 
				This is login 
				The only way you can vertically center stuff here is by forcing the height of the div
				and the eight of the text to be the same
			-->
			<div style='border: 2px none green; position: absolute; right: 0;  top: 0; bottom: 0px; height: 20px; line-height: 20px; margin: auto 0;'>
				<a style="color: white; text-decoration: none;" href="https://www.facebook.com/v2.5/dialog/oauth?client_id=1682406642074489&amp;state=6241aa28239e903f6cad376e5bc19dd1&amp;response_type=code&amp;sdk=php-sdk-5.4.0&amp;redirect_uri=https%3A%2F%2Fwww.scratchapixel.com%2Ffb-callback.php%3F&amp;scope=email">Sign in</a>			</div>
			
		</div>
	</div>
</div></div>

<body onload="onload();">

<div id='fb-root'></div> <!-- that's required by FB -->
<div class="page-content">
<article><div id='sap-root'></div><!-- that's needed by scratchapixel see onload() --><div class='lesson-title'>Transforming Objects using Matrices</div><div style='width: 100%; margin: 0px; display: table; vertical-align: middle; border: 1px none red;'>
			<div style='display: table-row; height: 30px;'>
			<div style='margin: 0px; padding: 0px; border: 1px none blue ; display: table-cell; vertical-align: middle;'>
				<a href='https://twitter.com/share' class='twitter-share-button' data-lang='en'>Tweet</a>
			</div></div>
			<div style='display: table-row; height: 30px;'>
			<div style='padding: 0px; border: 1px none blue ; display: table-cell; vertical-align: middle;'>
				<div style='margin-top: 5px;' class='fb-like' data-share='true' data-width='450' data-show-faces='true'></div>
			</div></div></div><div class='chapter-table'><div class='chapter-row'><div class='chapter-cell'><b>Contents</b></div></div><div class='chapter-row'><div class='chapter-cell'><a style='text-decoration: none;' href="using-4x4-matrices-transform-objects-3D.html"><b>Using 4x4 Matrices to Transform Objects in 3D</b></a></div></div><div class='chapter-row'><div class='chapter-cell'><a style='text-decoration: none;' href="../../../code81c8.html?id=12&amp;origin=/lessons/3d-basic-rendering/transforming-objects-using-matrices">Source Code</a></div></div></div><span style='display: inline-block; width: 100%; margin: 0px 0px 10px 0px;'><i>Keywords: transform, transformation, matrix, 4x4 matrix, matrices, geometry, vertex, vertices, mesh, triangle mesh, transforming normals.</i></span><p>In this lesson, we will learn about using 4x4 transformation matrices to change the position, rotation and scale of 3D objects. So far, we assumed that the geometry we rendered was always positioned where the model was initially created. We learned how to ray-trace spheres with arbitrary center position. Though, the position of a polygon mesh in the scene is defined by the position of the vertices making up the mesh, and in most cases, this is not where we want the object to be in the final scene. Thus we need to transform it. Imagine for example that you have modelled a tree but want to render an image of a forest. To create the forest you will use the model of the tree you created, duplicate this model a large number of times and apply random transformations to these copies to make each tree scale, positon and rotation unique. By doing so, you introduce variety in the way that single model looks like from any viewpoint, giving the illusion that the forest is made of many unique tree models. Transformation more generally is useful to place any model into its final positon in the rendered scene (position here is used in a general sense, i.e. it includes the concept of position, rotation and scale). In CG, artists call this step layout or set dressing. It consist of taking objects as they were modelled (eventually taking multiply copies of the same model), and moving, rotating and scaling them around.</p>

<img class="left" style="margin-bottom: 12px;" src="../../../images/upload/transformations/trees-transformd41d.png?" />

<div style="width: 450px;" class="captionImage right">
<img class="left" src="../../../images/upload/transformations/cow-transformd41d.png?" />
<p class="caption left">Figure 1: from object to world space.</p>
</div>

<p>When they are created in a modeling software such as Maya or Blender, 3D models are generally centred around the world origin. More often the base of the model also lies in the xz-plane (in Maya, or xy plane in 3DSMax). When they are in this position, we say that the model is defined in <b>object space</b>. If we change the size, the rotation and the position of this object using a 4x4 transformation matrix for example, we say the object is defined in <b>world space</b> and the matrix transform the object from object to world space, is of course call the <b>object-to-world matrix</b> (in OpenGL this matrix is also known as the <b>model</b> matrix).</p>

<h2>Transforming Vertices</h2>

<p>From a programming point of view, transforming the an object from object space to world space is really straightforward. All we need to do, is loop over all the vertices of the mesh and transform them with the object-to-world matrix:</p>

<div name="code" class="code">for (uint32_t i = 0; i < numVertices; ++i) {
    const Vec3f & vertObjectSpace = vertices[i];
    Vec3f vertWorldSpace;
    objectToWorld.multVecMatrix(vertObjectSpace, vertWorldSpace);
    vertices[i] = vertWorldSpace;
}</div>

<p>The code above is written for clarity but it can be made faster. The object-to-world matrix can often be easily queried in 3D applications. For example in Maya you can select the object and use the Mel command <span class="code-inline">xform -q -ws -m</span> or <span class="code-inline">getAttr .worldMatrix</span>.</p>

<p>The object-to-world matrix is a property of any object in a scene, thus, we can define it as a member variable of the <span class="code-inline">Object</span> class in our program. The matrix will be passed to the constructor of the class (line 4).</p>

<div name="code" class="code">class Object
{
 public:
    Object(const Matrix44f &o2w) : objectToWorld(o2w) {}
    virtual ~Object() {}
    virtual bool intersect(const Vec3f &, const Vec3f &, float &, uint32_t &, Vec2f &) const = 0;
    virtual void getSurfaceProperties(const Vec3f &, const Vec3f &, const uint32_t &, const Vec2f &, Vec3f &, Vec2f &) const = 0;
    Matrix44f objectToWorld;
};</div>

<p> All objects will have access to this matrix, since they are all derived from this base class (quadrics, polygon meshes, etc.). For example, here is how it works for the <span class="code-inline">TriangleMesh</span> class. The object-to-world matrix is passed to the constructor of the <span class="code-inline">TriangleMesh</span> class (line 6) which in turn passes it on to the constructor of the <span class="code-inline">Object</span> class (line 13). Finally, in the constructor of the triangle mesh class, we loop over all the vertices making the mesh and set the mesh vertices to the input vertices transformed by the object-to-world matrix (lines 19-22):</p>

<div name="code" class="code">class TriangleMesh : public Object
{
public:
    // Build a triangle mesh from a face index array and a vertex index array
    TriangleMesh(
        const Matrix44f &o2w,
        const uint32_t nfaces,
        const std::unique_ptr&ltuint32_t []&gt &faceIndex,
        const std::unique_ptr&ltuint32_t []&gt &vertsIndex,
        const std::unique_ptr&ltVec3f []&gt &verts,
        std::unique_ptr&ltVec3f []&gt &normals,
        std::unique_ptr&ltVec2f []&gt &st) :
        Object(o2w),
        numTris(0)
    {
        ...
        // allocate memory to store the position of the mesh vertices
        P = std::unique_ptr&ltVec3f []&gt(new Vec3f[maxVertIndex]);
        for (uint32_t i = 0; i < maxVertIndex; ++i) {
            // transform object space vertex to world space position
            objectToWorld.multVecMatrix(verts[i], P[i]);
        }
        ...
    }
};</div>

<div class="question">The transformation pipeline...<br/><img class="left" src="../../../images/upload/transformations/transform-pipelined41d.png?" />
We now have all a full picture of the transformation pipeline. Objects are first transformed from object space to world space. If rasterization is used, objects are then transform from world-to-camera space. Vertices are then projected onto the screen (using the perspective projection matrix) to screen space and then remapped to NDC (as part of the perspective projection matrix). Finally, points on the image plane in NDC coordinates are converted to their final raster or pixel coordinates. In ray-tracing, we only care about the object to wold transformation matrix. Rays are defined in world space and the ray-geometry intersection test occurs in world space (it can also take place in object space as explained later in this lesson though this is generally more a special case).</div>

<h2>Transforming Normals</h2>

<p>Remember from the lesson on <a href="../../mathematics-physics-for-computer-graphics/geometry/transforming-normals.html">Geometry</a> that when we transform points and vectors by a 4x4 matrix, normals have to be transformed by the <b>transpose of the inverse of that object-to-camera matrix</b>. Thus, in addition to setting up the object-to-world matrix in the Object class constructor, we will also compute the world-to-object matrix (line 4), which is going to be needed to transform normals:</p>

<div name="code" class="code">class Object
{
 public:
    Object(const Matrix44f &o2w) : objectToWorld(o2w), worldToObject(o2w.inverse()) {}
    virtual ~Object() {}
    virtual bool intersect(const Vec3f &, const Vec3f &, float &, uint32_t &, Vec2f &) const = 0;
    virtual void getSurfaceProperties(const Vec3f &, const Vec3f &, const uint32_t &, const Vec2f &, Vec3f &, Vec2f &) const = 0;
    Matrix44f objectToWorld, worldToObject;
};</div>

<p>In the constructor of the <span class="code-inline">TriangleMesh</span>, we will now need to transform the normal by the transpose of the world-to-object matrix. We first compute the transpose matrix (line 27) and use it to transform all normals (line 33):</p>

<div name="code" class="code">TriangleMesh(
    const Matrix44f &o2w,
    const uint32_t nfaces,
    const std::unique_ptr&ltuint32_t []&gt &faceIndex,
    const std::unique_ptr&ltuint32_t []&gt &vertsIndex,
    const std::unique_ptr&ltVec3f []&gt &verts,
    std::unique_ptr&ltVec3f []&gt &normals,
    std::unique_ptr&ltVec2f []&gt &st) :
    Object(o2w),
    numTris(0)
{
    uint32_t k = 0, maxVertIndex = 0;
    // find out how many triangles we need to create for this mesh
    for (uint32_t i = 0; i < nfaces; ++i) {
        numTris += faceIndex[i] - 2;
        for (uint32_t j = 0; j < faceIndex[i]; ++j)
            if (vertsIndex[k + j] > maxVertIndex)
                maxVertIndex = vertsIndex[k + j];
        k += faceIndex[i];
    }
    maxVertIndex += 1;

    // allocate memory to store the position of the mesh vertices
    P = std::unique_ptr&ltVec3f []&gt(new Vec3f[maxVertIndex]);
    N = std::unique_ptr&ltVec3f []&gt(new Vec3f[maxVertIndex]);
    texCoordinates = std::unique_ptr&ltVec2f []&gt(new Vec2f[maxVertIndex]);
    Matrix44f transformNormals = worldToObject.transpose();
    for (uint32_t i = 0; i < maxVertIndex; ++i) {
        // transform vertex
        objectToWorld.multVecMatrix(verts[i], P[i]);

        // transform normal
        transformNormals.multDirMatrix(normals[i], N[i]);
        N[i].normalize();

        texCoordinates[i] = st[i];
    }

    // allocate memory to store triangle indices
    trisIndex = std::unique_ptr&ltuint32_t []&gt(new uint32_t [numTris * 3]);
    uint32_t l = 0;
    // generate the triangle index array and set normals and st coordinates
    for (uint32_t i = 0, k = 0; i < nfaces; ++i) { // for each  face
        for (uint32_t j = 0; j < faceIndex[i] - 2; ++j) { // for each triangle in the face
            trisIndex[l] = vertsIndex[k];
            trisIndex[l + 1] = vertsIndex[k + j + 1];
            trisIndex[l + 2] = vertsIndex[k + j + 2];
            l += 3;
        }
        k += faceIndex[i];
    }
}</div>

<p>Note that texture coordinates don't need to be transformed. They live in their own 2D space and are not affected by the object's transformation. It is of course possible to transform texture coordinates but a 3x3 matrix in this case should be enough (to handle scale, rotation and translation in 2D space). Though in practice this is rarely done. Texture coordinates are generally adjusted in the 3D application and the transformations are directly baked into the coordinates themselves.</p>

<p>If we put all the pieces together and render a new object (the famous Utah teapot, an iconic object in the world of computer graphics) we can produce the two following images:</p>

<img class="left" style="margin-bottom: 12px;" src="../../../images/upload/transformations/ray-tracing-transform-resultsd41d.png?" />

<p>The image on the left uses face normals and the image on the right uses vertex normals. Note that the faceted look of the object in the left image disappeared in the right image. This is what vertex normals are used for, but don't worry too much about it, we will learn about smooth shading in the next lesson. While it is not obvious in these images that the teapot has been transformed, you can change the matrix in the program to the identity matrix and render the image again. You will more easily be able to spot the difference and the effect of the object-to-world matrix.</p>

<h2>A Special Use of the World-to-Object Matrix in Ray-Tracing</h2>

<div style="width: 300px;" class="captionImage right">
<img class="left" src="../../../images/upload/transformations/raysphereisectd41d.png?" />
<p class="caption left">Figure 2: the ray-sphere intersection technique only works when the sphere is centred at the origin. In a) because the sphere was moved away from the origin, the ray-sphere intersection test would return false (the ray would miss the sphere because it would intersect it as if it was centred at the origin). In b) we apply the world-to-object matrix from the sphere to the ray's origin and direction which transforms the ray as if the sphere was located at the origin. We can then safely apply the ray-sphere intersection routine.</p>
</div>

<p>In this part of the lesson we will show one interesting use of the world-to-object matrix in ray-tracing. In the lesson <a href="../minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection.html">A Minimal Ray-Tracer: Rendering Simple Shapes (Sphere, Cube, Disk, Plane, etc.)</a> we studied two techniques to compute the ray-sphere intersection, a geometric and a parametric method. While it is possible in both method to specify the centre and the radius of the sphere we wish to render, let's imagine a situation in which we don't know how to ray-trace a sphere unless the sphere has radius 1 and is centred about the world coordinate system origin. How could we still change the sphere size, rotation and position? The solution to this problem is in fact simple. If the sphere new scale, position and rotation is defined by a 4x4 transformation matrix, then rather than transforming the sphere using this matrix, we will transform the ray instead of the sphere to the sphere object space, by transforming its position and direction using the sphere world-to-object matrix (the inverse of the sphere object-to-world matrix). We don't transform the sphere, we transform the ray by the matrix inverse. Imagine that we translate the sphere by 2 units in Y. Then instead of computing the intersection of the ray with the translated sphere, we keep the sphere at the origin, and move the ray position by -2 in Y (as shown in figure 2). This technique is quite common in ray-tracing. It is sometimes more convenient to compute the intersection of a shape while the shape is in its object space. Thus rather than transforming the shape by the object-to-world matrix and test the ray-shape intersection with the ray in world space, we transform the ray to the shape object space, and perform the ray-geometry test in object space.</p>

<div name="code" class="code">bool intersect(const Vec3f &orig, const Vec3f &dir, float &t) const
{
    Vec3f origObject, dirObject;
    worldToObject.multVecMatrix(orig, origObject);
    worldToObject.multDirMatrix(dir, dirObject);
    float t0, t1; // solutions for t if the ray intersects
    // analytic solution
    float a = dirObject.dotProduct(dirObject);
    float b = 2 * dirObject.dotProduct(origObject);
    float c = origObject.dotProduct(origObject) - 1; // radius = 1 and radius^2 = 1
    if (!solveQuadratic(a, b, c, t0, t1)) return false;
    if (t0 > t1) std::swap(t0, t1);

    if (t0 < 0) {
        t0 = t1; // if t0 is negative, let's use t1 instead
        if (t0 < 0) return false; // both t0 and t1 are negative
    }

    t = t0;

    return true;
}</div>

<p>Obviously, the problem with this technique is that \(t\) the intersection distance, is not in world space anymore but in object space. The value computed by this method can't be compared to the value returned for instance by the <span class="code-inline">intersect()</span> method of the <span class="code-inline">TriangleMesh</span> class. To fix the problem, you need to compute the intersection point in object space, transform the hit point to world space, and then compute \(t\) by taking the distance between the ray origin and the hit point in world space. Obviously all these complications are worth it if computing the ray-geometry intersection is much more efficient in object space than world space. We won't implement this method in our program. Mentioning the method is enough but you can give it a try as an exercise by adapting the code above.</p>

<h2>Source Code</h2>

<p>As usual, the source code of the full program can be found in the <a href="../../../code81c8.html?id=12&amp;origin=/lessons/3d-basic-rendering/transforming-objects-using-matrices">last chapter</a> of this lesson.</p>

<h2>Exercises</h2>

Render multiply copies of the teapot geometry using different transformation matrices.</article></div><!-- end of page-content -->
			<div class='footer-prev-next'>
			<div class='footer-column'><div class='footer-prev-next-row'>
				<div class='footer-prev-next-cell' style='text-align: left;'></div>
				<div class='footer-prev-next-cell' style='text-align: center;'><p>Chapter 1 of  2</p></div>
				<div class='footer-prev-next-cell' style='text-align: right;'><p><a href='../../../code81c8.html?id=12&amp;origin=/lessons/3d-basic-rendering/transforming-objects-using-matrices'>Next Chapter <i style='float: right;' class='material-icons'>arrow_forward</i></a></p></div>
			</div></div>
			</div>

</body>

<!-- Mirrored from www.scratchapixel.com/lessons/3d-basic-rendering/transforming-objects-using-matrices/using-4x4-matrices-transform-objects-3D by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 01 Aug 2021 18:12:42 GMT -->
</html>