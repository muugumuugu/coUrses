(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.delaunay=f()}})(function(){var define,module,exports;return(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){"use strict"
module.exports=incrementalConvexHull
var orient=require("robust-orientation")
var compareCell=require("simplicial-complex").compareCells
function compareInt(a,b){return a-b}
function Simplex(vertices,adjacent,boundary){this.vertices=vertices
this.adjacent=adjacent
this.boundary=boundary
this.lastVisited=-1}
Simplex.prototype.flip=function(){var t=this.vertices[0]
this.vertices[0]=this.vertices[1]
this.vertices[1]=t
var u=this.adjacent[0]
this.adjacent[0]=this.adjacent[1]
this.adjacent[1]=u}
function GlueFacet(vertices,cell,index){this.vertices=vertices
this.cell=cell
this.index=index}
function compareGlue(a,b){return compareCell(a.vertices,b.vertices)}
function bakeOrient(d){var code=["function orient(){var tuple=this.tuple;return test("]
for(var i=0;i<=d;++i){if(i>0){code.push(",")}
code.push("tuple[",i,"]")}
code.push(")}return orient")
var proc=new Function("test",code.join(""))
var test=orient[d+1]
if(!test){test=orient}
return proc(test)}
var BAKED=[]
function Triangulation(dimension,vertices,simplices){this.dimension=dimension
this.vertices=vertices
this.simplices=simplices
this.interior=simplices.filter(function(c){return!c.boundary})
this.tuple=new Array(dimension+1)
for(var i=0;i<=dimension;++i){this.tuple[i]=this.vertices[i]}
var o=BAKED[dimension]
if(!o){o=BAKED[dimension]=bakeOrient(dimension)}
this.orient=o}
var proto=Triangulation.prototype
proto.handleBoundaryDegeneracy=function(cell,point){var d=this.dimension
var n=this.vertices.length-1
var tuple=this.tuple
var verts=this.vertices
var toVisit=[cell]
cell.lastVisited=-n
while(toVisit.length>0){cell=toVisit.pop()
var cellVerts=cell.vertices
var cellAdj=cell.adjacent
for(var i=0;i<=d;++i){var neighbor=cellAdj[i]
if(!neighbor.boundary||neighbor.lastVisited<=-n){continue}
var nv=neighbor.vertices
for(var j=0;j<=d;++j){var vv=nv[j]
if(vv<0){tuple[j]=point}else{tuple[j]=verts[vv]}}
var o=this.orient()
if(o>0){return neighbor}
neighbor.lastVisited=-n
if(o===0){toVisit.push(neighbor)}}}
return null}
proto.walk=function(point,random){var n=this.vertices.length-1
var d=this.dimension
var verts=this.vertices
var tuple=this.tuple
var initIndex=random?(this.interior.length*Math.random())|0:(this.interior.length-1)
var cell=this.interior[initIndex]
outerLoop:while(!cell.boundary){var cellVerts=cell.vertices
var cellAdj=cell.adjacent
for(var i=0;i<=d;++i){tuple[i]=verts[cellVerts[i]]}
cell.lastVisited=n
for(var i=0;i<=d;++i){var neighbor=cellAdj[i]
if(neighbor.lastVisited>=n){continue}
var prev=tuple[i]
tuple[i]=point
var o=this.orient()
tuple[i]=prev
if(o<0){cell=neighbor
continue outerLoop}else{if(!neighbor.boundary){neighbor.lastVisited=n}else{neighbor.lastVisited=-n}}}
return}
return cell}
proto.addPeaks=function(point,cell){var n=this.vertices.length-1
var d=this.dimension
var verts=this.vertices
var tuple=this.tuple
var interior=this.interior
var simplices=this.simplices
var tovisit=[cell]
cell.lastVisited=n
cell.vertices[cell.vertices.indexOf(-1)]=n
cell.boundary=false
interior.push(cell)
var glueFacets=[]
while(tovisit.length>0){var cell=tovisit.pop()
var cellVerts=cell.vertices
var cellAdj=cell.adjacent
var indexOfN=cellVerts.indexOf(n)
if(indexOfN<0){continue}
for(var i=0;i<=d;++i){if(i===indexOfN){continue}
var neighbor=cellAdj[i]
if(!neighbor.boundary||neighbor.lastVisited>=n){continue}
var nv=neighbor.vertices
if(neighbor.lastVisited!==-n){var indexOfNeg1=0
for(var j=0;j<=d;++j){if(nv[j]<0){indexOfNeg1=j
tuple[j]=point}else{tuple[j]=verts[nv[j]]}}
var o=this.orient()
if(o>0){nv[indexOfNeg1]=n
neighbor.boundary=false
interior.push(neighbor)
tovisit.push(neighbor)
neighbor.lastVisited=n
continue}else{neighbor.lastVisited=-n}}
var na=neighbor.adjacent
var vverts=cellVerts.slice()
var vadj=cellAdj.slice()
var ncell=new Simplex(vverts,vadj,true)
simplices.push(ncell)
var opposite=na.indexOf(cell)
if(opposite<0){continue}
na[opposite]=ncell
vadj[indexOfN]=neighbor
vverts[i]=-1
vadj[i]=cell
cellAdj[i]=ncell
ncell.flip()
for(var j=0;j<=d;++j){var uu=vverts[j]
if(uu<0||uu===n){continue}
var nface=new Array(d-1)
var nptr=0
for(var k=0;k<=d;++k){var vv=vverts[k]
if(vv<0||k===j){continue}
nface[nptr++]=vv}
glueFacets.push(new GlueFacet(nface,ncell,j))}}}
glueFacets.sort(compareGlue)
for(var i=0;i+1<glueFacets.length;i+=2){var a=glueFacets[i]
var b=glueFacets[i+1]
var ai=a.index
var bi=b.index
if(ai<0||bi<0){continue}
a.cell.adjacent[a.index]=b.cell
b.cell.adjacent[b.index]=a.cell}}
proto.insert=function(point,random){var verts=this.vertices
verts.push(point)
var cell=this.walk(point,random)
if(!cell){return}
var d=this.dimension
var tuple=this.tuple
for(var i=0;i<=d;++i){var vv=cell.vertices[i]
if(vv<0){tuple[i]=point}else{tuple[i]=verts[vv]}}
var o=this.orient(tuple)
if(o<0){return}else if(o===0){cell=this.handleBoundaryDegeneracy(cell,point)
if(!cell){return}}
this.addPeaks(point,cell)}
proto.boundary=function(){var d=this.dimension
var boundary=[]
var cells=this.simplices
var nc=cells.length
for(var i=0;i<nc;++i){var c=cells[i]
if(c.boundary){var bcell=new Array(d)
var cv=c.vertices
var ptr=0
var parity=0
for(var j=0;j<=d;++j){if(cv[j]>=0){bcell[ptr++]=cv[j]}else{parity=j&1}}
if(parity===(d&1)){var t=bcell[0]
bcell[0]=bcell[1]
bcell[1]=t}
boundary.push(bcell)}}
return boundary}
function incrementalConvexHull(points,randomSearch){var n=points.length
if(n===0){throw new Error("Must have at least d+1 points")}
var d=points[0].length
if(n<=d){throw new Error("Must input at least d+1 points")}
var initialSimplex=points.slice(0,d+1)
var o=orient.apply(void 0,initialSimplex)
if(o===0){throw new Error("Input not in general position")}
var initialCoords=new Array(d+1)
for(var i=0;i<=d;++i){initialCoords[i]=i}
if(o<0){initialCoords[0]=1
initialCoords[1]=0}
var initialCell=new Simplex(initialCoords,new Array(d+1),false)
var boundary=initialCell.adjacent
var list=new Array(d+2)
for(var i=0;i<=d;++i){var verts=initialCoords.slice()
for(var j=0;j<=d;++j){if(j===i){verts[j]=-1}}
var t=verts[0]
verts[0]=verts[1]
verts[1]=t
var cell=new Simplex(verts,new Array(d+1),true)
boundary[i]=cell
list[i]=cell}
list[d+1]=initialCell
for(var i=0;i<=d;++i){var verts=boundary[i].vertices
var adj=boundary[i].adjacent
for(var j=0;j<=d;++j){var v=verts[j]
if(v<0){adj[j]=initialCell
continue}
for(var k=0;k<=d;++k){if(boundary[k].vertices.indexOf(v)<0){adj[j]=boundary[k]}}}}
var triangles=new Triangulation(d,initialSimplex,list)
var useRandom=!!randomSearch
for(var i=d+1;i<n;++i){triangles.insert(points[i],useRandom)}
return triangles.boundary()}},{"robust-orientation":7,"simplicial-complex":10}],2:[function(require,module,exports){"use strict"
module.exports=fastTwoSum
function fastTwoSum(a,b,result){var x=a+b
var bv=x-a
var av=x-bv
var br=b-bv
var ar=a-av
if(result){result[0]=ar+br
result[1]=x
return result}
return[ar+br,x]}},{}],3:[function(require,module,exports){"use strict"
var twoProduct=require("two-product")
var twoSum=require("two-sum")
module.exports=scaleLinearExpansion
function scaleLinearExpansion(e,scale){var n=e.length
if(n===1){var ts=twoProduct(e[0],scale)
if(ts[0]){return ts}
return[ts[1]]}
var g=new Array(2*n)
var q=[0.1,0.1]
var t=[0.1,0.1]
var count=0
twoProduct(e[0],scale,q)
if(q[0]){g[count++]=q[0]}
for(var i=1;i<n;++i){twoProduct(e[i],scale,t)
var pq=q[1]
twoSum(pq,t[0],q)
if(q[0]){g[count++]=q[0]}
var a=t[1]
var b=q[1]
var x=a+b
var bv=x-a
var y=b-bv
q[1]=x
if(y){g[count++]=y}}
if(q[1]){g[count++]=q[1]}
if(count===0){g[count++]=0.0}
g.length=count
return g}},{"two-product":6,"two-sum":2}],4:[function(require,module,exports){"use strict"
module.exports=robustSubtract
function scalarScalar(a,b){var x=a+b
var bv=x-a
var av=x-bv
var br=b-bv
var ar=a-av
var y=ar+br
if(y){return[y,x]}
return[x]}
function robustSubtract(e,f){var ne=e.length|0
var nf=f.length|0
if(ne===1&&nf===1){return scalarScalar(e[0],-f[0])}
var n=ne+nf
var g=new Array(n)
var count=0
var eptr=0
var fptr=0
var abs=Math.abs
var ei=e[eptr]
var ea=abs(ei)
var fi=-f[fptr]
var fa=abs(fi)
var a,b
if(ea<fa){b=ei
eptr+=1
if(eptr<ne){ei=e[eptr]
ea=abs(ei)}}else{b=fi
fptr+=1
if(fptr<nf){fi=-f[fptr]
fa=abs(fi)}}
if((eptr<ne&&ea<fa)||(fptr>=nf)){a=ei
eptr+=1
if(eptr<ne){ei=e[eptr]
ea=abs(ei)}}else{a=fi
fptr+=1
if(fptr<nf){fi=-f[fptr]
fa=abs(fi)}}
var x=a+b
var bv=x-a
var y=b-bv
var q0=y
var q1=x
var _x,_bv,_av,_br,_ar
while(eptr<ne&&fptr<nf){if(ea<fa){a=ei
eptr+=1
if(eptr<ne){ei=e[eptr]
ea=abs(ei)}}else{a=fi
fptr+=1
if(fptr<nf){fi=-f[fptr]
fa=abs(fi)}}
b=q0
x=a+b
bv=x-a
y=b-bv
if(y){g[count++]=y}
_x=q1+x
_bv=_x-q1
_av=_x-_bv
_br=x-_bv
_ar=q1-_av
q0=_ar+_br
q1=_x}
while(eptr<ne){a=ei
b=q0
x=a+b
bv=x-a
y=b-bv
if(y){g[count++]=y}
_x=q1+x
_bv=_x-q1
_av=_x-_bv
_br=x-_bv
_ar=q1-_av
q0=_ar+_br
q1=_x
eptr+=1
if(eptr<ne){ei=e[eptr]}}
while(fptr<nf){a=fi
b=q0
x=a+b
bv=x-a
y=b-bv
if(y){g[count++]=y}
_x=q1+x
_bv=_x-q1
_av=_x-_bv
_br=x-_bv
_ar=q1-_av
q0=_ar+_br
q1=_x
fptr+=1
if(fptr<nf){fi=-f[fptr]}}
if(q0){g[count++]=q0}
if(q1){g[count++]=q1}
if(!count){g[count++]=0.0}
g.length=count
return g}},{}],5:[function(require,module,exports){"use strict"
module.exports=linearExpansionSum
function scalarScalar(a,b){var x=a+b
var bv=x-a
var av=x-bv
var br=b-bv
var ar=a-av
var y=ar+br
if(y){return[y,x]}
return[x]}
function linearExpansionSum(e,f){var ne=e.length|0
var nf=f.length|0
if(ne===1&&nf===1){return scalarScalar(e[0],f[0])}
var n=ne+nf
var g=new Array(n)
var count=0
var eptr=0
var fptr=0
var abs=Math.abs
var ei=e[eptr]
var ea=abs(ei)
var fi=f[fptr]
var fa=abs(fi)
var a,b
if(ea<fa){b=ei
eptr+=1
if(eptr<ne){ei=e[eptr]
ea=abs(ei)}}else{b=fi
fptr+=1
if(fptr<nf){fi=f[fptr]
fa=abs(fi)}}
if((eptr<ne&&ea<fa)||(fptr>=nf)){a=ei
eptr+=1
if(eptr<ne){ei=e[eptr]
ea=abs(ei)}}else{a=fi
fptr+=1
if(fptr<nf){fi=f[fptr]
fa=abs(fi)}}
var x=a+b
var bv=x-a
var y=b-bv
var q0=y
var q1=x
var _x,_bv,_av,_br,_ar
while(eptr<ne&&fptr<nf){if(ea<fa){a=ei
eptr+=1
if(eptr<ne){ei=e[eptr]
ea=abs(ei)}}else{a=fi
fptr+=1
if(fptr<nf){fi=f[fptr]
fa=abs(fi)}}
b=q0
x=a+b
bv=x-a
y=b-bv
if(y){g[count++]=y}
_x=q1+x
_bv=_x-q1
_av=_x-_bv
_br=x-_bv
_ar=q1-_av
q0=_ar+_br
q1=_x}
while(eptr<ne){a=ei
b=q0
x=a+b
bv=x-a
y=b-bv
if(y){g[count++]=y}
_x=q1+x
_bv=_x-q1
_av=_x-_bv
_br=x-_bv
_ar=q1-_av
q0=_ar+_br
q1=_x
eptr+=1
if(eptr<ne){ei=e[eptr]}}
while(fptr<nf){a=fi
b=q0
x=a+b
bv=x-a
y=b-bv
if(y){g[count++]=y}
_x=q1+x
_bv=_x-q1
_av=_x-_bv
_br=x-_bv
_ar=q1-_av
q0=_ar+_br
q1=_x
fptr+=1
if(fptr<nf){fi=f[fptr]}}
if(q0){g[count++]=q0}
if(q1){g[count++]=q1}
if(!count){g[count++]=0.0}
g.length=count
return g}},{}],6:[function(require,module,exports){"use strict"
module.exports=twoProduct
var SPLITTER=+(Math.pow(2,27)+1.0)
function twoProduct(a,b,result){var x=a*b
var c=SPLITTER*a
var abig=c-a
var ahi=c-abig
var alo=a-ahi
var d=SPLITTER*b
var bbig=d-b
var bhi=d-bbig
var blo=b-bhi
var err1=x-(ahi*bhi)
var err2=err1-(alo*bhi)
var err3=err2-(ahi*blo)
var y=alo*blo-err3
if(result){result[0]=y
result[1]=x
return result}
return[y,x]}},{}],7:[function(require,module,exports){"use strict"
var twoProduct=require("two-product")
var robustSum=require("robust-sum")
var robustScale=require("robust-scale")
var robustSubtract=require("robust-subtract")
var NUM_EXPAND=5
var EPSILON=1.1102230246251565e-16
var ERRBOUND3=(3.0+16.0*EPSILON)*EPSILON
var ERRBOUND4=(7.0+56.0*EPSILON)*EPSILON
function cofactor(m,c){var result=new Array(m.length-1)
for(var i=1;i<m.length;++i){var r=result[i-1]=new Array(m.length-1)
for(var j=0,k=0;j<m.length;++j){if(j===c){continue}
r[k++]=m[i][j]}}
return result}
function matrix(n){var result=new Array(n)
for(var i=0;i<n;++i){result[i]=new Array(n)
for(var j=0;j<n;++j){result[i][j]=["m",j,"[",(n-i-1),"]"].join("")}}
return result}
function sign(n){if(n&1){return "-"}
return ""}
function generateSum(expr){if(expr.length===1){return expr[0]}else if(expr.length===2){return["sum(",expr[0],",",expr[1],")"].join("")}else{var m=expr.length>>1
return["sum(",generateSum(expr.slice(0,m)),",",generateSum(expr.slice(m)),")"].join("")}}
function determinant(m){if(m.length===2){return[["sum(prod(",m[0][0],",",m[1][1],"),prod(-",m[0][1],",",m[1][0],"))"].join("")]}else{var expr=[]
for(var i=0;i<m.length;++i){expr.push(["scale(",generateSum(determinant(cofactor(m,i))),",",sign(i),m[0][i],")"].join(""))}
return expr}}
function orientation(n){var pos=[]
var neg=[]
var m=matrix(n)
var args=[]
for(var i=0;i<n;++i){if((i&1)===0){pos.push.apply(pos,determinant(cofactor(m,i)))}else{neg.push.apply(neg,determinant(cofactor(m,i)))}
args.push("m"+i)}
var posExpr=generateSum(pos)
var negExpr=generateSum(neg)
var funcName="orientation"+n+"Exact"
var code=["function ",funcName,"(",args.join(),"){var p=",posExpr,",n=",negExpr,",d=sub(p,n);\
return d[d.length-1];};return ",funcName].join("")
var proc=new Function("sum","prod","scale","sub",code)
return proc(robustSum,twoProduct,robustScale,robustSubtract)}
var orientation3Exact=orientation(3)
var orientation4Exact=orientation(4)
var CACHED=[function orientation0(){return 0},function orientation1(){return 0},function orientation2(a,b){return b[0]-a[0]},function orientation3(a,b,c){var l=(a[1]-c[1])*(b[0]-c[0])
var r=(a[0]-c[0])*(b[1]-c[1])
var det=l-r
var s
if(l>0){if(r<=0){return det}else{s=l+r}}else if(l<0){if(r>=0){return det}else{s=-(l+r)}}else{return det}
var tol=ERRBOUND3*s
if(det>=tol||det<=-tol){return det}
return orientation3Exact(a,b,c)},function orientation4(a,b,c,d){var adx=a[0]-d[0]
var bdx=b[0]-d[0]
var cdx=c[0]-d[0]
var ady=a[1]-d[1]
var bdy=b[1]-d[1]
var cdy=c[1]-d[1]
var adz=a[2]-d[2]
var bdz=b[2]-d[2]
var cdz=c[2]-d[2]
var bdxcdy=bdx*cdy
var cdxbdy=cdx*bdy
var cdxady=cdx*ady
var adxcdy=adx*cdy
var adxbdy=adx*bdy
var bdxady=bdx*ady
var det=adz*(bdxcdy-cdxbdy)
+bdz*(cdxady-adxcdy)
+cdz*(adxbdy-bdxady)
var permanent=(Math.abs(bdxcdy)+Math.abs(cdxbdy))*Math.abs(adz)
+(Math.abs(cdxady)+Math.abs(adxcdy))*Math.abs(bdz)
+(Math.abs(adxbdy)+Math.abs(bdxady))*Math.abs(cdz)
var tol=ERRBOUND4*permanent
if((det>tol)||(-det>tol)){return det}
return orientation4Exact(a,b,c,d)}]
function slowOrient(args){var proc=CACHED[args.length]
if(!proc){proc=CACHED[args.length]=orientation(args.length)}
return proc.apply(undefined,args)}
function generateOrientationProc(){while(CACHED.length<=NUM_EXPAND){CACHED.push(orientation(CACHED.length))}
var args=[]
var procArgs=["slow"]
for(var i=0;i<=NUM_EXPAND;++i){args.push("a"+i)
procArgs.push("o"+i)}
var code=["function getOrientation(",args.join(),"){switch(arguments.length){case 0:case 1:return 0;"]
for(var i=2;i<=NUM_EXPAND;++i){code.push("case ",i,":return o",i,"(",args.slice(0,i).join(),");")}
code.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation")
procArgs.push(code.join(""))
var proc=Function.apply(undefined,procArgs)
module.exports=proc.apply(undefined,[slowOrient].concat(CACHED))
for(var i=0;i<=NUM_EXPAND;++i){module.exports[i]=CACHED[i]}}
generateOrientationProc()},{"robust-scale":3,"robust-subtract":4,"robust-sum":5,"two-product":6}],8:[function(require,module,exports){"use strict";"use restrict";var INT_BITS=32;exports.INT_BITS=INT_BITS;exports.INT_MAX=0x7fffffff;exports.INT_MIN=-1<<(INT_BITS-1);exports.sign=function(v){return(v>0)-(v<0);}
exports.abs=function(v){var mask=v>>(INT_BITS-1);return(v^mask)-mask;}
exports.min=function(x,y){return y^((x^y)&-(x<y));}
exports.max=function(x,y){return x^((x^y)&-(x<y));}
exports.isPow2=function(v){return!(v&(v-1))&&(!!v);}
exports.log2=function(v){var r,shift;r=(v>0xFFFF)<<4;v>>>=r;shift=(v>0xFF)<<3;v>>>=shift;r|=shift;shift=(v>0xF)<<2;v>>>=shift;r|=shift;shift=(v>0x3)<<1;v>>>=shift;r|=shift;return r|(v>>1);}
exports.log10=function(v){return(v>=1000000000)?9:(v>=100000000)?8:(v>=10000000)?7:(v>=1000000)?6:(v>=100000)?5:(v>=10000)?4:(v>=1000)?3:(v>=100)?2:(v>=10)?1:0;}
exports.popCount=function(v){v=v-((v>>>1)&0x55555555);v=(v&0x33333333)+((v>>>2)&0x33333333);return((v+(v>>>4)&0xF0F0F0F)*0x1010101)>>>24;}
function countTrailingZeros(v){var c=32;v&=-v;if(v)c--;if(v&0x0000FFFF)c-=16;if(v&0x00FF00FF)c-=8;if(v&0x0F0F0F0F)c-=4;if(v&0x33333333)c-=2;if(v&0x55555555)c-=1;return c;}
exports.countTrailingZeros=countTrailingZeros;exports.nextPow2=function(v){v+=v===0;--v;v|=v>>>1;v|=v>>>2;v|=v>>>4;v|=v>>>8;v|=v>>>16;return v+1;}
exports.prevPow2=function(v){v|=v>>>1;v|=v>>>2;v|=v>>>4;v|=v>>>8;v|=v>>>16;return v-(v>>>1);}
exports.parity=function(v){v^=v>>>16;v^=v>>>8;v^=v>>>4;v&=0xf;return(0x6996>>>v)&1;}
var REVERSE_TABLE=new Array(256);(function(tab){for(var i=0;i<256;++i){var v=i,r=i,s=7;for(v>>>=1;v;v>>>=1){r<<=1;r|=v&1;--s;}
tab[i]=(r<<s)&0xff;}})(REVERSE_TABLE);exports.reverse=function(v){return(REVERSE_TABLE[v&0xff]<<24)|(REVERSE_TABLE[(v>>>8)&0xff]<<16)|(REVERSE_TABLE[(v>>>16)&0xff]<<8)|REVERSE_TABLE[(v>>>24)&0xff];}
exports.interleave2=function(x,y){x&=0xFFFF;x=(x|(x<<8))&0x00FF00FF;x=(x|(x<<4))&0x0F0F0F0F;x=(x|(x<<2))&0x33333333;x=(x|(x<<1))&0x55555555;y&=0xFFFF;y=(y|(y<<8))&0x00FF00FF;y=(y|(y<<4))&0x0F0F0F0F;y=(y|(y<<2))&0x33333333;y=(y|(y<<1))&0x55555555;return x|(y<<1);}
exports.deinterleave2=function(v,n){v=(v>>>n)&0x55555555;v=(v|(v>>>1))&0x33333333;v=(v|(v>>>2))&0x0F0F0F0F;v=(v|(v>>>4))&0x00FF00FF;v=(v|(v>>>16))&0x000FFFF;return(v<<16)>>16;}
exports.interleave3=function(x,y,z){x&=0x3FF;x=(x|(x<<16))&4278190335;x=(x|(x<<8))&251719695;x=(x|(x<<4))&3272356035;x=(x|(x<<2))&1227133513;y&=0x3FF;y=(y|(y<<16))&4278190335;y=(y|(y<<8))&251719695;y=(y|(y<<4))&3272356035;y=(y|(y<<2))&1227133513;x|=(y<<1);z&=0x3FF;z=(z|(z<<16))&4278190335;z=(z|(z<<8))&251719695;z=(z|(z<<4))&3272356035;z=(z|(z<<2))&1227133513;return x|(z<<2);}
exports.deinterleave3=function(v,n){v=(v>>>n)&1227133513;v=(v|(v>>>2))&3272356035;v=(v|(v>>>4))&251719695;v=(v|(v>>>8))&4278190335;v=(v|(v>>>16))&0x3FF;return(v<<22)>>22;}
exports.nextCombination=function(v){var t=v|(v-1);return(t+1)|(((~t&-~t)-1)>>>(countTrailingZeros(v)+1));}},{}],9:[function(require,module,exports){"use strict";"use restrict";module.exports=UnionFind;function UnionFind(count){this.roots=new Array(count);this.ranks=new Array(count);for(var i=0;i<count;++i){this.roots[i]=i;this.ranks[i]=0;}}
var proto=UnionFind.prototype
Object.defineProperty(proto,"length",{"get":function(){return this.roots.length}})
proto.makeSet=function(){var n=this.roots.length;this.roots.push(n);this.ranks.push(0);return n;}
proto.find=function(x){var x0=x
var roots=this.roots;while(roots[x]!==x){x=roots[x]}
while(roots[x0]!==x){var y=roots[x0]
roots[x0]=x
x0=y}
return x;}
proto.link=function(x,y){var xr=this.find(x),yr=this.find(y);if(xr===yr){return;}
var ranks=this.ranks,roots=this.roots,xd=ranks[xr],yd=ranks[yr];if(xd<yd){roots[xr]=yr;}else if(yd<xd){roots[yr]=xr;}else{roots[yr]=xr;++ranks[xr];}}},{}],10:[function(require,module,exports){"use strict";"use restrict";var bits=require("bit-twiddle"),UnionFind=require("union-find")
function dimension(cells){var d=0,max=Math.max
for(var i=0,il=cells.length;i<il;++i){d=max(d,cells[i].length)}
return d-1}
exports.dimension=dimension
function countVertices(cells){var vc=-1,max=Math.max
for(var i=0,il=cells.length;i<il;++i){var c=cells[i]
for(var j=0,jl=c.length;j<jl;++j){vc=max(vc,c[j])}}
return vc+1}
exports.countVertices=countVertices
function cloneCells(cells){var ncells=new Array(cells.length)
for(var i=0,il=cells.length;i<il;++i){ncells[i]=cells[i].slice(0)}
return ncells}
exports.cloneCells=cloneCells
function compareCells(a,b){var n=a.length,t=a.length-b.length,min=Math.min
if(t){return t}
switch(n){case 0:return 0;case 1:return a[0]-b[0];case 2:var d=a[0]+a[1]-b[0]-b[1]
if(d){return d}
return min(a[0],a[1])-min(b[0],b[1])
case 3:var l1=a[0]+a[1],m1=b[0]+b[1]
d=l1+a[2]-(m1+b[2])
if(d){return d}
var l0=min(a[0],a[1]),m0=min(b[0],b[1]),d=min(l0,a[2])-min(m0,b[2])
if(d){return d}
return min(l0+a[2],l1)-min(m0+b[2],m1)
default:var as=a.slice(0)
as.sort()
var bs=b.slice(0)
bs.sort()
for(var i=0;i<n;++i){t=as[i]-bs[i]
if(t){return t}}
return 0}}
exports.compareCells=compareCells
function compareZipped(a,b){return compareCells(a[0],b[0])}
function normalize(cells,attr){if(attr){var len=cells.length
var zipped=new Array(len)
for(var i=0;i<len;++i){zipped[i]=[cells[i],attr[i]]}
zipped.sort(compareZipped)
for(var i=0;i<len;++i){cells[i]=zipped[i][0]
attr[i]=zipped[i][1]}
return cells}else{cells.sort(compareCells)
return cells}}
exports.normalize=normalize
function unique(cells){if(cells.length===0){return[]}
var ptr=1,len=cells.length
for(var i=1;i<len;++i){var a=cells[i]
if(compareCells(a,cells[i-1])){if(i===ptr){ptr++
continue}
cells[ptr++]=a}}
cells.length=ptr
return cells}
exports.unique=unique;function findCell(cells,c){var lo=0,hi=cells.length-1,r=-1
while(lo<=hi){var mid=(lo+hi)>>1,s=compareCells(cells[mid],c)
if(s<=0){if(s===0){r=mid}
lo=mid+1}else if(s>0){hi=mid-1}}
return r}
exports.findCell=findCell;function incidence(from_cells,to_cells){var index=new Array(from_cells.length)
for(var i=0,il=index.length;i<il;++i){index[i]=[]}
var b=[]
for(var i=0,n=to_cells.length;i<n;++i){var c=to_cells[i]
var cl=c.length
for(var k=1,kn=(1<<cl);k<kn;++k){b.length=bits.popCount(k)
var l=0
for(var j=0;j<cl;++j){if(k&(1<<j)){b[l++]=c[j]}}
var idx=findCell(from_cells,b)
if(idx<0){continue}
while(true){index[idx++].push(i)
if(idx>=from_cells.length||compareCells(from_cells[idx],b)!==0){break}}}}
return index}
exports.incidence=incidence
function dual(cells,vertex_count){if(!vertex_count){return incidence(unique(skeleton(cells,0)),cells,0)}
var res=new Array(vertex_count)
for(var i=0;i<vertex_count;++i){res[i]=[]}
for(var i=0,len=cells.length;i<len;++i){var c=cells[i]
for(var j=0,cl=c.length;j<cl;++j){res[c[j]].push(i)}}
return res}
exports.dual=dual
function explode(cells){var result=[]
for(var i=0,il=cells.length;i<il;++i){var c=cells[i],cl=c.length|0
for(var j=1,jl=(1<<cl);j<jl;++j){var b=[]
for(var k=0;k<cl;++k){if((j>>>k)&1){b.push(c[k])}}
result.push(b)}}
return normalize(result)}
exports.explode=explode
function skeleton(cells,n){if(n<0){return[]}
var result=[],k0=(1<<(n+1))-1
for(var i=0;i<cells.length;++i){var c=cells[i]
for(var k=k0;k<(1<<c.length);k=bits.nextCombination(k)){var b=new Array(n+1),l=0
for(var j=0;j<c.length;++j){if(k&(1<<j)){b[l++]=c[j]}}
result.push(b)}}
return normalize(result)}
exports.skeleton=skeleton;function boundary(cells){var res=[]
for(var i=0,il=cells.length;i<il;++i){var c=cells[i]
for(var j=0,cl=c.length;j<cl;++j){var b=new Array(c.length-1)
for(var k=0,l=0;k<cl;++k){if(k!==j){b[l++]=c[k]}}
res.push(b)}}
return normalize(res)}
exports.boundary=boundary;function connectedComponents_dense(cells,vertex_count){var labels=new UnionFind(vertex_count)
for(var i=0;i<cells.length;++i){var c=cells[i]
for(var j=0;j<c.length;++j){for(var k=j+1;k<c.length;++k){labels.link(c[j],c[k])}}}
var components=[],component_labels=labels.ranks
for(var i=0;i<component_labels.length;++i){component_labels[i]=-1}
for(var i=0;i<cells.length;++i){var l=labels.find(cells[i][0])
if(component_labels[l]<0){component_labels[l]=components.length
components.push([cells[i].slice(0)])}else{components[component_labels[l]].push(cells[i].slice(0))}}
return components}
function connectedComponents_sparse(cells){var vertices=unique(normalize(skeleton(cells,0))),labels=new UnionFind(vertices.length)
for(var i=0;i<cells.length;++i){var c=cells[i]
for(var j=0;j<c.length;++j){var vj=findCell(vertices,[c[j]])
for(var k=j+1;k<c.length;++k){labels.link(vj,findCell(vertices,[c[k]]))}}}
var components=[],component_labels=labels.ranks
for(var i=0;i<component_labels.length;++i){component_labels[i]=-1}
for(var i=0;i<cells.length;++i){var l=labels.find(findCell(vertices,[cells[i][0]]));if(component_labels[l]<0){component_labels[l]=components.length
components.push([cells[i].slice(0)])}else{components[component_labels[l]].push(cells[i].slice(0))}}
return components}
function connectedComponents(cells,vertex_count){if(vertex_count){return connectedComponents_dense(cells,vertex_count)}
return connectedComponents_sparse(cells)}
exports.connectedComponents=connectedComponents},{"bit-twiddle":8,"union-find":9}],11:[function(require,module,exports){"use strict"
function unique_pred(list,compare){var ptr=1,len=list.length,a=list[0],b=list[0]
for(var i=1;i<len;++i){b=a
a=list[i]
if(compare(a,b)){if(i===ptr){ptr++
continue}
list[ptr++]=a}}
list.length=ptr
return list}
function unique_eq(list){var ptr=1,len=list.length,a=list[0],b=list[0]
for(var i=1;i<len;++i,b=a){b=a
a=list[i]
if(a!==b){if(i===ptr){ptr++
continue}
list[ptr++]=a}}
list.length=ptr
return list}
function unique(list,compare,sorted){if(list.length===0){return list}
if(compare){if(!sorted){list.sort(compare)}
return unique_pred(list,compare)}
if(!sorted){list.sort()}
return unique_eq(list)}
module.exports=unique},{}],12:[function(require,module,exports){"use strict"
var ch=require("incremental-convex-hull")
var uniq=require("uniq")
module.exports=triangulate
function LiftedPoint(p,i){this.point=p
this.index=i}
function compareLifted(a,b){var ap=a.point
var bp=b.point
var d=ap.length
for(var i=0;i<d;++i){var s=bp[i]-ap[i]
if(s){return s}}
return 0}
function triangulate1D(n,points,includePointAtInfinity){if(n===1){if(includePointAtInfinity){return[[-1,0]]}else{return[]}}
var lifted=points.map(function(p,i){return[p[0],i]})
lifted.sort(function(a,b){return a[0]-b[0]})
var cells=new Array(n-1)
for(var i=1;i<n;++i){var a=lifted[i-1]
var b=lifted[i]
cells[i-1]=[a[1],b[1]]}
if(includePointAtInfinity){cells.push([-1,cells[0][1],],[cells[n-1][1],-1])}
return cells}
function triangulate(points,includePointAtInfinity){var n=points.length
if(n===0){return[]}
var d=points[0].length
if(d<1){return[]}
if(d===1){return triangulate1D(n,points,includePointAtInfinity)}
var lifted=new Array(n)
var upper=1.0
for(var i=0;i<n;++i){var p=points[i]
var x=new Array(d+1)
var l=0.0
for(var j=0;j<d;++j){var v=p[j]
x[j]=v
l+=v*v}
x[d]=l
lifted[i]=new LiftedPoint(x,i)
upper=Math.max(l,upper)}
uniq(lifted,compareLifted)
n=lifted.length
var dpoints=new Array(n+d+1)
var dindex=new Array(n+d+1)
var u=(d+1)*(d+1)*upper
var y=new Array(d+1)
for(var i=0;i<=d;++i){y[i]=0.0}
y[d]=u
dpoints[0]=y.slice()
dindex[0]=-1
for(var i=0;i<=d;++i){var x=y.slice()
x[i]=1
dpoints[i+1]=x
dindex[i+1]=-1}
for(var i=0;i<n;++i){var h=lifted[i]
dpoints[i+d+1]=h.point
dindex[i+d+1]=h.index}
var hull=ch(dpoints,false)
if(includePointAtInfinity){hull=hull.filter(function(cell){var count=0
for(var j=0;j<=d;++j){var v=dindex[cell[j]]
if(v<0){if(++count>=2){return false}}
cell[j]=v}
return true})}else{hull=hull.filter(function(cell){for(var i=0;i<=d;++i){var v=dindex[cell[i]]
if(v<0){return false}
cell[i]=v}
return true})}
if(d&1){for(var i=0;i<hull.length;++i){var h=hull[i]
var x=h[0]
h[0]=h[1]
h[1]=x}}
return hull}},{"incremental-convex-hull":1,"uniq":11}],13:[function(require,module,exports){var delaunay=require('delaunay-triangulate');module.exports={delaunay:delaunay}},{"delaunay-triangulate":12}]},{},[13])(13)});