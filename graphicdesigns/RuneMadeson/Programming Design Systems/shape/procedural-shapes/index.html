<!DOCTYPE html>
<html>
  <head>
    <title>
Procedural Shapes - Programming Design Systems
    </title>
    <meta charset="utf-8" />
    <meta
      name="description"
      content="Programming Design Systems is a free digital book that teaches a practical introduction to the new foundations of graphic design."
    />
    <script src="../../plugins/p5.js"></script>
    <meta name="author" content="Rune Madsen" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../../assets/bundle-f3f9d291f9.css">
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-4524292-24', 'auto');
  ga('send', 'pageview');

</script>
  </head>
  <body>
    <nav class="menu">
      <div class="wrapper">
        <a id="tocToggle" href="index.html#">
          <svg
            width="25px"
            height="16px"
            viewBox="0 0 25 16"
            version="1.1"
            xmlns="http://www.w3.org/2000/svg"
          >
            <line x1="0" y1="2" x2="18" y2="2" stroke="#29b79b" />
            <line x1="0" y1="8" x2="18" y2="8" stroke="#29b79b" />
            <line x1="0" y1="14" x2="18" y2="14" stroke="#29b79b" />
          </svg>
        </a>
        <a id="logo" href="../../index.html">Programming Design Systems</a>
        <a
          id="newsletter"
          target="_blank"
          href="https://confirmsubscription.com/h/t/2E81B263662AA1A0"
          >Subscribe to Newsletter</a
        >
      </div>
    </nav>
    <main>
      <aside id="tocContainer" style="display: none;"><nav data-type='toc' class="toc">
  <h2>Table of Contents</h2>
  <ul>
<li>
    <a data-toc="chapter" href="../../introduction/index.html#introduction-AlRYsdq">Introduction</a>
  </li>
<li>
    <a data-toc="chapter" href="../../what-is-a-design-system/index.html#what-is-a-design-system-OQAaTNQ">What is a design system?</a>
  </li>
<li>
    <h3 data-toc="part">Shape</h3>
    <ul>
<li>
    <a data-toc="chapter" href="../figure-and-ground/index.html#figure-and-ground-LxG6S7J">Figure and ground</a>
  </li>
<li>
    <a data-toc="chapter" href="../basic-shapes/index.html#basic-shapes-bOYdIDj">Basic shapes</a>
  </li>
<li>
    <a data-toc="chapter" href="../custom-shapes/index.html#custom-shapes-pANLh0l">Custom shapes</a>
  </li>
<li>
    <a data-toc="chapter" href="index.html#procedural-shapes-qYPzCLg">Procedural Shapes</a>
  </li>
  </ul>
</li>
<li>
    <h3 data-toc="part">Color</h3>
    <ul>
<li>
    <a data-toc="chapter" href="../../color/a-short-history-of-color-theory/index.html#a-short-history-of-color-theory-xZzRFOZ">A short history of color theory</a>
  </li>
<li>
    <a data-toc="chapter" href="../../color/color-models-and-color-spaces/index.html#color-models-and-color-spaces-JDQ1fRD">Color models and color spaces</a>
  </li>
<li>
    <a data-toc="chapter" href="../../color/perceptually-uniform-color-spaces/index.html#perceptually-uniform-color-spaces-e7zMSWy">Perceptually uniform color spaces</a>
  </li>
<li>
    <a data-toc="chapter" href="../../color/color-schemes/index.html#color-schemes-dV9Rf6L">Color schemes</a>
  </li>
  </ul>
</li>
<li>
    <h3 data-toc="part">Layout</h3>
    <ul>
<li>
    <a data-toc="chapter" href="../../layout/a-short-history-of-geometric-composition/index.html#a-short-history-of-geometric-composition-DvkJs3o">A short history of geometric composition</a>
  </li>
<li>
    <a data-toc="chapter" href="../../layout/geometric-composition/index.html#geometric-composition-Amy3I4K">Geometric composition</a>
  </li>
  </ul>
</li>
<li>
    <a data-toc="chapter" href="../../more-to-come/index.html#more-to-come-rK5kfnO">... more to come</a>
  </li>
  </ul>
</nav>
</aside>
      <article>
        <div class="maxContent"><section data-type="chapter" id="procedural-shapes-qYPzCLg">

<header>
  <span class="part-info color1">Shape</span>
  <h1>Procedural Shapes</h1>
</header>

  <p>The code for our custom shape examples has so far been rather tedious. We have manually created shapes by typing line after line of vertex function calls, and this strategy will not work for more complex shapes. Also, given the title of the book, this approach might seem a bit anti-climatic. Now that we understand the basics of <code>beginShape()</code>, let us have a first look at how to procedurally draw custom shapes using a for loop, and the <code>sin()</code> and <code>cos()</code> functions.</p>

  <section data-type="sect1" id="sine-and-cosine-5gyJCVp">

    <h1>Sine and Cosine</h1>

    <p>Over the years, I have seen many students struggle with Sine and Cosine. It is easy to understand why: These words seem rather scary and abstract, especially if you do not consider yourself good at math. However, this is both unfortunate and unnecessary. Unfortunate, because these two functions are a fundamental part of most programmatic designs, and a good understanding of them will allow you to solve many visual problems. Unnecessary, because they are not that hard to learn. Even if you do not understand everything presented in this chapter, you can get started by memorizing two almost identical lines of code.</p>

    <p>Sine and Cosine allow us to find any position on the outline of an ellipse. They do this by converting an angle into an <code>x</code> position (Cosine) or a <code>y</code> position (Sine) for a circle with a 1 pixel radius. These values can then be multiplied by the radius of your actual circle to scale them up. Although it is not strictly necessary to understand how these functions work internally, here is a way to visualize what is going on: Imagine a right sided triangle connecting the center of the circle to the point on the outline. The Sine function is a quick way to get the ratio between the left side (hypotenuse) and the right side (opposite) of that triangle. The Cosine function is likewise the ratio between the hypotenuse and the bottom side (adjacent) of the triangle.</p>

    <figure class="text-width">
      <svg width="100%" viewBox="0 0 600 500" style="background-color: #f1f1f1">
        <circle cx="300" cy="250" r="200" stroke="#333333" fill="none" stroke-dasharray="5, 5" stroke-weight="1"/>
        <circle cx="473" cy="150" r="12" fill="#333333" stroke="none"/>
        <circle cx="300" cy="250" r="5" fill="#333333" stroke="none"/>
        <line x1="300" y1="250" x2="473" y2="150" stroke="#333333"/>
        <line x1="300" y1="250" x2="473" y2="250" stroke="#333333"/>
        <line x1="473" y1="250" x2="473" y2="150" stroke="#333333"/>
        <g transform="translate(350,108)">
          <text>Given an angle on a</text>
          <text y="20">circle with 1px radius</text>
        </g>
        <text x="340" y="275">Cosine finds x</text>
        <text x="487" y="210">Sine finds y</text>
      </svg>
    </figure>

    <p>In P5, these functions are called <code>sin()</code> and <code>cos()</code>. As described above, they accept a single argument &#x2013; an angle in radians &#x2013; and return a value between <code>-1</code> and <code>1</code> representing the <code>x</code> or <code>y</code> position on a tiny circle. The two lines below demonstrate how to get these values and multiply them by the radius of your actual circle. Memorize these two lines, as they are very important.</p>

    <pre class="text-width"><code>const x = cos(RADIANS) * RADIUS;
const y = sin(RADIANS) * RADIUS;</code></pre>


    <p>To put this into context, here is an example where we use the same code to draw a small circle 330 degrees along the outline of a bigger circle.</p>

    <div class="grid">
      <div class="col-1-2">
<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>translate(width/2, height/2);

noFill();
const radius = width * 0.3;
ellipse(0, 0, radius*2, radius*2);

fill(30);
const x = cos(radians(330)) * radius;
const y = sin(radians(330)) * radius;
ellipse(x, y, 20, 20);
</code></pre></div></div></div></div>      </div>
      <div class="col-1-2">
<figure id="example46" class><div class="p5container"></div><script type="text/javascript">window.p5Examples = window.p5Examples || [];
window.p5Examples.push(["example46", function(p) {p.setup = function()
{
  p.createCanvas(600, 500);
  p.background(240);

  p.translate(p.width/2, p.height/2);

  p.noFill();
  const radius = p.width * 0.3;
  p.ellipse(0, 0, radius*2, radius*2);

  p.fill(30);
  const x = p.cos(p.radians(330)) * radius;
  const y = p.sin(p.radians(330)) * radius;
  p.ellipse(x, y, 20, 20);

  p.noLoop();
}
}])</script></figure>      </div>
    </div>

    <p>If you consider all the basic shapes &#x2013; as well as many complex shapes &#x2013; they are characterized by having non-overlapping outlines that move around a center point. Some shapes, like the triangle, have just a few vertices, while others &#x2013; like the ellipse &#x2013; have many vertices. The <code>sin()</code> and <code>cos()</code> functions give a way to procedurally draw these types of shapes.</p>

  </section>

  <section data-type="sect1" id="for-loop">

    <h1>The For Loop</h1>

    <p>Although we will dedicate an entire part of this book to repetition, let us briefly go over the basic functionality of a <code>for</code> loop. A <code>for</code> loop allows us to execute code multiple times in a row by incrementing (or decrementing) a variable &#x2013; often called <code>i</code> &#x2013; until an expression is no longer true and the loop stops. In the following example, we initialize a variable with the number <code>0</code>, iterate as long as our variable is lower than <code>10</code>, and increment our variable by one between each iteration. The result is a loop that iterates ten times with our variable incrementing from zero to nine, drawing ten rectangles on the screen.</p>

    <div class="grid">
      <div class="col-1-2">
<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>for(let i = 0; i &lt; 10; i++) {
  rect(0, 0, 100, 100);
}
</code></pre></div></div></div></div>      </div>
      <div class="col-1-2">
<figure id="example47" class><div class="p5container"></div><script type="text/javascript">window.p5Examples = window.p5Examples || [];
window.p5Examples.push(["example47", function(p) {p.setup = function()
{
  p.createCanvas(600, 300);
  p.background(240);
  p.fill(30);
  p.noStroke();

  for(let i = 0; i < 10; i++) {
    p.rect(0, 0, 100, 100);
  }

  p.noLoop();
}
}])</script></figure>      </div>
    </div>

    <p>Unfortunately, all these rectangles have identical positions and sizes because we are passing the same static numbers to the <code>rect()</code> function over and over again. This is where <code>i</code> comes into play: Because it changes between each iteration of the loop, it can be used to create variance between each rectangle. The example below uses <code>i</code> to position the ten rectangles one pixel apart on the x-axis.</p>

    <div class="grid">
      <div class="col-1-2">
<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>for(let i = 0; i &lt; 10; i++) {
  rect(i, 0, 100, 100);
}
</code></pre></div></div></div></div>      </div>
      <div class="col-1-2">
<figure id="example48" class><div class="p5container"></div><script type="text/javascript">window.p5Examples = window.p5Examples || [];
window.p5Examples.push(["example48", function(p) {p.setup = function()
{
  p.createCanvas(600, 300);
  p.background(240);
  p.fill(30);
  p.noStroke();

  for(let i = 0; i < 10; i++) {
    p.rect(i, 0, 100, 100);
  }

  p.noLoop();
}
}])</script></figure>      </div>
    </div>

    <p>Although it might not be immediately clear, this is an important technique when drawing procedural designs. Because <code>i</code> increments by one between each iteration, it can be used as a scalar to distribute shapes across the canvas. For example, if we want to position the rectangles next to each other, we can multiply <code>i</code> with a number greater than the width of the rectangles.</p>

    <div class="grid">
      <div class="col-1-2">
<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>for(let i = 0; i &lt; 10; i++) {
  rect(i * 105, 0, 100, 100);
}
</code></pre></div></div></div></div>      </div>
      <div class="col-1-2">
<figure id="example49" class><div class="p5container"></div><script type="text/javascript">window.p5Examples = window.p5Examples || [];
window.p5Examples.push(["example49", function(p) {p.setup = function()
{
  p.createCanvas(600, 300);
  p.background(240);
  p.fill(30);
  p.noStroke();

  for(let i = 0; i < 10; i++) {
    p.rect(i * 105, 0, 100, 100);
  }

  p.noLoop();
}
}])</script></figure>      </div>
    </div>

    <p>We can use this same technique to draw custom shapes. Instead of drawing individual shapes in the loop, we use the for loop to procedurally add vertices between the <code>beginShape()</code> and <code>endShape()</code> function calls. In the example below, we use this technique to draw ten random vertices in the center of the canvas.</p>

    <div class="grid">
      <div class="col-1-2">
<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>translate(width/2, height/2);
beginShape();
for(let i = 0; i &lt; 10; i++) {
  const x = random(-100, 100);
  const y = random(-100, 100);
  vertex(x, y);
}
endShape();
</code></pre></div></div></div></div>      </div>
      <div class="col-1-2">
<figure id="example50" class><div class="p5container"></div><script type="text/javascript">window.p5Examples = window.p5Examples || [];
window.p5Examples.push(["example50", function(p) {p.setup = function()
{
  p.createCanvas(600, 300);
  p.background(240);
  p.noStroke();
  p.fill(30);

  p.translate(p.width/2, p.height/2);
  p.beginShape();
  for(let i = 0; i < 10; i++) {
    const x = p.random(-100, 100);
    const y = p.random(-100, 100);
    p.vertex(x, y);
  }
  p.endShape();

  p.noLoop();
}
}])</script></figure>      </div>
    </div>

    <p>The result is certainly a procedural shape, but the use of <code>random()</code> does not give us a lot of control over the placement of the vertices: The shape is just a bunch of lines randomly crossing each other. The final step is to put our two techniques together and generate shapes with <code>sin()</code> and <code>cos()</code> inside of a <code>for</code> loop.</p>

  </section>

  <section data-type="sect1" id="putting-it-together-nYbbC3Y">

    <h1>Putting it together</h1>

    <p>Starting from our random shape code above, let us replace the random vertices with vertices placed sequentially along the outline of an ellipse. We do this by using the same two lines that we memorized earlier, but instead of passing the same angle to <code>sin()</code> and <code>cos()</code>, we calculate a different angle on every iteration by multiplying <code>i</code> with the angle we want between the vertices. The result is a shape with ten vertices evenly spread around the center of the canvas.</p>

    <div class="grid">
      <div class="col-1-2">
<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>translate(width/2, height/2);
beginShape();
for(let i = 0; i &lt; 10; i++) {
  const x = cos(radians(i * 36)) * 100;
  const y = sin(radians(i * 36)) * 100;
  vertex(x, y);
}
endShape();
</code></pre></div></div></div></div>      </div>
      <div class="col-1-2">
<figure id="example51" class><div class="p5container"></div><script type="text/javascript">window.p5Examples = window.p5Examples || [];
window.p5Examples.push(["example51", function(p) {p.setup = function()
{
  p.createCanvas(600, 300);
  p.background(240);
  p.noStroke();
  p.fill(30);

  p.translate(p.width/2, p.height/2);
  p.beginShape();
  for(let i = 0; i < 10; i++) {
    const x = p.cos(p.radians(i * 36)) * 100;
    const y = p.sin(p.radians(i * 36)) * 100;
    p.vertex(x, y);
  }
  p.endShape();

  p.noLoop();
}
}])</script></figure>      </div>
    </div>

    <p>By changing the number of iterations and the spacing between the vertices, you can draw all of the basic shapes. The code below adds a few variables on top of the sketch to automatically calculate the spacing based on the number of vertices. Change the <code>numVertices</code> variable and another shape will appear.</p>

    <div class="grid">
      <div class="col-1-2">
<div class="codesplit"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>const numVertices = 3; // or 4 or 30
const spacing = 360 / numVertices;
translate(width/2, height/2);
beginShape();
for(let i = 0; i &lt;= numVertices; i++) {
  const x = cos(radians(i * spacing)) * 100;
  const y = sin(radians(i * spacing)) * 100;
  vertex(x, y);
}
endShape();
</code></pre></div></div></div></div>      </div>
      <div class="col-1-2">
<figure id="example52" class><div class="p5container"></div><script type="text/javascript">window.p5Examples = window.p5Examples || [];
window.p5Examples.push(["example52", function(p) {p.setup = function()
{
  p.createCanvas(600, 300);
  p.background(240);
  p.noStroke();
  p.fill(30);

  const numVertices = 3; // or 4 or 30
  const spacing = 360 / numVertices;
  p.translate(p.width/2, p.height/2);
  p.beginShape();
  for(let i = 0; i <= numVertices; i++) {
    const x = p.cos(p.radians(i * spacing)) * 100;
    const y = p.sin(p.radians(i * spacing)) * 100;
    p.vertex(x, y);
  }
  p.endShape();

  p.noLoop();
}
}])</script></figure>      </div>
    </div>

    <p>&#x2018;Great, we have reinvented the basic shape functions&#x2019; you might say. Actually, this technique allows us to draw much more sophisticated shapes. Let&apos;s run through a few examples that all use the same <code>sin()</code> and <code>cos()</code> formula to draw different types of shapes. We&apos;ll start with the squiggly circle below that has a random radius for each vertex, making it look like it was drawn by hand.</p>

<figure id="example53" class="text-width"><div class="p5container"></div><script type="text/javascript">window.p5Examples = window.p5Examples || [];
window.p5Examples.push(["example53", function(p) {p.setup = function()
{
  p.createCanvas(600, 400);
  p.background(240);
  p.noStroke();
  p.fill(30);

  p.translate(p.width/2, p.height/2);

  p.beginShape();
  for(let i = 0; i < 100; i++) {
    // Change the radius for every vertex {!1}
    const radius = 100 + p.random(5);
    const x = p.cos(p.radians(i * 3.6)) * radius;
    const y = p.sin(p.radians(i * 3.6)) * radius;
    p.vertex(x, y);
  }
  p.endShape();

  p.noLoop();
}
}])</script></figure>    <div class="codesplit columns"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>translate(width/2, height/2);

beginShape();
for(let i = 0; i &lt; 100; i++) {
</code></pre></div></div><div class="pair"><div class="comment"><p>Change the radius for every vertex</p></div><div class="code">

<pre><code>  const radius = 100 + random(5);
</code></pre></div></div><div class="pair no-comment"><div class="code">

<pre><code>  const x = cos(radians(i * 3.6)) * radius;
  const y = sin(radians(i * 3.6)) * radius;
  vertex(x, y);
}
endShape();
</code></pre></div></div></div></div>
    <p>The star below is created by alternating between a low and a high radius for each vertex. It&apos;s easy to tweak the style of the star by using different numbers or more vertices, or using <code>rotate()</code> to change the orientation of the star.</p>

<figure id="example54" class="text-width"><div class="p5container"></div><script type="text/javascript">window.p5Examples = window.p5Examples || [];
window.p5Examples.push(["example54", function(p) {p.setup = function()
{
  p.createCanvas(600, 400);
  p.background(240);
  p.noStroke();
  p.fill(30);

  p.translate(p.width/2, p.height/2);

  // Set the initial radius to 100 {!1}
  let radius = 100;

  p.beginShape();
  for(let i = 0; i < 10; i++) {

    // Use the radius in the cos/sin formula {!2}
    const x = p.cos(p.radians(i * 36)) * radius;
    const y = p.sin(p.radians(i * 36)) * radius;
    p.vertex(x, y);

    // Change the radius for the next vertex {!5}
    if(radius == 100) {
      radius = 50;
    } else {
      radius = 100;
    }
  }
  p.endShape();

  p.noLoop();
}
}])</script></figure>    <div class="codesplit columns"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>translate(width/2, height/2);

</code></pre></div></div><div class="pair"><div class="comment"><p>Set the initial radius to 100</p></div><div class="code">

<pre><code>let radius = 100;
</code></pre></div></div><div class="pair no-comment"><div class="code">

<pre><code>
beginShape();
for(let i = 0; i &lt; 10; i++) {

</code></pre></div></div><div class="pair"><div class="comment"><p>Use the radius in the cos/sin formula</p></div><div class="code">

<pre><code>  const x = cos(radians(i * 36)) * radius;
  const y = sin(radians(i * 36)) * radius;
</code></pre></div></div><div class="pair no-comment"><div class="code">

<pre><code>  vertex(x, y);

</code></pre></div></div><div class="pair"><div class="comment"><p>Change the radius for the next vertex</p></div><div class="code">

<pre><code>  if(radius == 100) {
    radius = 50;
  } else {
    radius = 100;
  }
</code></pre></div></div><div class="pair no-comment"><div class="code">

<pre><code>}
endShape();
</code></pre></div></div></div></div>
    <p>Here is a flower created with <code>quadraticVertex()</code> where all vertices and control points are positioned using <code>sin()</code> and <code>cos()</code>. By using a larger radius for the control points (the inverse of the star example above), the curves go outwards. When using B&#xE9;zier curves, remember to start the shape with a <code>vertex()</code> function call. We do this by checking the value of <code>i</code> within the loop.</p>

<figure id="example55" class="text-width"><div class="p5container"></div><script type="text/javascript">window.p5Examples = window.p5Examples || [];
window.p5Examples.push(["example55", function(p) {p.setup = function()
{
  p.createCanvas(600, 400);
  p.background(240);
  p.noStroke();
  p.fill(30);

  p.translate(p.width/2, p.height/2);

  // Automatically calculate the spacing {!2}
  const numVertices = 7;
  const spacing = 360 / numVertices;

  p.beginShape();
  // Loop one extra time to close shape with a curved line. {!1}
  for(let i = 0; i < numVertices+1; i++) {

    // Find the position for the vertex {!3}
    const angle = i * spacing;
    const x = p.cos(p.radians(angle)) * 100;
    const y = p.sin(p.radians(angle)) * 100;

    if(i == 0) {
      // If this is the first run of the loop, create simple vertex. {!1}
      p.vertex(x, y);
    }
    else {
      // Otherwise create a quadratic Bézier vertex with a control point halfway in
      // between the points and with a higher radius. {!4}
      const cAngle = angle - spacing/2;
      const cX = p.cos(p.radians(cAngle)) * 180;
      const cY = p.sin(p.radians(cAngle)) * 180;
      p.quadraticVertex(cX, cY, x, y)
    }
  }
  p.endShape();

  p.noLoop();
}
}])</script></figure>    <div class="codesplit columns"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>translate(width/2, height/2);

</code></pre></div></div><div class="pair"><div class="comment"><p>Automatically calculate the spacing</p></div><div class="code">

<pre><code>const numVertices = 7;
const spacing = 360 / numVertices;
</code></pre></div></div><div class="pair no-comment"><div class="code">

<pre><code>
beginShape();
</code></pre></div></div><div class="pair"><div class="comment"><p>Loop one extra time to close shape with a curved line.</p></div><div class="code">

<pre><code>for(let i = 0; i &lt; numVertices+1; i++) {
</code></pre></div></div><div class="pair no-comment"><div class="code">

<pre><code>
</code></pre></div></div><div class="pair"><div class="comment"><p>Find the position for the vertex</p></div><div class="code">

<pre><code>  const angle = i * spacing;
  const x = cos(radians(angle)) * 100;
  const y = sin(radians(angle)) * 100;
</code></pre></div></div><div class="pair no-comment"><div class="code">

<pre><code>
  if(i == 0) {
</code></pre></div></div><div class="pair"><div class="comment"><p>If this is the first run of the loop, create simple vertex.</p></div><div class="code">

<pre><code>    vertex(x, y);
</code></pre></div></div><div class="pair no-comment"><div class="code">

<pre><code>  }
  else {
</code></pre></div></div><div class="pair"><div class="comment"><p>Otherwise create a quadratic B&#xE9;zier vertex with a control point halfway in between the points and with a higher radius.</p></div><div class="code">

<pre><code>    const cAngle = angle - spacing/2;
    const cX = cos(radians(cAngle)) * 180;
    const cY = sin(radians(cAngle)) * 180;
    quadraticVertex(cX, cY, x, y)
</code></pre></div></div><div class="pair no-comment"><div class="code">

<pre><code>  }
}
endShape();
</code></pre></div></div></div></div>
    <p>You will often find yourself needing to use just one of the circular functions. The two shapes below are created just like that: The first one uses <code>sin()</code> and the second one uses <code>cos()</code> (as demonstrated in the code below).</p>

    <div class="grid">
      <div class="col-1-2">
<figure id="example56" class><div class="p5container"></div><script type="text/javascript">window.p5Examples = window.p5Examples || [];
window.p5Examples.push(["example56", function(p) {p.setup = function()
{
  p.createCanvas(600, 500);
  p.background(240);
  p.stroke(30);
  p.noFill();

  p.strokeWeight(20);
  p.strokeCap(p.SQUARE);

  p.translate((p.width/2) - 200, p.height/2);
  p.beginShape();
  for(let i = 0; i < 200; i++) {
    const x = i * 2;
    const y = p.sin(i * 0.03) * 100;
    p.vertex(x, y);
  }
  p.endShape();

  p.noLoop();
}
}])</script></figure>      </div>
      <div class="col-1-2">
<figure id="example57" class><div class="p5container"></div><script type="text/javascript">window.p5Examples = window.p5Examples || [];
window.p5Examples.push(["example57", function(p) {p.setup = function()
{
  p.createCanvas(600, 500);
  p.background(240);
  p.stroke(30);
  p.noFill();

  p.strokeWeight(20);
  p.strokeCap(p.SQUARE);
  p.translate((p.width/2) - 200, p.height/2);
  p.beginShape();
  for(let i = 0; i < 200; i++) {
    // 2 pixel spacing on the x-axis. {!1}
    const x = i * 2;
    // 200 pixel high waveform on the y-axis. {!1}
    const y = p.cos(i * p.radians(2)) * 100;
    p.vertex(x, y);
  }
  p.endShape();

  p.noLoop();
}
}])</script></figure>      </div>
    </div>

<div class="codesplit columns"><div class="pairs"><div class="pair no-comment"><div class="code">

<pre><code>strokeWeight(20);
strokeCap(SQUARE);
translate((width/2) - 200, height/2);
beginShape();
for(let i = 0; i &lt; 200; i++) {
</code></pre></div></div><div class="pair"><div class="comment"><p>2 pixel spacing on the x-axis.</p></div><div class="code">

<pre><code>  const x = i * 2;
</code></pre></div></div><div class="pair"><div class="comment"><p>200 pixel high waveform on the y-axis.</p></div><div class="code">

<pre><code>  const y = cos(i * radians(2)) * 100;
</code></pre></div></div><div class="pair no-comment"><div class="code">

<pre><code>  vertex(x, y);
}
endShape();
</code></pre></div></div></div></div>
    <p>Sine and Cosine can be used to create a range of different shapes during the design process. In this design by Josef M&#xFC;ller-Brockmann, a series of exponentially growing arcs are rotated around the bottom left of the canvas.</p>

    <figure class="text-width">
      <img src="../../assets/shape/procedural-shapes/brockmann.jpg">
      <figcaption>Beethoven poster by Josef M&#xFC;ller-Brockmann <a href="index.html#fairuse">&#xA9;</a></figcaption>
    </figure>

    <p>Sediment Mars is a series of generative poster designs by Sarah Hallacher and Alessandra Villaamil. The <code>sin()</code> and <code>cos()</code> functions are used to generate an elliptical shape, which is then distorted by adding random values to it.</p>

    <figure>
      <img src="../../assets/shape/procedural-shapes/sedimentmars.jpg">
      <figcaption>Sediment Mars by by Sarah Hallacher and Alessandra Villaamil <a href="index.html#fairuse">&#xA9;</a></figcaption>
    </figure>

    <p>The project Generative Play is a card game by Adria Navarro that uses procedural drawing to create an infinite amount of generative characters. The character bodies are created using <code>sin()</code> and <code>cos()</code>.</p>

    <figure>
      <img src="../../assets/shape/procedural-shapes/generativeplay.jpg">
      <figcaption>Generative Play by Adria Navarro <a href="index.html#fairuse">&#xA9;</a></figcaption>
    </figure>

    <p>This chapter introduced an approach to design that is inherently different than a traditional design process. Rather than individually placing each shape on the canvas, we wrote algorithms to do this for us. Using loops to procedurally draw shapes is a powerful concept, as it allows designers to do more with less code, thus alleviating us from the pains of manually constructing every design object by hand. This is also the hardest thing about procedural design, as designers need to devote more time up front distilling the system into code, and they cannot easily manipulate individual shapes like in a traditional design tool. The American computer scientist Donald Knuth calls this a transition from design to meta-design:</p>

    <blockquote class="text-width">
      <p>&#x201C;Meta-design is much more difficult than design; it is easier to draw something than to explain how to draw it. [&#x2026;] However, once we have successfully explained how to draw something in a sufficiently general manner, the same explanation will work for related shapes, in different circumstances; so the time spent in formulating a precise explanation turns out to be worth it.&#x201D;</p>
      <cite>Donald Knuth (1986), The Metafont Book</cite>
    </blockquote>

    <p>This is also the main thesis of this book. When designers learn to not only think systematically about the design process, but also to implement those systems in software, they can build things that were not possible before.</p>

  </section>

<div data-type="exercise" class="media-width" id="exercise-jQ10uWY">
  <svg width="100%" height="3" xmlns="http://www.w3.org/2000/svg">
    <line x1="0" y1="1" x2="100%" y2="1" stroke-dasharray="6, 3" stroke-width="2" stroke="#29b79b"/>
  </svg>
  <header class="text-width">
    <h2>Exercise</h2>
  </header>
  <p class="text-width">Try to draw all the basic shapes using the techniques presented in this chapter. Then continue to generate other types of shapes. Can you use <code>random()</code> to manipulate the shape outline? Can you use B&#xE9;zier curves instead of simple vertices?</p>
</div>

</section>
</div>
<div class="navigation">
  <div class="pagination grid">
    <div class="col-1-3 prev-page">
      <a href="../custom-shapes/index.html">Previous Chapter</a>
      <a href="../custom-shapes/index.html">Custom shapes</a>
    </div>
    <div class="col-1-3 newsletter">
      <a
        href="https://confirmsubscription.com/h/t/2E81B263662AA1A0"
        class="btn large invert"
        >Subscribe to Newsletter</a
      >
    </div>
    <div class="col-1-3 next-page">
      <a href="../../color/a-short-history-of-color-theory/index.html">Next Chapter</a>
      <a href="../../color/a-short-history-of-color-theory/index.html">A short history of color theory</a>
    </div>
  </div>

  <div data-type="copyright-page" id="fairuse">
    <hr />
    <p>
      Images with the Copyright symbol (©) are copyrighted and do not fall under
      the Creative Commons license of this book. Although unlicensed, these
      works are believed to qualify as fair use: The purpose of use is
      non-profit educational material, the works are used for informational
      purposes only, and the works are widely published in books and on
      websites.
    </p>
  </div>
</div>
      </article>
    </main>
    <script src="../../assets/app-c6c9c2d8c23735faaac5.js" type="text/javascript"></script>
  </body>
</html>
