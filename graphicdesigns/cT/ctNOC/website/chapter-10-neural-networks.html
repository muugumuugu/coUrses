<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>The Nature of Code</title>
	<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
	<script type="text/javascript" src="javascripts/codeprocessing.js"></script>
	<script type="text/javascript" src="processingjs/processing.js"></script>
  <script type="text/javascript" src="processingjs/lazyloading.js"></script>
  <script type="text/javascript" src="javascripts/sketchControls.js"></script>
  <script type="text/javascript" src="javascripts/jquery.fixed.js"></script>

  <script type="text/javascript" charset="utf-8">
    $(document).ready(function(){
      $('#toc-list').fixed({'top':'8'});
      $('#nav-bar-wrap').fixed({'top':'8'});

      $('span.c1').each(function(){ addStylesToCodeLines($(this)); });
      // $('code').each(function(){ inlineComments($(this)); });
      $('div.source-code').each(function(){ setRawCodeHeight($(this)); });
      $('a.toggle').click(function(){ toggleCodeDisplay($(this)); return false; });
    });
  </script>
	<link rel="stylesheet" href="stylesheets/fonts.css" type="text/css">
	<link rel="stylesheet" href="stylesheets/html.css" type="text/css">
	<link rel="stylesheet" href="stylesheets/code-html.css">

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-34673170-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<script>

    window.onload= function() {
      offsetUps = document.getElementsByClassName('offset-up');
      for(var i=0; i < offsetUps.length; i++) {
        var element = offsetUps[i];
        var comment = element.getElementsByClassName('code-comment')[0];
        var height = comment.offsetHeight;
        comment.style.top = '-' + (height) +  'px';
      }
    };
</script>

</head>
<body>

  <div id="navigator">
    <div id="navigator-inner">
      <div id='nav-bar-wrap'>
        <div id="mask"></div>
        <div id="nav-bar">
          <h1><a href="../index.html">THE <strong>NATURE</strong> OF CODE</a></h1>
          <h2>by Daniel Shiffman</h2>
          <a id="purchase-link" href="../index.html">Buy this book in print</a> <a id="purchase-link" href="../index.html">Buy this book as PDF</a>
        </div>
      </div>
      <div id="toc-holder">
        <div id="toc-list">
          <ul>
            <li><a href="../book.html">Welcome</a></li>
            <li><a href="acknowledgments.html">Acknowledgments</a></li>
            <li><a href="dedication.html">Dedication</a></li>
            <li><a href="preface.html">Preface</a></li>
            <li><a href="introduction.html">Introduction</a></li>
            <li><a href="chapter-1-vectors.html">1.  Vectors</a></li>
            <li><a href="chapter-2-forces.html">2.  Forces</a></li>
            <li><a href="chapter-3-oscillation.html">3.  Oscillation</a></li>
            <li><a href="chapter-4-particle-systems.html">4.  Particle Systems</a></li>
            <li><a href="chapter-5-physics-libraries.html">5.  Physics Libraries</a></li>
            <li><a href="chapter-6-autonomous-agents.html">6.  Autonomous Agents</a></li>
            <li><a href="chapter-7-cellular-automata.html">7.  Cellular Automata</a></li>
            <li><a href="chapter-8-fractals.html">8.  Fractals</a></li>
            <li><a href="chapter-9-the-evolution-of-code.html">9.  The Evolution of Code</a></li>
            <li><a href="chapter-10-neural-networks.html">10.  Neural Networks</a></li>
            <li><a href="further-reading.html">Further Reading</a></li>
            <li><a href="index.html">Index</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <div id="top">
    <div id="header">
      <h1><a href="../index.html">The <strong>Nature</strong> of Code</a></h1>
      <h2>Daniel Shiffman</h2>
    </div>
  </div>

  <div id="middle">

  	<div id="container">
  		<a id="_chapter_10_neural_networks" style="display: block;"></a><h2 id="chapter-10-neural-networks">Chapter 10.  Neural Networks</h2>
<blockquote >
  “You can’t process me with a normal brain.”
  
    <span class="attribution">
— Charlie Sheen
</span>
  
</blockquote><p><a id="artificial-intelligence-83082b80-253f-0130-bddf-7cd1c3f718ad" style="display: block;"></a><a id="neural-networks-830839c0-253f-0130-bde0-7cd1c3f718ad" style="display: block;"></a></p>
<p>We’re at the end of our story.   This is the last official chapter of this book (though I envision additional supplemental material for the website and perhaps new chapters in the future).    We began with inanimate objects living in a world of forces and gave those objects desires, autonomy, and the ability to take action according to a system of rules.  Next, we allowed those objects to live in a population and evolve over time.  Now we ask: What is each object’s decision-making process?  How can it adjust its choices by learning over time?  Can a computational entity process its environment and generate a decision?</p>
<p>The human brain can be described as a biological neural network—an interconnected web of neurons transmitting elaborate patterns of electrical signals.   Dendrites receive input signals and, based on those inputs, fire an output signal via an axon.  Or something like that.  How the human brain actually works is an elaborate and complex mystery, one that we certainly are not going to attempt to tackle in rigorous detail in this chapter.</p>
<a id="chapter10_figure1" style="display: block;"></a><div class="image-container " >
	
	<img src="imgs/chapter10/ch10_01.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 10.1</p>
</div>
<p>The good news is that developing engaging animated systems with code does not require scientific rigor or accuracy, as we’ve learned throughout this book.   We can simply be inspired by the idea of brain function.</p>
<p>In this chapter, we’ll begin with a conceptual overview of the properties and features of neural networks and build the simplest possible example of one (a network that consists of a single neuron).  Afterwards, we’ll examine strategies for creating a “Brain” object that can be inserted into our <span class="klass">Vehicle</span> class and used to determine steering.   Finally, we’ll also look at techniques for visualizing and animating a network of neurons.</p>
<section><a id="chapter10_section1" style="display: block;"></a><h3 id="101-artificial-neural-networks-introduction-and-application">10.1 Artificial Neural Networks: Introduction and Application</h3><p><a id="logical-calculus-of-the-ideas-imminent-in-nervous-activity-a-mccullochpitts-830875c0-253f-0130-bde1-7cd1c3f718ad" style="display: block;"></a></p>
<p><a id="mcculloch-warren-s-83088510-253f-0130-bde2-7cd1c3f718ad" style="display: block;"></a><a id="pitts-walter-83089480-253f-0130-bde3-7cd1c3f718ad" style="display: block;"></a></p>
<p>Computer scientists have long been inspired by the human brain.   In 1943, Warren S. McCulloch, a neuroscientist, and Walter Pitts, a logician, developed the first conceptual model of an artificial neural network.  In their paper, "A logical calculus of the ideas imminent in nervous activity,” they describe the concept of a neuron, a single cell living in a network of cells that receives inputs, processes those inputs, and generates an output.</p>
<p>Their work, and the work of many scientists and researchers that followed, was not meant to accurately describe how the biological brain works.  Rather, an artificial neural network (which we will now simply refer to as a “neural network”) was designed as a computational model based on the brain to solve certain kinds of problems.</p>
<p>It’s probably pretty obvious to you that there are problems that are incredibly simple for a computer to solve, but difficult for you.  Take the square root of 964,324, for example.  A quick line of code produces the value 982, a number Processing computed in less than a millisecond.   There are, on the other hand, problems that are incredibly simple for you or me to solve, but not so easy for a computer.   Show any toddler a picture of a kitten or puppy and they’ll be able to tell you very quickly which one is which.   Say hello and shake my hand one morning and you should be able to pick me out of a crowd of people the next day.  But need a machine to perform one of these tasks?  Scientists have already spent entire careers researching and implementing complex solutions.</p>
<p><a id="ai-for-game-developers-bourgseemann-8308ac00-253f-0130-bde4-7cd1c3f718ad" style="display: block;"></a><a id="artificial-intelligence-a-modern-approach-russellnorvig-8308bfc0-253f-0130-bde5-7cd1c3f718ad" style="display: block;"></a><a id="artificial-intelligencepattern-recognition-8308d380-253f-0130-bde6-7cd1c3f718ad" style="display: block;"></a><a id="bourg-david-m-8308e460-253f-0130-bde7-7cd1c3f718ad" style="display: block;"></a><a id="neural-networkspattern-recognition-8308f710-253f-0130-bde8-7cd1c3f718ad" style="display: block;"></a><a id="norvig-peter-83090870-253f-0130-bde9-7cd1c3f718ad" style="display: block;"></a><a id="pattern-recognition-83092170-253f-0130-bdea-7cd1c3f718ad" style="display: block;"></a><a id="russell-stuart-j-830938b0-253f-0130-bdeb-7cd1c3f718ad" style="display: block;"></a><a id="seemann-glenn-83094860-253f-0130-bdec-7cd1c3f718ad" style="display: block;"></a></p>
<p>The most common application of neural networks in computing today is to perform one of these “easy-for-a-human, difficult-for-a-machine” tasks, often referred to as pattern recognition.   Applications range from optical character recognition (turning printed or handwritten scans into digital text) to facial recognition.  We don’t have the time or need to use some of these more elaborate artificial intelligence algorithms here, but if you are interested in researching neural networks, I’d recommend the books <em>Artificial Intelligence: A Modern Approach</em> by Stuart J. Russell and Peter Norvig and <em>AI for Game Developers</em> by David M. Bourg and Glenn Seemann.</p>
<a id="chapter10_figure2" style="display: block;"></a><div class="image-container half-width-right" >
	
	<img src="imgs/chapter10/ch10_02.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 10.2</p>
</div>
<p><a id="complex-systemsconnectionist-computational-system-83097bb0-253f-0130-bded-7cd1c3f718ad" style="display: block;"></a><a id="connectionist-computational-system-83098d20-253f-0130-bdee-7cd1c3f718ad" style="display: block;"></a><a id="neural-networksconnectionist-computational-system-83099c70-253f-0130-bdef-7cd1c3f718ad" style="display: block;"></a></p>
<p>A neural network is a “connectionist” computational system.   The computational systems we write are procedural; a program starts at the first line of code, executes it, and goes on to the next, following instructions in a linear fashion.   A true neural network does not follow a linear path.  Rather, information is processed collectively, in parallel throughout a network of nodes (the nodes, in this case, being neurons).</p>
<p>Here we have yet another example of a complex system, much like the ones we examined in Chapters 6, 7, and 8.   The individual elements of the network, the neurons, are simple.  They read an input, process it, and generate an output.   A network of many neurons, however, can exhibit incredibly rich and intelligent behaviors.</p>
<p><a id="neural-networkslearning-and-8309b5a0-253f-0130-bdf0-7cd1c3f718ad" style="display: block;"></a><a id="weightneural-networks-and-8309c840-253f-0130-bdf1-7cd1c3f718ad" style="display: block;"></a></p>
<p>One of the key elements of a neural network is its ability to <em>learn</em>.  A neural network is not just a complex system, but a complex <strong><em>adaptive</em></strong> system, meaning it can change its internal structure based on the information flowing through it.  Typically, this is achieved through the adjusting of <em>weights</em>.  In the diagram above, each line represents a connection between two neurons and indicates the pathway for the flow of information.    Each connection has a <strong><em>weight</em></strong>, a number that controls the signal between the two neurons.   If the network generates a “good” output (which we’ll define later), there is no need to adjust the weights. However, if the network generates a “poor” output—an error, so to speak—then the system adapts, altering the weights in order to improve subsequent results.</p>
<p>There are several strategies for learning, and we’ll examine two of them in this chapter.</p>
<p><a id="neural-networkssupervised-learning-8309fc90-253f-0130-bdf2-7cd1c3f718ad" style="display: block;"></a><a id="supervised-learning-neural-networks-830a1500-253f-0130-bdf3-7cd1c3f718ad" style="display: block;"></a></p>
<div class="list">
	
	<ul>
		
			<li><p><strong><em>Supervised Learning</em></strong> —Essentially, a strategy that involves a teacher that is smarter than the network itself.  For example, let’s take the facial recognition example.  The teacher shows the network a bunch of faces, and the teacher already knows the name associated with each face.  The network makes its guesses, then the teacher provides the network with the answers.   The network can then compare its answers to the known “correct” ones and make adjustments according to its errors.  Our first neural network in the next section will follow this model.
</p>
</li>
		
	</ul>
</div><p><a id="neural-networksunsupervised-learning-830a3470-253f-0130-bdf4-7cd1c3f718ad" style="display: block;"></a><a id="unsupervised-learning-neural-networks-830a4660-253f-0130-bdf5-7cd1c3f718ad" style="display: block;"></a></p>
<div class="list">
	
	<ul>
		
			<li><p><strong><em>Unsupervised Learning</em></strong> —Required when there isn’t an example data set with known answers.    Imagine searching for a hidden pattern in a data set.   An application of this is clustering, i.e. dividing a set of elements into groups according to some unknown pattern.   We won’t be looking at any examples of unsupervised learning in this chapter, as this strategy is less relevant for our examples.
</p>
</li>
		
	</ul>
</div><p><a id="neural-networksreinforcement-learning-830a64e0-253f-0130-bdf6-7cd1c3f718ad" style="display: block;"></a><a id="reinforcement-learning-neural-networks-830a7750-253f-0130-bdf7-7cd1c3f718ad" style="display: block;"></a></p>
<div class="list">
	
	<ul>
		
			<li><p><strong><em>Reinforcement Learning</em></strong> —A strategy built on observation.   Think of a little mouse running through a maze. If it turns left, it gets a piece of cheese; if it turns right, it receives a little shock. (Don’t worry, this is just a pretend mouse.)   Presumably, the mouse will learn over time to turn left.  Its neural network makes a decision with an outcome (turn left or right) and observes its environment (yum or ouch).   If the observation is negative, the network can adjust its weights in order to make a different decision the next time.    Reinforcement learning is common in robotics.  At time <span class="var">t</span>, the robot performs a task and observes the results.   Did it crash into a wall or fall off a table?  Or is it unharmed?  We’ll look at reinforcement learning in the context of our simulated steering vehicles.
</p>
</li>
		
	</ul>
</div><p>This ability of a neural network to learn, to make adjustments to its structure over time, is what makes it so useful in the field of artificial intelligence.  Here are some standard uses of neural networks in software today.</p>
<p><a id="anomaly-detection-830a9f80-253f-0130-bdf8-7cd1c3f718ad" style="display: block;"></a><a id="control-of-physical-objects-830aae10-253f-0130-bdf9-7cd1c3f718ad" style="display: block;"></a><a id="neural-networksuses-of-830acd50-253f-0130-bdfa-7cd1c3f718ad" style="display: block;"></a><a id="signal-processing-830ae810-253f-0130-bdfb-7cd1c3f718ad" style="display: block;"></a><a id="soft-sensors-830af820-253f-0130-bdfc-7cd1c3f718ad" style="display: block;"></a><a id="time-series-prediction-830b0730-253f-0130-bdfd-7cd1c3f718ad" style="display: block;"></a></p>
<div class="list">
	
	<ul>
		
			<li><p><strong><em>Pattern Recognition</em></strong> —We’ve mentioned this several times already and it’s probably the most common application.   Examples are facial recognition, optical character recognition, etc.
</p>
</li>
		
			<li><p><strong><em>Time Series Prediction</em></strong> —Neural networks can be used to make predictions.  Will the stock rise or fall tomorrow?  Will it rain or be sunny?
</p>
</li>
		
			<li><p><strong><em>Signal Processing</em></strong> —Cochlear implants and hearing aids need to filter out unnecessary noise and amplify the important sounds.   Neural networks can be trained to process an audio signal and filter it appropriately.
</p>
</li>
		
			<li><p><strong><em>Control</em></strong> —You may have read about recent research advances in self-driving cars.   Neural networks are often used to manage steering decisions of physical vehicles (or simulated ones).
</p>
</li>
		
			<li><p><strong><em>Soft Sensors</em></strong> —A soft sensor refers to the process of analyzing a collection of many measurements.   A thermometer can tell you the temperature of the air, but what if you also knew the humidity, barometric pressure, dewpoint, air quality, air density, etc.?  Neural networks can be employed to process the input data from many individual sensors and evaluate them as a whole.
</p>
</li>
		
			<li><p><strong><em>Anomaly Detection</em></strong> —Because neural networks are so good at recognizing patterns, they can also be trained to generate an output when something occurs that doesn’t fit the pattern.  Think of a neural network monitoring your daily routine over a long period of time.  After learning the patterns of your behavior, it could alert you when something is amiss.
</p>
</li>
		
	</ul>
</div><p>This is by no means a comprehensive list of applications of neural networks.   But hopefully it gives you an overall sense of the features and possibilities.   The thing is, neural networks are complicated and difficult.  They involve all sorts of fancy mathematics.   While this is all fascinating (and incredibly important to scientific research), a lot of the techniques are not very practical in the world of building interactive, animated Processing sketches.   Not to mention that in order to cover all this material, we would need another book—or more likely, a series of books.</p>
<p>So instead, we’ll begin our last hurrah in the nature of code with the simplest of all neural networks, in an effort to understand how the overall concepts are applied in code.  Then we’ll look at some Processing sketches that generate visual results inspired by these concepts.</p>
</section><section><a id="chapter10_section2" style="display: block;"></a><h3 id="102-the-perceptron">10.2  The Perceptron</h3><p><a id="cornell-aeronautical-laboratory-830b6a40-253f-0130-bdfe-7cd1c3f718ad" style="display: block;"></a><a id="neural-networksperceptron-830b7980-253f-0130-bdff-7cd1c3f718ad" style="display: block;"></a><a id="perceptron-830b8a30-253f-0130-be00-7cd1c3f718ad" style="display: block;"></a><a id="perceptronimplementing-830b9920-253f-0130-be01-7cd1c3f718ad" style="display: block;"></a><a id="rosenblatt-frank-830bac00-253f-0130-be02-7cd1c3f718ad" style="display: block;"></a></p>
<p>Invented in 1957 by Frank Rosenblatt at the Cornell Aeronautical Laboratory, a perceptron is the simplest neural network possible: a computational model of a single neuron. A perceptron consists of one or more inputs, a processor, and a single output.</p>
<a id="chapter10_figure3" style="display: block;"></a><div class="image-container " >
	
	<img src="imgs/chapter10/ch10_03.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 10.3: The perceptron</p>
</div>
<p><a id="feed-forward-model-neural-networks-830bce60-253f-0130-be03-7cd1c3f718ad" style="display: block;"></a></p>
<p>A perceptron follows the “feed-forward” model, meaning inputs are sent into the neuron, are processed, and result in an output.  In the diagram above, this means the network (one neuron) reads from left to right: inputs come in, output goes out.</p>
<p>Let’s follow each of these steps in more detail.</p>
<p><span class="highlight">Step 1: Receive inputs.</span></p>
<p>Say we have a perceptron with two inputs—let’s call them <em>x1</em> and <em>x2</em>.</p>
<p><span class="mono">Input 0:         x1 = 12<br />
Input 1:        x2 = 4</span></p>
<p><span class="highlight">Step 2: Weight inputs.</span></p>
<p>Each input that is sent into the neuron must first be weighted, i.e. multiplied by some value (often a number between -1 and 1).   When creating a perceptron, we’ll typically begin by assigning random weights.  Here, let’s give the inputs the following weights:</p>
<p><span class="mono">Weight 0: 0.5<br />
Weight 1: -1</span></p>
<p>We take each input and multiply it by its weight.</p>
<p><span class="mono">Input 0 * Weight 0 ⇒ 12 * 0.5 = 6</span></p>
<p><span class="mono">Input 1 * Weight 1 ⇒ 4 * -1 = -4</span></p>
<p><span class="highlight">Step 3: Sum inputs.</span></p>
<p>The weighted inputs are then summed.</p>
<p><span class="mono">Sum = 6 + -4 = 2</span></p>
<p><span class="highlight">Step 4: Generate output.</span></p>
<p><a id="activation-functions-of-neural-networks-830c67e0-253f-0130-be04-7cd1c3f718ad" style="display: block;"></a><a id="neural-networksactivation-functions-of-830c7d50-253f-0130-be05-7cd1c3f718ad" style="display: block;"></a></p>
<p>The output of a perceptron is generated by passing that sum through an activation function.    In the case of a simple binary output, the activation function is what tells the perceptron whether to “fire” or not.   You can envision an LED connected to the output signal: if it fires, the light goes on; if not, it stays off.</p>
<p>Activation functions can get a little bit hairy.   If you start reading one of those artificial intelligence textbooks looking for more info about activation functions, you may soon find yourself reaching for a calculus textbook.    However, with our friend the simple perceptron, we’re going to do something really easy.  Let’s make the activation function the sign of the sum.   In other words, if the sum is a positive number, the output is 1; if it is negative, the output is -1.</p>
<p><span class="mono">Output = sign(sum) ⇒ sign(2) ⇒ +1</span></p>
<p>Let’s review and condense these steps so we can implement them with a code snippet.</p>
<p><strong><em>The Perceptron Algorithm:</em></strong></p>
<div class="list">
	
	<ol class="arabic">
		
			<li><p>
For every input, multiply that input by its weight.
</p>
</li>
		
			<li><p>
Sum all of the weighted inputs.
</p>
</li>
		
			<li><p>
Compute the output of the perceptron based on that sum passed through an activation function (the sign of the sum).
</p>
</li>
		
	</ol>
</div><p>Let’s assume we have two arrays of numbers, the inputs and the weights.   For example:</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>float[] inputs  = {12 , 4};
float[] weights = {0.5,-1};</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">float</span><span class="o">[]</span> <span class="n">inputs</span>  <span class="o">=</span> <span class="o">{</span><span class="mi">12</span> <span class="o">,</span> <span class="mi">4</span><span class="o">};</span></span>
<span class='one-line'><span class="kt">float</span><span class="o">[]</span> <span class="n">weights</span> <span class="o">=</span> <span class="o">{</span><span class="mf">0.5</span><span class="o">,-</span><span class="mi">1</span><span class="o">};</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>“For every input” implies a loop that multiplies each input by its corresponding weight.  Since we need the sum, we can add up the results in that very loop.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>//[full] Steps 1 and 2: Add up all the weighted inputs.
float sum = 0;
for (int i = 0; i < inputs.length; i++) {
  sum += inputs[i]*weights[i];
}
//[end]</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Steps 1 and 2: Add up all the weighted inputs.</div><code><pre><span class='one-line'><span class="kt">float</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span></span>
<span class='one-line'><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inputs</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">sum</span> <span class="o">+=</span> <span class="n">inputs</span><span class="o">[</span><span class="n">i</span><span class="o">]*</span><span class="n">weights</span><span class="o">[</span><span class="n">i</span><span class="o">];</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Once we have the sum we can compute the output.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>// Step 3: Passing the sum
// through an activation function
float output = activate(sum);

// The activation function
int activate(float sum) {
  //[full] Return a 1 if positive, -1 if negative.
  if (sum > 0) return 1;
  else return -1;
  //[end]
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair '><div class='code-comment '>Step 3: Passing the sum
through an activation function</div><code><pre><span class='one-line'><span class="kt">float</span> <span class="n">output</span> <span class="o">=</span> <span class="n">activate</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The activation function</div><code><pre><span class='one-line'><span class="kt">int</span> <span class="nf">activate</span><span class="o">(</span><span class="kt">float</span> <span class="n">sum</span><span class="o">)</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Return a 1 if positive, -1 if negative.</div><code><pre><span class='one-line'>  <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span></span>
<span class='one-line'>  <span class="k">else</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div></section><section><a id="chapter10_section3" style="display: block;"></a><h3 id="103-simple-pattern-recognition-using-a-perceptron">10.3  Simple Pattern Recognition Using a Perceptron</h3><p><a id="bias-input-perceptron-830ce3e0-253f-0130-be06-7cd1c3f718ad" style="display: block;"></a><a id="pattern-recognitionperceptron-and-830cf5f0-253f-0130-be07-7cd1c3f718ad" style="display: block;"></a><a id="perceptronbias-input-830d0850-253f-0130-be08-7cd1c3f718ad" style="display: block;"></a><a id="perceptronerror-calculations-and-830d1c00-253f-0130-be09-7cd1c3f718ad" style="display: block;"></a><a id="perceptronpattern-recognition-with-830d2d90-253f-0130-be0a-7cd1c3f718ad" style="display: block;"></a></p>
<p>Now that we understand the computational process of a perceptron, we can look at an example of one in action.   We stated that neural networks are often used for pattern recognition applications, such as facial recognition.   Even simple perceptrons can demonstrate the basics of classification, as in the following example.</p>
<a id="chapter10_figure4" style="display: block;"></a><div class="image-container half-width-right" >
	
	<img src="imgs/chapter10/ch10_04.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 10.4</p>
</div>
<p>Consider a line in two-dimensional space. Points in that space can be classified as living on either one side of the line or the other. While this is a somewhat silly example (since there is clearly no need for a neural network; we can determine on which side a point lies with some simple algebra), it shows how a perceptron can be trained to recognize points on one side versus another.</p>
<p>Let’s say a perceptron has 2 inputs (the x- and y-coordinates of a point). Using a sign activation function, the output will either be  -1 or 1—i.e., the input data is classified according to the sign of the output.  In the above diagram, we can see how each point is either below the line (-1) or above (+1).</p>
<p>The perceptron itself can be diagrammed as follows:</p>
<a id="chapter10_figure5" style="display: block;"></a><div class="image-container " >
	
	<img src="imgs/chapter10/ch10_05.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 10.5</p>
</div>
<p>We can see how there are two inputs (<em>x</em> and <em>y</em>), a weight for each input (<em>weight<sub>x</sub></em> and <em>weight<sub>y</sub></em>), as well as a processing neuron that generates the output.</p>
<p>There is a pretty significant problem here, however.  Let’s consider the point (0,0).  What if we send this point into the perceptron as its input:  x = 0 and y = 0?  What will the sum of its weighted inputs be?  No matter what the weights are, the sum will always be 0!  But this can’t be right—after all, the point (0,0) could certainly be above or below various lines in our two-dimensional world.</p>
<p>To avoid this dilemma, our perceptron will require a third input, typically referred to as a <strong><em>bias</em></strong> input.   A bias input always has the value of 1 and is also weighted.  Here is our perceptron with the addition of the bias:</p>
<a id="chapter10_figure6" style="display: block;"></a><div class="image-container " >
	
	<img src="imgs/chapter10/ch10_06.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 10.6</p>
</div>
<p>Let’s go back to the point (0,0).   Here are our inputs:</p>
<p><span class="mono">0 * weight for x = 0<br />
0 * weight for y = 0<br />
1 * weight for bias = weight for bias</span></p>
<p>The output is the sum of the above three values, 0 plus 0 plus the bias’s weight.  Therefore, the bias, on its own, answers the question as to where (0,0) is in relation to the line.  If the bias’s weight is positive, (0,0) is above the line; negative, it is below.   It “biases” the perceptron’s understanding of the line’s position relative to (0,0).</p>
</section><section><a id="chapter10_section4" style="display: block;"></a><h3 id="104-coding-the-perceptron">10.4  Coding the Perceptron</h3><p>We’re now ready to assemble the code for a <span class="klass">Perceptron</span> class.  The only data the perceptron needs to track are the input weights, and we could use an array of floats to store these.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>class Perceptron {
  float[] weights;</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kd">class</span> <span class="nc">Perceptron</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="kt">float</span><span class="o">[]</span> <span class="n">weights</span><span class="o">;</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>The constructor could receive an argument indicating the number of inputs (in this case three: x, y, and a bias) and size the array accordingly.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>  Perceptron(int n) {
    weights = new float[n];
    for (int i = 0; i < weights.length; i++) {
      // The weights are picked randomly to start.
      weights[i] = random(-1,1);
    }
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="n">Perceptron</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">weights</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="o">[</span><span class="n">n</span><span class="o">];</span></span>
<span class='one-line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">weights</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The weights are picked randomly to start.</div><code><pre><span class='one-line'>      <span class="n">weights</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">(-</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span></span>
<span class='one-line'>    <span class="o">}</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>A perceptron needs to be able to receive inputs and generate an output.  We can package these requirements into a function called <span class="function">feedforward()</span>.   In this example, we’ll have the perceptron receive its inputs as an array (which should be the same length as the array of weights) and return the output as an integer.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>  int feedforward(float[] inputs) {
    float sum = 0;
    for (int i = 0; i < weights.length; i++) {
      sum += inputs[i]*weights[i];
    }
    // Result is the sign of the sum, -1 or +1.
    // Here the perceptron is making a guess.
    // Is it on one side of the line or the other?
    return activate(sum);
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="kt">int</span> <span class="nf">feedforward</span><span class="o">(</span><span class="kt">float</span><span class="o">[]</span> <span class="n">inputs</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="kt">float</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span></span>
<span class='one-line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">weights</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span></span>
<span class='one-line'>      <span class="n">sum</span> <span class="o">+=</span> <span class="n">inputs</span><span class="o">[</span><span class="n">i</span><span class="o">]*</span><span class="n">weights</span><span class="o">[</span><span class="n">i</span><span class="o">];</span></span>
<span class='one-line'>    <span class="o">}</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Result is the sign of the sum, -1 or +1.
Here the perceptron is making a guess.
Is it on one side of the line or the other?</div><code><pre><span class='one-line'>    <span class="k">return</span> <span class="nf">activate</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Presumably, we could now create a <span class="klass">Perceptron</span> object and ask it to make a guess for any given point.</p>
<a id="chapter10_figure7" style="display: block;"></a><div class="image-container " >
	
	<img src="imgs/chapter10/ch10_07.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 10.7</p>
</div>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>// Create the Perceptron.
Perceptron p = new Perceptron(3);
// The input is 3 values: x,y and bias.
float[] point = {50,-12,1};
// The answer!
int result = p.feedforward(point);</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair '><div class='code-comment '>Create the Perceptron.</div><code><pre><span class='one-line'><span class="n">Perceptron</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Perceptron</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The input is 3 values: x,y and bias.</div><code><pre><span class='one-line'><span class="kt">float</span><span class="o">[]</span> <span class="n">point</span> <span class="o">=</span> <span class="o">{</span><span class="mi">50</span><span class="o">,-</span><span class="mi">12</span><span class="o">,</span><span class="mi">1</span><span class="o">};</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The answer!</div><code><pre><span class='one-line'><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">feedforward</span><span class="o">(</span><span class="n">point</span><span class="o">);</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Did the perceptron get it right?    At this point, the perceptron has no better than a 50/50 chance of arriving at the right answer.  Remember, when we created it, we gave each weight a random value.    A neural network isn’t magic.   It’s not going to be able to guess anything correctly unless we teach it how to!</p>
<p>To train a neural network to answer correctly, we’re going to employ the method of <em>supervised learning</em> that we described in <a href="chapter-10-neural-networks.html#chapter10_section1">section 10.1</a>.</p>
<p>With this method, the network is provided with inputs for which there is a known answer.  This way the network can find out if it has made a correct guess.  If it’s incorrect, the network can learn from its mistake and adjust its weights.  The process is as follows:</p>
<div class="list">
	
	<ol class="arabic">
		
			<li><p>
Provide the perceptron with inputs for which there is a known answer.
</p>
</li>
		
			<li><p>
Ask the perceptron to guess an answer.
</p>
</li>
		
			<li><p>
Compute the error.  (Did it get the answer right or wrong?)
</p>
</li>
		
			<li><p>
Adjust all the weights according to the error.
</p>
</li>
		
			<li><p>
Return to Step 1 and repeat!
</p>
</li>
		
	</ol>
</div><p>Steps 1 through 4 can be packaged into a function.  Before we can write the entire function, however, we need to examine Steps 3 and 4 in more detail.  How do we define the perceptron’s error?  And how should we adjust the weights according to this error?</p>
<p>The perceptron’s error can be defined as the difference between the desired answer and its guess.</p>
<p><span class="formula">ERROR = DESIRED OUTPUT - GUESS OUTPUT</span></p>
<p>The above formula may look familiar to you.  In <a href="chapter-10-neural-networks.html#chapter06_section3">Chapter 6</a>, we computed a steering force as the difference between our desired velocity and our current velocity.</p>
<p><span class="formula">STEERING = DESIRED VELOCITY - CURRENT VELOCITY</span></p>
<p>This was also an error calculation.  The current velocity acts as a guess and the error (the steering force) tells us how to adjust the velocity in the right direction.   In a moment, we’ll see how adjusting the vehicle’s velocity to follow a target is just like adjusting the weights of a neural network to arrive at the right answer.</p>
<p>In the case of the perceptron, the output has only two possible values: <strong><em>+1</em></strong> or <strong><em>-1</em></strong>.   This means there are only three possible errors.</p>
<p>If the perceptron guesses the correct answer, then the guess equals the desired output and the error is 0.  If the correct answer is -1 and we’ve guessed +1, then the error is -2.  If the correct answer is +1 and we’ve guessed -1, then the error is +2.</p>
<div class="table">
	
	<table>
		
			<thead>
				<tr>
					
						<th>Desired        </th>
					
						<th>Guess  </th>
					
						<th>Error</th>
					
				</tr>
			</thead>
		
	
		
	
		<tbody>
		
			<tr>
				
					<td><p>-1</p>
</td>
				
					<td><p>-1</p>
</td>
				
					<td><p>0</p>
</td>
				
			</tr>
		
			<tr>
				
					<td><p>-1</p>
</td>
				
					<td><p>+1</p>
</td>
				
					<td><p>-2</p>
</td>
				
			</tr>
		
			<tr>
				
					<td><p>+1</p>
</td>
				
					<td><p>-1</p>
</td>
				
					<td><p>+2</p>
</td>
				
			</tr>
		
			<tr>
				
					<td><p>+1</p>
</td>
				
					<td><p>+1</p>
</td>
				
					<td><p>0</p>
</td>
				
			</tr>
		
		</tbody>
	</table>
</div><p><a id="delta-weight-83133980-253f-0130-be0b-7cd1c3f718ad" style="display: block;"></a></p>
<p>The error is the determining factor in how the perceptron’s weights should be adjusted.   For any given weight, what we are looking to calculate is the change in weight, often called <em>Δweight</em> (or “delta” weight, delta being the Greek letter Δ).</p>
<p><span class="formula">NEW WEIGHT = WEIGHT + ΔWEIGHT</span></p>
<p>Δweight is calculated as the error multiplied by the input.</p>
<p><span class="formula">ΔWEIGHT = ERROR * INPUT</span></p>
<p>Therefore:</p>
<p><span class="formula">NEW WEIGHT = WEIGHT + ERROR * INPUT</span></p>
<p>To understand why this works, we can again return to <a href="chapter-10-neural-networks.html#chapter06_section3">steering</a>.  A steering force is essentially an error in velocity.  If we apply that force as our acceleration (Δvelocity), then we adjust our velocity to move in the correct direction.  This is what we want to do with our neural network’s weights.  We want to adjust them in the right direction, as defined by the error.</p>
<p><a id="learning-constant-8313c5a0-253f-0130-be0c-7cd1c3f718ad" style="display: block;"></a><a id="perceptronlearning-constant-8313eec0-253f-0130-be0d-7cd1c3f718ad" style="display: block;"></a></p>
<p>With steering, however, we had an additional variable that controlled the vehicle’s ability to steer: the <em>maximum force</em>.   With a high maximum force, the vehicle was able to accelerate and turn very quickly; with a lower force, the vehicle would take longer to adjust its velocity.  The neural network will employ a similar strategy with a variable called the “learning constant.”  We’ll add in the learning constant as follows:</p>
<p><span class="formula">NEW WEIGHT = WEIGHT + ERROR * INPUT * LEARNING CONSTANT</span></p>
<p>Notice that a high learning constant means the weight will change more drastically.  This may help us arrive at a solution more quickly, but with such large changes in weight it’s possible we will overshoot the optimal weights.  With a small learning constant, the weights will be adjusted slowly, requiring more training time but allowing the network to make very small adjustments that could improve the network’s overall accuracy.</p>
<p>Assuming the addition of a variable <span class="var">c</span> for the learning constant, we can now write a training function for the perceptron following the above steps.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>// A new variable is introduced
// to control the learning rate.
float c = 0.01;

// Step 1: Provide the inputs and known answer.
// These are passed in as arguments to train().
void train(float[] inputs, int desired) {

  // Step 2: Guess according to those inputs.
  int guess = feedforward(inputs);

  // Step 3: Compute the error (difference
  // between answer and guess).
  float error = desired - guess;

  //[full] Step 4: Adjust all the weights according
  // to the error and learning constant.
  for (int i = 0; i < weights.length; i++) {
    weights[i] += c * error * inputs[i];
  }
  //[end]
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair '><div class='code-comment '>A new variable is introduced
to control the learning rate.</div><code><pre><span class='one-line'><span class="kt">float</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">0.01</span><span class="o">;</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Step 1: Provide the inputs and known answer.
These are passed in as arguments to train().</div><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">train</span><span class="o">(</span><span class="kt">float</span><span class="o">[]</span> <span class="n">inputs</span><span class="o">,</span> <span class="kt">int</span> <span class="n">desired</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Step 2: Guess according to those inputs.</div><code><pre><span class='one-line'>  <span class="kt">int</span> <span class="n">guess</span> <span class="o">=</span> <span class="n">feedforward</span><span class="o">(</span><span class="n">inputs</span><span class="o">);</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Step 3: Compute the error (difference
between answer and guess).</div><code><pre><span class='one-line'>  <span class="kt">float</span> <span class="n">error</span> <span class="o">=</span> <span class="n">desired</span> <span class="o">-</span> <span class="n">guess</span><span class="o">;</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Step 4: Adjust all the weights according
to the error and learning constant.</div><code><pre><span class='one-line'>  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">weights</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">weights</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">error</span> <span class="o">*</span> <span class="n">inputs</span><span class="o">[</span><span class="n">i</span><span class="o">];</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>We can now see the <span class="klass">Perceptron</span> class as a whole.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>class Perceptron {
  //[full] The Perceptron stores its weights and learning constants.
  float[] weights;
  float c = 0.01;
  //[end]

  Perceptron(int n) {
    weights = new float[n];
    //[full] Weights start off random.
    for (int i = 0; i < weights.length; i++) {
      weights[i] = random(-1,1);
    }
    //[end]
  }

  //[full] Return an output based on inputs.
  int feedforward(float[] inputs) {
    float sum = 0;
    for (int i = 0; i < weights.length; i++) {
      sum += inputs[i]*weights[i];
    }
    return activate(sum);
  }
  //[end]

  //[full] Output is a +1 or -1.
  int activate(float sum) {
    if (sum > 0) return 1;
    else return -1;
  }
  //[end]

  //[full] Train the network against known data.
  void train(float[] inputs, int desired) {
    int guess = feedforward(inputs);
    float error = desired - guess;
    for (int i = 0; i < weights.length; i++) {
      weights[i] += c * error * inputs[i];
    }
  }
  //[end]
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kd">class</span> <span class="nc">Perceptron</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> The Perceptron stores its weights and learning constants.</div><code><pre><span class='one-line'>  <span class="kt">float</span><span class="o">[]</span> <span class="n">weights</span><span class="o">;</span></span>
<span class='one-line'>  <span class="kt">float</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">0.01</span><span class="o">;</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'> </span>
<span class='one-line'>  <span class="n">Perceptron</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">weights</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="o">[</span><span class="n">n</span><span class="o">];</span></span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Weights start off random.</div><code><pre><span class='one-line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">weights</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span></span>
<span class='one-line'>      <span class="n">weights</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">(-</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span></span>
<span class='one-line'>    <span class="o">}</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Return an output based on inputs.</div><code><pre><span class='one-line'>  <span class="kt">int</span> <span class="nf">feedforward</span><span class="o">(</span><span class="kt">float</span><span class="o">[]</span> <span class="n">inputs</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="kt">float</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span></span>
<span class='one-line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">weights</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span></span>
<span class='one-line'>      <span class="n">sum</span> <span class="o">+=</span> <span class="n">inputs</span><span class="o">[</span><span class="n">i</span><span class="o">]*</span><span class="n">weights</span><span class="o">[</span><span class="n">i</span><span class="o">];</span></span>
<span class='one-line'>    <span class="o">}</span></span>
<span class='one-line'>    <span class="k">return</span> <span class="nf">activate</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Output is a +1 or -1.</div><code><pre><span class='one-line'>  <span class="kt">int</span> <span class="nf">activate</span><span class="o">(</span><span class="kt">float</span> <span class="n">sum</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span></span>
<span class='one-line'>    <span class="k">else</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Train the network against known data.</div><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">train</span><span class="o">(</span><span class="kt">float</span><span class="o">[]</span> <span class="n">inputs</span><span class="o">,</span> <span class="kt">int</span> <span class="n">desired</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="kt">int</span> <span class="n">guess</span> <span class="o">=</span> <span class="n">feedforward</span><span class="o">(</span><span class="n">inputs</span><span class="o">);</span></span>
<span class='one-line'>    <span class="kt">float</span> <span class="n">error</span> <span class="o">=</span> <span class="n">desired</span> <span class="o">-</span> <span class="n">guess</span><span class="o">;</span></span>
<span class='one-line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">weights</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span></span>
<span class='one-line'>      <span class="n">weights</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">error</span> <span class="o">*</span> <span class="n">inputs</span><span class="o">[</span><span class="n">i</span><span class="o">];</span></span>
<span class='one-line'>    <span class="o">}</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p><a id="perceptrontraining-83146cd0-253f-0130-be0e-7cd1c3f718ad" style="display: block;"></a></p>
<p>To train the perceptron, we need a set of inputs with a known answer.   We could package this up in a class like so:</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>class Trainer {

  // A "Trainer" object stores the inputs and the correct answer.
  float[] inputs;
  int answer;

  Trainer(float x, float y, int a) {
    inputs = new float[3];
    inputs[0] = x;
    inputs[1] = y;
    // Note that the Trainer has the bias input built into its array.
    inputs[2] = 1;
    answer = a;
  }
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kd">class</span> <span class="nc">Trainer</span> <span class="o">{</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>A "Trainer" object stores the inputs and the correct answer.</div><code><pre><span class='one-line'>  <span class="kt">float</span><span class="o">[]</span> <span class="n">inputs</span><span class="o">;</span></span>
<span class='one-line'>  <span class="kt">int</span> <span class="n">answer</span><span class="o">;</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">Trainer</span><span class="o">(</span><span class="kt">float</span> <span class="n">x</span><span class="o">,</span> <span class="kt">float</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">inputs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="o">[</span><span class="mi">3</span><span class="o">];</span></span>
<span class='one-line'>    <span class="n">inputs</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span></span>
<span class='one-line'>    <span class="n">inputs</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Note that the Trainer has the bias input built into its array.</div><code><pre><span class='one-line'>    <span class="n">inputs</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span></span>
<span class='one-line'>    <span class="n">answer</span> <span class="o">=</span> <span class="n">a</span><span class="o">;</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Now the question becomes, how do we pick a point and know whether it is above or below a line?   Let’s start with the formula for a line, where <span class="var">y</span> is calculated as a function of <span class="var">x</span>:</p>
<p><span class="formula">y = f(x)</span></p>
<p>In generic terms, a line can be described as:</p>
<p><span class="formula">y = ax + b</span></p>
<p>Here’s a specific example:</p>
<p><span class="formula">y = 2*x + 1</span></p>
<p>We can then write a Processing function with this in mind.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>//[full] A function to calculate y based on x along a line
float f(float x) {
  return 2*x+1;
}
//[end]</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> A function to calculate y based on x along a line</div><code><pre><span class='one-line'><span class="kt">float</span> <span class="nf">f</span><span class="o">(</span><span class="kt">float</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>So, if we make up a point:</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>float x = random(width);
float y = random(height);</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">random</span><span class="o">(</span><span class="n">width</span><span class="o">);</span></span>
<span class='one-line'><span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">random</span><span class="o">(</span><span class="n">height</span><span class="o">);</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>How do we know if this point is above or below the line?   The line function <span class="function">f(x)</span> gives us the <span class="var">y</span> value on the line for that <span class="var">x</span> position.  Let’s call that <span class="var">yline</span>.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>// The y position on the line
float yline = f(x);</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair '><div class='code-comment '>The y position on the line</div><code><pre><span class='one-line'><span class="kt">float</span> <span class="n">yline</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">);</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>If the <span class="var">y</span> value we are examining is above the line, it will be less than <span class="var">yline</span>.</p>
<a id="chapter10_figure8" style="display: block;"></a><div class="image-container " >
	
	<img src="imgs/chapter10/ch10_08.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 10.8</p>
</div>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>if (y < yline) {
  // The answer is -1 if y is above the line.
  answer = -1;
} else {
  answer = 1;
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">yline</span><span class="o">)</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The answer is -1 if y is above the line.</div><code><pre><span class='one-line'>  <span class="n">answer</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span></span>
<span class='one-line'><span class="o">}</span> <span class="k">else</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">answer</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>We can then make a <span class="klass">Trainer</span> object with the inputs and the correct answer.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>Trainer t = new Trainer(x, y, answer);</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="n">Trainer</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Trainer</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">answer</span><span class="o">);</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Assuming we had a <span class="klass">Perceptron</span> object <span class="var">ptron</span>, we could then train it by sending the inputs along with the known answer.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>ptron.train(t.inputs,t.answer);</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="n">ptron</span><span class="o">.</span><span class="na">train</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">inputs</span><span class="o">,</span><span class="n">t</span><span class="o">.</span><span class="na">answer</span><span class="o">);</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Now, it’s important to remember that this is just a demonstration.  Remember our <a href="chapter-10-neural-networks.html#chapter09_section2">Shakespeare-typing monkeys</a>?  We asked our genetic algorithm to solve for “to be or not to be”—an answer we already knew.  We did this to make sure our genetic algorithm worked properly.  The same reasoning applies to this example.  We don’t need a perceptron to tell us whether a point is above or below a line; we can do that with simple math.   We are using this scenario, one that we can easily solve without a perceptron, to demonstrate the perceptron’s algorithm as well as easily confirm that it is working properly.</p>
<p>Let’s look at how the perceptron works with an array of many training points.</p>
<div class="image-container screenshot" >
	
	<canvas data-processing-sources="../NOC%20examples%20-%20processing/chp10/NOC_10_01_SimplePerceptron/NOC_10_01_SimplePerceptron.pde ../NOC%20examples%20-%20processing/chp10/NOC_10_01_SimplePerceptron/Perceptron.pde ../NOC%20examples%20-%20processing/chp10/NOC_10_01_SimplePerceptron/Trainer.pde" class="screenshot">
		<p>Your browser does not support the canvas tag.</p>
	</canvas>
  <div class="sketch-controls">
    <button class="reset">RESET</button>
    <button class="pause">PAUSE</button>
  </div>
	
	
</div>
<p><a id="chapter10_example1" style="display: block;"></a><span class="example">Example 10.1: The Perceptron</span></p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>// The Perceptron
Perceptron ptron;
// 2,000 training points
Trainer[] training = new Trainer[2000];
int count = 0;

//[full] The formula for a line
float f(float x) {
  return 2*x+1;
}
//[end]

void setup() {
  size(640, 360);

  ptron = new Perceptron(3);

  // Make 2,000 training points.
  for (int i = 0; i < training.length; i++) {
    float x = random(-width/2,width/2);
    float y = random(-height/2,height/2);
    //[full] Is the correct answer 1 or -1?
    int answer = 1;
    if (y < f(x)) answer = -1;
    //[end]
    training[i] = new Trainer(x, y, answer);
  }
}


void draw() {
  background(255);
  translate(width/2,height/2);

  ptron.train(training[count].inputs, training[count].answer);
  // For animation, we are training one point at a time.
  count = (count + 1) % training.length;

  for (int i = 0; i < count; i++) {
    stroke(0);
    int guess = ptron.feedforward(training[i].inputs);
    //[full] Show the classification—no fill for -1, black for +1.
    if (guess > 0) noFill();
    else           fill(0);
    //[end]
    ellipse(training[i].inputs[0], training[i].inputs[1], 8, 8);
  }
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair '><div class='code-comment '>The Perceptron</div><code><pre><span class='one-line'><span class="n">Perceptron</span> <span class="n">ptron</span><span class="o">;</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>2,000 training points</div><code><pre><span class='one-line'><span class="n">Trainer</span><span class="o">[]</span> <span class="n">training</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Trainer</span><span class="o">[</span><span class="mi">2000</span><span class="o">];</span></span>
<span class='one-line'><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> The formula for a line</div><code><pre><span class='one-line'><span class="kt">float</span> <span class="nf">f</span><span class="o">(</span><span class="kt">float</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'> </span>
<span class='one-line'><span class="kt">void</span> <span class="nf">setup</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">size</span><span class="o">(</span><span class="mi">640</span><span class="o">,</span> <span class="mi">360</span><span class="o">);</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">ptron</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Perceptron</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Make 2,000 training points.</div><code><pre><span class='one-line'>  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">training</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">random</span><span class="o">(-</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span></span>
<span class='one-line'>    <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">random</span><span class="o">(-</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Is the correct answer 1 or -1?</div><code><pre><span class='one-line'>    <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span></span>
<span class='one-line'>    <span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="n">answer</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>    <span class="n">training</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Trainer</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">answer</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'><span class="o">}</span></span>
<span class='one-line'> </span>
<span class='one-line'> </span>
<span class='one-line'><span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">background</span><span class="o">(</span><span class="mi">255</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">translate</span><span class="o">(</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">ptron</span><span class="o">.</span><span class="na">train</span><span class="o">(</span><span class="n">training</span><span class="o">[</span><span class="n">count</span><span class="o">].</span><span class="na">inputs</span><span class="o">,</span> <span class="n">training</span><span class="o">[</span><span class="n">count</span><span class="o">].</span><span class="na">answer</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>For animation, we are training one point at a time.</div><code><pre><span class='one-line'>  <span class="n">count</span> <span class="o">=</span> <span class="o">(</span><span class="n">count</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">%</span> <span class="n">training</span><span class="o">.</span><span class="na">length</span><span class="o">;</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">stroke</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>    <span class="kt">int</span> <span class="n">guess</span> <span class="o">=</span> <span class="n">ptron</span><span class="o">.</span><span class="na">feedforward</span><span class="o">(</span><span class="n">training</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">inputs</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Show the classification—no fill for -1, black for +1.</div><code><pre><span class='one-line'>    <span class="k">if</span> <span class="o">(</span><span class="n">guess</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">noFill</span><span class="o">();</span></span>
<span class='one-line'>    <span class="k">else</span>           <span class="nf">fill</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>    <span class="n">ellipse</span><span class="o">(</span><span class="n">training</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">inputs</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">training</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">inputs</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">8</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><div class="example">
  <a id="chapter10_exercise1" style="display: block;"></a><h4 id="exercise-101">Exercise 10.1</h4><p>Instead of using the supervised learning model above, can you train the neural network to find the right weights by using a genetic algorithm?</p>

</div><div class="example">
  <a id="chapter10_exercise2" style="display: block;"></a><h4 id="exercise-102">Exercise 10.2</h4><p>Visualize the perceptron itself. Draw the inputs, the processing node, and the output.</p>

</div></section><section><a id="chapter10_section5" style="display: block;"></a><h3 id="105-a-steering-perceptron">10.5  A Steering Perceptron</h3><p><a id="perceptronsteering-and-83158e00-253f-0130-be0f-7cd1c3f718ad" style="display: block;"></a><a id="steering-behaviorsperceptron-for-8315a010-253f-0130-be10-7cd1c3f718ad" style="display: block;"></a><a id="steering-perceptron-8315baf0-253f-0130-be11-7cd1c3f718ad" style="display: block;"></a></p>
<p>While classifying points according to their position above or below a line was a useful demonstration of the perceptron in action, it doesn’t have much practical relevance to the other examples throughout this book.  In this section, we’ll take the concepts of a perceptron (array of inputs, single output), apply it to steering behaviors, and demonstrate reinforcement learning along the way.</p>
<p>We are now going to take significant creative license with the concept of a neural network. This will allow us to stick with the basics and avoid some of the highly complex algorithms associated with more sophisticated neural networks.   Here we’re not so concerned with following rules outlined in artificial intelligence textbooks—we’re just hoping to make something interesting and brain-like.</p>
<p>Remember our good friend the <span class="klass">Vehicle</span> class?  You know, that one for making objects with a location, velocity, and acceleration?  That could obey Newton’s laws with an <span class="function">applyForce()</span> function and move around the window according to a variety of steering rules?</p>
<p>What if we added one more variable to our <span class="klass">Vehicle</span> class?</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>class Vehicle {

  // Giving the vehicle a brain!
  Perceptron brain;

  PVector location;
  PVector velocity;
  PVector acceleration;
  //etc...</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kd">class</span> <span class="nc">Vehicle</span> <span class="o">{</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Giving the vehicle a brain!</div><code><pre><span class='one-line'>  <span class="n">Perceptron</span> <span class="n">brain</span><span class="o">;</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">PVector</span> <span class="n">location</span><span class="o">;</span></span>
<span class='one-line'>  <span class="n">PVector</span> <span class="n">velocity</span><span class="o">;</span></span>
<span class='one-line'>  <span class="n">PVector</span> <span class="n">acceleration</span><span class="o">;</span></span>
<span class='one-line'>  <span class="c1">//etc...</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Here’s our scenario.  Let’s say we have a Processing sketch with an <span class="klass">ArrayList</span> of targets and a single vehicle.</p>
<a id="chapter10_figure09" style="display: block;"></a><div class="image-container " >
	
	<img src="imgs/chapter10/ch10_09.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 10.9</p>
</div>
<p>Let’s say that the vehicle seeks all of the targets.   According to the principles of Chapter 6, we would next write a function that calculates a steering force towards each target, applying each force one at a time to the object’s acceleration.   Assuming the targets are an <span class="klass">ArrayList</span> of <span class="klass">PVector</span> objects, it would look something like:</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>  void seek(ArrayList<PVector> targets) {
    for (PVector target : targets) {
      // For every target, apply a steering force towards the target.
      PVector force = seek(targets.get(i));
      applyForce(force);
    }
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">seek</span><span class="o">(</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">PVector</span><span class="o">&gt;</span> <span class="n">targets</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="k">for</span> <span class="o">(</span><span class="n">PVector</span> <span class="n">target</span> <span class="o">:</span> <span class="n">targets</span><span class="o">)</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>For every target, apply a steering force towards the target.</div><code><pre><span class='one-line'>      <span class="n">PVector</span> <span class="n">force</span> <span class="o">=</span> <span class="n">seek</span><span class="o">(</span><span class="n">targets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span></span>
<span class='one-line'>      <span class="n">applyForce</span><span class="o">(</span><span class="n">force</span><span class="o">);</span></span>
<span class='one-line'>    <span class="o">}</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>In Chapter 6, we also examined how we could create more dynamic simulations by weighting each steering force according to some rule.  For example, we could say that the farther you are from a target, the stronger the force.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea> void seek(ArrayList<PVector> targets) {
    for (PVector target : targets) {
      PVector force = seek(targets.get(i));
      float d = PVector.dist(target,location);
      float weight = map(d,0,width,0,5);
      // Weighting each steering force individually
      force.mult(weight);
      applyForce(force);
    }
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'> <span class="kt">void</span> <span class="nf">seek</span><span class="o">(</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">PVector</span><span class="o">&gt;</span> <span class="n">targets</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="k">for</span> <span class="o">(</span><span class="n">PVector</span> <span class="n">target</span> <span class="o">:</span> <span class="n">targets</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>      <span class="n">PVector</span> <span class="n">force</span> <span class="o">=</span> <span class="n">seek</span><span class="o">(</span><span class="n">targets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span></span>
<span class='one-line'>      <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">PVector</span><span class="o">.</span><span class="na">dist</span><span class="o">(</span><span class="n">target</span><span class="o">,</span><span class="n">location</span><span class="o">);</span></span>
<span class='one-line'>      <span class="kt">float</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">map</span><span class="o">(</span><span class="n">d</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">width</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">5</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Weighting each steering force individually</div><code><pre><span class='one-line'>      <span class="n">force</span><span class="o">.</span><span class="na">mult</span><span class="o">(</span><span class="n">weight</span><span class="o">);</span></span>
<span class='one-line'>      <span class="n">applyForce</span><span class="o">(</span><span class="n">force</span><span class="o">);</span></span>
<span class='one-line'>    <span class="o">}</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>But what if instead we could ask our brain (i.e. perceptron) to take in all the forces as an input, process them according to weights of the perceptron inputs, and generate an output steering force?   What if we could instead say:</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>  void seek(ArrayList<PVector> targets) {

    // Make an array of inputs for our brain.
    PVector[] forces = new PVector[targets.size()];

    for (int i = 0; i < forces.length; i++) {
      // Fill the array with a steering force
      // for each target.
      forces[i] = seek(targets.get(i));
    }

    //[full] Ask our brain for a result and apply that as the force!
    PVector output = brain.process(forces);
    applyForce(output);
    //[end]
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">seek</span><span class="o">(</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">PVector</span><span class="o">&gt;</span> <span class="n">targets</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Make an array of inputs for our brain.</div><code><pre><span class='one-line'>    <span class="n">PVector</span><span class="o">[]</span> <span class="n">forces</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PVector</span><span class="o">[</span><span class="n">targets</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span></span>
<span class='one-line'> </span>
<span class='one-line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">forces</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Fill the array with a steering force
for each target.</div><code><pre><span class='one-line'>      <span class="n">forces</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">seek</span><span class="o">(</span><span class="n">targets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span></span>
<span class='one-line'>    <span class="o">}</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Ask our brain for a result and apply that as the force!</div><code><pre><span class='one-line'>    <span class="n">PVector</span> <span class="n">output</span> <span class="o">=</span> <span class="n">brain</span><span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="n">forces</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">applyForce</span><span class="o">(</span><span class="n">output</span><span class="o">);</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>In other words, instead of weighting and accumulating the forces inside our vehicle, we simply pass an array of forces to the vehicle’s “brain” object and allow the brain to weight and sum the forces for us.  The output is then applied as a steering force.  This opens up a range of possibilities. A vehicle could make decisions as to how to steer on its own, learning from its mistakes and responding to stimuli in its environment.  Let’s see how this works.</p>
<p>We can use the line classification perceptron as a model, with one important difference—the inputs are not single numbers, but vectors!     Let’s look at how the <span class="function">feedforward()</span> function works in our vehicle’s perceptron, alongside the one from our previous example.</p>
<table class="codewide">
<tr>
<th>Vehicle PVector inputs</th>
<th>Line float inputs</th>
</tr>
<tr>
<td>
<pre>
PVector feedforward(PVector[] forces) {
  // Sum is a PVector.
  <b>PVector sum = new PVector();</b>
  for (int i = 0; i &lt; weights.length; i++) {
    // Vector addition and multiplication
    <b>forces[i].mult(weights[i]);</b>
    <b>sum.add(forces[i]);</b>
  }
  // No activation function
  <b>return sum;</b>
}
</pre>
</td>
<td>
<pre>
int feedforward(float[] inputs) {
  // Sum is a float.
  <b>float sum = 0;</b>
  for (int i = 0; i &lt; weights.length; i++) {
    // Scalar addition and multiplication
    <b>sum += inputs[i]*weights[i];</b>

  }
  // Activation function
  <b>return activate(sum);</b>
}
</pre>
</td>
</tr>

</table><p>Note how these two functions implement nearly identical algorithms, with two differences:</p>
<div class="list">
	
	<ol class="arabic">
		
			<li><p><strong><em>Summing PVectors.</em></strong>  Instead of a series of numbers added together, each input is a <span class="klass">PVector</span> and must be multiplied by the weight and added to a sum according to the mathematical <span class="klass">PVector</span> functions.
</p>
</li>
		
			<li><p><strong><em>No activation function.</em></strong>   In this case, we’re taking the result and applying it directly as a steering force for the vehicle, so we’re not asking for a simple boolean value that classifies it in one of two categories.  Rather, we’re asking for raw output itself, the resulting overall force.
</p>
</li>
		
	</ol>
</div><p><a id="reinforcement-learningneural-networks-83166420-253f-0130-be12-7cd1c3f718ad" style="display: block;"></a><a id="steering-perceptronreinforcement-learningneural-networks-831673c0-253f-0130-be13-7cd1c3f718ad" style="display: block;"></a></p>
<p>Once the resulting steering force has been applied, it’s time to give feedback to the brain, i.e. <em>reinforcement learning</em>.   Was the decision to steer in that particular direction a good one or a bad one?  Presumably if some of the targets were predators (resulting in being eaten) and some of the targets were food (resulting in greater health), the network would adjust its weights in order to steer away from the predators and towards the food.</p>
<p>Let’s take a simpler example, where the vehicle simply wants to stay close to the center of the window.    We’ll train the brain as follows:</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>    PVector desired = new PVector(width/2,height/2);
    PVector error = PVector.sub(desired, location);
    brain.train(forces,error);</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>    <span class="n">PVector</span> <span class="n">desired</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PVector</span><span class="o">(</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">PVector</span> <span class="n">error</span> <span class="o">=</span> <span class="n">PVector</span><span class="o">.</span><span class="na">sub</span><span class="o">(</span><span class="n">desired</span><span class="o">,</span> <span class="n">location</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">brain</span><span class="o">.</span><span class="na">train</span><span class="o">(</span><span class="n">forces</span><span class="o">,</span><span class="n">error</span><span class="o">);</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><a id="chapter10_figure10" style="display: block;"></a><div class="image-container half-width-right" >
	
	<img src="imgs/chapter10/ch10_10.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 10.10</p>
</div>
<p>Here we are passing the brain a copy of all the inputs (which it will need for error correction) as well as an observation about its environment: a <span class="klass">PVector</span> that points from its current location to where it desires to be.  This <span class="klass">PVector</span> essentially serves as the error—the longer the <span class="klass">PVector</span>, the worse the vehicle is performing; the shorter, the better.</p>
<p>The brain can then apply this “error” vector (which has two error values, one for <span class="var">x</span> and one for <span class="var">y</span>) as a means for adjusting the weights, just as we did in the line classification example.</p>
<table class="codewide">
<tr>
<th>Training the Vehicle</th>
<th>Training the Line Classifier</th>
</tr>
<tr>
<td>
<pre>
void train(PVector[] forces, PVector error) {




  for (int i = 0; i &lt; weights.length; i++) {
    weights[i] += c*error.x*forces[i].x;
    weights[i] += c*error.y*forces[i].y;
  }
}
</pre>
</td>
<td>
<pre>
void train(float[] inputs, int desired) {

  int guess = feedforward(inputs);
  float error = desired - guess;

  for (int i = 0; i &lt; weights.length; i++) {
    weights[i] += c * error * inputs[i];

  }
}
</pre>
</td>
</tr>

</table><p>Because the vehicle observes its own error, there is no need to calculate one; we can simply receive the error as an argument.  Notice how the change in weight is processed twice, once for the error along the x-axis and once for the y-axis.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>weights[i] += c*error.x*forces[i].x;
weights[i] += c*error.y*forces[i].y;</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="n">weights</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">c</span><span class="o">*</span><span class="n">error</span><span class="o">.</span><span class="na">x</span><span class="o">*</span><span class="n">forces</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">x</span><span class="o">;</span></span>
<span class='one-line'><span class="n">weights</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+=</span> <span class="n">c</span><span class="o">*</span><span class="n">error</span><span class="o">.</span><span class="na">y</span><span class="o">*</span><span class="n">forces</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">y</span><span class="o">;</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>We can now look at the <span class="klass">Vehicle</span> class and see how the <span class="function">steer</span> function uses a perceptron to control the overall steering force.   The new content from this chapter is highlighted.</p>
<div class="image-container screenshot" >
	
	<canvas data-processing-sources="../NOC%20examples%20-%20processing/chp10/NOC_10_02_SeekingNeural/NOC_10_02_SeekingNeural.pde ../NOC%20examples%20-%20processing/chp10/NOC_10_02_SeekingNeural/Perceptron.pde ../NOC%20examples%20-%20processing/chp10/NOC_10_02_SeekingNeural/Vehicle.pde" class="screenshot">
		<p>Your browser does not support the canvas tag.</p>
	</canvas>
  <div class="sketch-controls">
    <button class="reset">RESET</button>
    <button class="pause">PAUSE</button>
  </div>
	
	
</div>
<p><a id="chapter10_example2" style="display: block;"></a><span class="example">Example 10.2: Perceptron steering</span></p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>class Vehicle {

  // The Vehicle now has a brain.
  Perceptron brain; //[bold]

  //[full] Same old variables for physics
  PVector location;
  PVector velocity;
  PVector acceleration;
  float maxforce;
  float maxspeed;
  //[end]

  // The Vehicle creates a perceptron with n inputs and a learning constant.
  Vehicle(int n, float x, float y) {
    brain = new Perceptron(n,0.001); //[bold]
    acceleration = new PVector(0,0);
    velocity = new PVector(0,0);
    location = new PVector(x,y);
    maxspeed = 4;
    maxforce = 0.1;
  }

  //[full] Same old update() function
  void update() {
    velocity.add(acceleration);
    velocity.limit(maxspeed);
    location.add(velocity);
    acceleration.mult(0);
  }
  //[end]

  //[full] Same old applyForce() function
  void applyForce(PVector force) {
    acceleration.add(force);
  }
  //[end]

  void steer(ArrayList<PVector> targets) {
    PVector[] forces = new PVector[targets.size()];

    for (int i = 0; i < forces.length; i++) {
      forces[i] = seek(targets.get(i));
    }
    // All the steering forces are inputs.
    PVector result = brain.feedforward(forces); //[bold]

    // The result is applied.
    applyForce(result);

    //[offset-down] The brain is trained according to
    // the distance to the center.
    PVector desired = new PVector(width/2,height/2); //[bold]
    PVector error = PVector.sub(desired, location); //[bold]
    brain.train(forces,error); //[bold]

  }


  //[full] Same old seek() function
  PVector seek(PVector target) {
    PVector desired = PVector.sub(target,location);
    desired.normalize();
    desired.mult(maxspeed);
    PVector steer = PVector.sub(desired,velocity);
    steer.limit(maxforce);
    return steer;
  }
  //[end]

}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kd">class</span> <span class="nc">Vehicle</span> <span class="o">{</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The Vehicle now has a brain.</div><code><pre><span class='one-line'>  <strong><span class="n">Perceptron</span> <span class="n">brain</span><span class="o">;</span></strong></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Same old variables for physics</div><code><pre><span class='one-line'>  <span class="n">PVector</span> <span class="n">location</span><span class="o">;</span></span>
<span class='one-line'>  <span class="n">PVector</span> <span class="n">velocity</span><span class="o">;</span></span>
<span class='one-line'>  <span class="n">PVector</span> <span class="n">acceleration</span><span class="o">;</span></span>
<span class='one-line'>  <span class="kt">float</span> <span class="n">maxforce</span><span class="o">;</span></span>
<span class='one-line'>  <span class="kt">float</span> <span class="n">maxspeed</span><span class="o">;</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The Vehicle creates a perceptron with n inputs and a learning constant.</div><code><pre><span class='one-line'>  <span class="n">Vehicle</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">float</span> <span class="n">x</span><span class="o">,</span> <span class="kt">float</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <strong><span class="n">brain</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Perceptron</span><span class="o">(</span><span class="n">n</span><span class="o">,</span><span class="mf">0.001</span><span class="o">);</span></strong></span>
<span class='one-line'>    <span class="n">acceleration</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PVector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">velocity</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PVector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">location</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PVector</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">maxspeed</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span></span>
<span class='one-line'>    <span class="n">maxforce</span> <span class="o">=</span> <span class="mf">0.1</span><span class="o">;</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Same old update() function</div><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">update</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">velocity</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">acceleration</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">velocity</span><span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="n">maxspeed</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">location</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">velocity</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">acceleration</span><span class="o">.</span><span class="na">mult</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Same old applyForce() function</div><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">applyForce</span><span class="o">(</span><span class="n">PVector</span> <span class="n">force</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">acceleration</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">force</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'> </span>
<span class='one-line'>  <span class="kt">void</span> <span class="nf">steer</span><span class="o">(</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">PVector</span><span class="o">&gt;</span> <span class="n">targets</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">PVector</span><span class="o">[]</span> <span class="n">forces</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PVector</span><span class="o">[</span><span class="n">targets</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span></span>
<span class='one-line'> </span>
<span class='one-line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">forces</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span></span>
<span class='one-line'>      <span class="n">forces</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">seek</span><span class="o">(</span><span class="n">targets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span></span>
<span class='one-line'>    <span class="o">}</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>All the steering forces are inputs.</div><code><pre><span class='one-line'>    <strong><span class="n">PVector</span> <span class="n">result</span> <span class="o">=</span> <span class="n">brain</span><span class="o">.</span><span class="na">feedforward</span><span class="o">(</span><span class="n">forces</span><span class="o">);</span></strong></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The result is applied.</div><code><pre><span class='one-line'>    <span class="n">applyForce</span><span class="o">(</span><span class="n">result</span><span class="o">);</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair offset-down'><div class='code-comment '> The brain is trained according to
the distance to the center.</div><code><pre><span class='one-line'>    <strong><span class="n">PVector</span> <span class="n">desired</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PVector</span><span class="o">(</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span></strong></span>
<span class='one-line'>    <strong><span class="n">PVector</span> <span class="n">error</span> <span class="o">=</span> <span class="n">PVector</span><span class="o">.</span><span class="na">sub</span><span class="o">(</span><span class="n">desired</span><span class="o">,</span> <span class="n">location</span><span class="o">);</span></strong></span>
<span class='one-line'>    <strong><span class="n">brain</span><span class="o">.</span><span class="na">train</span><span class="o">(</span><span class="n">forces</span><span class="o">,</span><span class="n">error</span><span class="o">);</span></strong></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'> </span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Same old seek() function</div><code><pre><span class='one-line'>  <span class="n">PVector</span> <span class="nf">seek</span><span class="o">(</span><span class="n">PVector</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">PVector</span> <span class="n">desired</span> <span class="o">=</span> <span class="n">PVector</span><span class="o">.</span><span class="na">sub</span><span class="o">(</span><span class="n">target</span><span class="o">,</span><span class="n">location</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">desired</span><span class="o">.</span><span class="na">normalize</span><span class="o">();</span></span>
<span class='one-line'>    <span class="n">desired</span><span class="o">.</span><span class="na">mult</span><span class="o">(</span><span class="n">maxspeed</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">PVector</span> <span class="n">steer</span> <span class="o">=</span> <span class="n">PVector</span><span class="o">.</span><span class="na">sub</span><span class="o">(</span><span class="n">desired</span><span class="o">,</span><span class="n">velocity</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">steer</span><span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="n">maxforce</span><span class="o">);</span></span>
<span class='one-line'>    <span class="k">return</span> <span class="n">steer</span><span class="o">;</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'> </span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><div class="example">
  <a id="chapter10_exercise3" style="display: block;"></a><h4 id="exercise-103">Exercise 10.3</h4><p>Visualize the weights of the network.  Try mapping each target’s corresponding weight to its brightness.</p>

</div><div class="example">
  <a id="chapter10_exercise4" style="display: block;"></a><h4 id="exercise-104">Exercise 10.4</h4><p>Try different rules for reinforcement learning.  What if some targets are desirable and some are undesirable?</p>

</div></section><section><a id="chapter10_section6" style="display: block;"></a><h3 id="106-its-a-network-remember">10.6  It’s a “Network,” Remember?</h3><p><a id="linearly-separable-problems-8316fd10-253f-0130-be14-7cd1c3f718ad" style="display: block;"></a><a id="perceptronlinearly-separable-problems-and-83170cb0-253f-0130-be15-7cd1c3f718ad" style="display: block;"></a></p>
<p>Yes, a perceptron can have multiple inputs, but it is still a lonely neuron.  The power of neural networks comes in the networking itself.   Perceptrons are, sadly, incredibly limited in their abilities.    If you read an AI textbook, it will say that a perceptron can only solve <strong><em>linearly separable</em></strong> problems.  What’s a linearly separable problem?  Let’s take a look at our first example, which determined whether points were on one side of a line or the other.</p>
<a id="chapter10_figure11" style="display: block;"></a><div class="image-container " >
	
	<img src="imgs/chapter10/ch10_11.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 10.11</p>
</div>
<p>On the left of Figure 10.11, we have classic linearly separable data.  Graph all of the possibilities; if you can classify the data with a straight line, then it is linearly separable.  On the right, however, is non-linearly separable data.  You can’t draw a straight line to separate the black dots from the gray ones.</p>
<p><a id="exclusive-or-xor-831733e0-253f-0130-be16-7cd1c3f718ad" style="display: block;"></a><a id="non-linearly-separable-problems-83174430-253f-0130-be17-7cd1c3f718ad" style="display: block;"></a><a id="xor-exclusive-or-831753f0-253f-0130-be18-7cd1c3f718ad" style="display: block;"></a></p>
<p>One of the simplest examples of a non-linearly separable problem is <em>XOR</em>, or “exclusive or.”  We’re all familiar with <em>AND</em>.  For <em>A</em> <em>AND</em> <em>B</em> to be true, both <em>A</em> and <em>B</em> must be true.  With <em>OR</em>, either <em>A</em> or <em>B</em> can be true for <em>A</em> <em>OR</em> <em>B</em> to evaluate as true. These are both linearly separable problems.  Let’s look at the solution space, a “truth table.”</p>
<a id="chapter10_figure12" style="display: block;"></a><div class="image-container " >
	
	<img src="imgs/chapter10/ch10_12.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 10.12</p>
</div>
<p>See how you can draw a line to separate the true outputs from the false ones?</p>
<p><em>XOR</em> is the equivalent of <em>OR</em> and <em>NOT AND</em>.  In other words, <em>A</em> <em>XOR</em> <em>B</em> only evaluates to true if one of them is true.  If both are false or both are true, then we get false.  Take a look at the following truth table.</p>
<a id="chapter10_figure13" style="display: block;"></a><div class="image-container " >
	
	<img src="imgs/chapter10/ch10_13.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 10.13</p>
</div>
<p>This is not linearly separable.  Try to draw a straight line to separate the true outputs from the false ones—you can’t!</p>
<p><a id="neural-networksnetworks-of-perceptrons-8317dc90-253f-0130-be19-7cd1c3f718ad" style="display: block;"></a><a id="perceptronnetworks-of-8317f010-253f-0130-be1a-7cd1c3f718ad" style="display: block;"></a></p>
<p>So perceptrons can’t even solve something as simple as <em>XOR</em>.  But what if we made a network out of two perceptrons?  If one perceptron can solve <em>OR</em> and one perceptron can solve <em>NOT AND</em>, then two perceptrons combined can solve <em>XOR</em>.</p>
<a id="chapter10_figure14" style="display: block;"></a><div class="image-container " >
	
	<img src="imgs/chapter10/ch10_14.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 10.14</p>
</div>
<p>The above diagram is known as a <em>multi-layered perceptron</em>, a network of many neurons.   Some are input neurons and receive the inputs, some are part of what’s called a “hidden” layer (as they are connected to neither the inputs nor the outputs of the network directly), and then there are the output neurons, from which we read the results.</p>
<p>Training these networks is much more complicated.  With the simple perceptron, we could easily evaluate how to change the weights according to the error. But here there are so many different connections, each in a different layer of the network. How does one know how much each neuron or connection contributed to the overall error of the network?</p>
<p><a id="backpropagation-83183aa0-253f-0130-be1b-7cd1c3f718ad" style="display: block;"></a><a id="neural-networksbackpropagation-831849c0-253f-0130-be1c-7cd1c3f718ad" style="display: block;"></a></p>
<p>The solution to optimizing weights of a multi-layered network is known as <strong><em>backpropagation</em></strong>.  The output of the network is generated in the same manner as a perceptron.   The inputs multiplied by the weights are summed and fed forward through the network.  The difference here is that they pass through additional layers of neurons before reaching the output. Training the network (i.e. adjusting the weights) also involves taking the error (desired result - guess).  The error, however, must be fed backwards through the network. The final error ultimately adjusts the weights of all the connections.</p>
<p>Backpropagation is a bit beyond the scope of this book and involves a fancier activation function (called the sigmoid function) as well as some basic calculus.  If you are interested in how backpropagation works, check the book website (and GitHub repository) for an example that solves <em>XOR</em> using a multi-layered feed forward network with backpropagation.</p>
<p>Instead, here we’ll focus on a code framework for building the visual architecture of a network.  We’ll make <span class="klass">Neuron</span> objects and <span class="klass">Connection</span> objects from which a <span class="klass">Network</span> object can be created and animated to show the feed forward process.   This will closely resemble some of the force-directed graph examples we examined in Chapter 5 (toxiclibs).</p>
</section><section><a id="chapter10_section7" style="display: block;"></a><h3 id="107-neural-network-diagrams">10.7  Neural Network Diagrams</h3><p><a id="neural-networksdiagramming-831890e0-253f-0130-be1d-7cd1c3f718ad" style="display: block;"></a></p>
<p>Our goal will be to create the following simple network diagram:</p>
<a id="chapter10_figure15" style="display: block;"></a><div class="image-container " >
	
	<img src="imgs/chapter10/ch10_15.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 10.15</p>
</div>
<p>The primary building block for this diagram is a neuron.  For the purpose of this example, the <span class="klass">Neuron</span> class describes an entity with an <em>(x,y)</em> location.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>// An incredibly simple Neuron class stores and displays the location of a single neuron.
class Neuron {
  PVector location;

  Neuron(float x, float y) {
    location = new PVector(x, y);
  }

  void display() {
    stroke(0);
    fill(0);
    ellipse(location.x, location.y, 16, 16);
  }
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair '><div class='code-comment '>An incredibly simple Neuron class stores and displays the location of a single neuron.</div><code><pre><span class='one-line'><span class="kd">class</span> <span class="nc">Neuron</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">PVector</span> <span class="n">location</span><span class="o">;</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">Neuron</span><span class="o">(</span><span class="kt">float</span> <span class="n">x</span><span class="o">,</span> <span class="kt">float</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">location</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PVector</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="kt">void</span> <span class="nf">display</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">stroke</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">fill</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">ellipse</span><span class="o">(</span><span class="n">location</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">location</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">16</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>The <span class="klass">Network</span> class can then manage an <span class="klass">ArrayList</span> of neurons, as well as have its own location (so that each neuron is drawn relative to the network’s center).  This is particle systems 101.  We have a single element (a neuron) and a network (a “system” of many neurons).</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>//[full] A Network is a list of neurons.
class Network {
  ArrayList<Neuron> neurons;
  //[end]
  PVector location;

  Network(float x, float y) {
    location = new PVector(x,y);
    neurons = new ArrayList<Neuron>();
  }

  //[full] We can add an neuron to the network.
  void addNeuron(Neuron n) {
    neurons.add(n);
  }
  //[end]

  //[full] We can draw the entire network.
  void display() {
    pushMatrix();
    translate(location.x, location.y);
    for (Neuron n : neurons) {
      n.display();
    }
    popMatrix();
  }
  //[end]
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> A Network is a list of neurons.</div><code><pre><span class='one-line'><span class="kd">class</span> <span class="nc">Network</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Neuron</span><span class="o">&gt;</span> <span class="n">neurons</span><span class="o">;</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="n">PVector</span> <span class="n">location</span><span class="o">;</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">Network</span><span class="o">(</span><span class="kt">float</span> <span class="n">x</span><span class="o">,</span> <span class="kt">float</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">location</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PVector</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">neurons</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Neuron</span><span class="o">&gt;();</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> We can add an neuron to the network.</div><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">addNeuron</span><span class="o">(</span><span class="n">Neuron</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">neurons</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">n</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> We can draw the entire network.</div><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">display</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">pushMatrix</span><span class="o">();</span></span>
<span class='one-line'>    <span class="n">translate</span><span class="o">(</span><span class="n">location</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">location</span><span class="o">.</span><span class="na">y</span><span class="o">);</span></span>
<span class='one-line'>    <span class="k">for</span> <span class="o">(</span><span class="n">Neuron</span> <span class="n">n</span> <span class="o">:</span> <span class="n">neurons</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>      <span class="n">n</span><span class="o">.</span><span class="na">display</span><span class="o">();</span></span>
<span class='one-line'>    <span class="o">}</span></span>
<span class='one-line'>    <span class="n">popMatrix</span><span class="o">();</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Now we can pretty easily make the diagram above.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>Network network;

void setup() {
  size(640, 360);
  // Make a Network.
  network = new Network(width/2,height/2);

  //[full] Make the Neurons.
  Neuron a = new Neuron(-200,0);
  Neuron b = new Neuron(0,100);
  Neuron c = new Neuron(0,-100);
  Neuron d = new Neuron(200,0);
  //[end]

  //[full] Add the Neurons to the network.
  network.addNeuron(a);
  network.addNeuron(b);
  network.addNeuron(c);
  network.addNeuron(d);
  //[end]
}

void draw() {
  background(255);
  // Show the network.
  network.display();
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="n">Network</span> <span class="n">network</span><span class="o">;</span></span>
<span class='one-line'> </span>
<span class='one-line'><span class="kt">void</span> <span class="nf">setup</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">size</span><span class="o">(</span><span class="mi">640</span><span class="o">,</span> <span class="mi">360</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Make a Network.</div><code><pre><span class='one-line'>  <span class="n">network</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Network</span><span class="o">(</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Make the Neurons.</div><code><pre><span class='one-line'>  <span class="n">Neuron</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Neuron</span><span class="o">(-</span><span class="mi">200</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">Neuron</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Neuron</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">100</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">Neuron</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Neuron</span><span class="o">(</span><span class="mi">0</span><span class="o">,-</span><span class="mi">100</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">Neuron</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Neuron</span><span class="o">(</span><span class="mi">200</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Add the Neurons to the network.</div><code><pre><span class='one-line'>  <span class="n">network</span><span class="o">.</span><span class="na">addNeuron</span><span class="o">(</span><span class="n">a</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">network</span><span class="o">.</span><span class="na">addNeuron</span><span class="o">(</span><span class="n">b</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">network</span><span class="o">.</span><span class="na">addNeuron</span><span class="o">(</span><span class="n">c</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">network</span><span class="o">.</span><span class="na">addNeuron</span><span class="o">(</span><span class="n">d</span><span class="o">);</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="o">}</span></span>
<span class='one-line'> </span>
<span class='one-line'><span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">background</span><span class="o">(</span><span class="mi">255</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Show the network.</div><code><pre><span class='one-line'>  <span class="n">network</span><span class="o">.</span><span class="na">display</span><span class="o">();</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>The above yields:</p>
<div class="image-container screenshot" >
	
	<img src="imgs/chapter10/ch10_ex03a.png" alt="Nature of Code Image" />
	
	
</div>
<p>What’s missing, of course, is the connection.   We can consider a <span class="klass">Connection</span> object to be made up of three elements, two neurons (from <span class="klass">Neuron</span> <span class="var">a</span> to <span class="klass">Neuron</span> <span class="var">b</span>) and a <span class="var">weight</span>.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>class Connection {
  //[full] A connection is between two neurons.
  Neuron a;
  Neuron b;
  //[end]
  // A connection has a weight.
  float weight;

  Connection(Neuron from, Neuron to,float w) {
    weight = w;
    a = from;
    b = to;
  }

  // A connection is drawn as a line.
  void display() {
    stroke(0);
    strokeWeight(weight*4);
    line(a.location.x, a.location.y, b.location.x, b.location.y);
  }
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kd">class</span> <span class="nc">Connection</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> A connection is between two neurons.</div><code><pre><span class='one-line'>  <span class="n">Neuron</span> <span class="n">a</span><span class="o">;</span></span>
<span class='one-line'>  <span class="n">Neuron</span> <span class="n">b</span><span class="o">;</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair '><div class='code-comment '>
A connection has a weight.</div><code><pre><span class='one-line'>  <span class="kt">float</span> <span class="n">weight</span><span class="o">;</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">Connection</span><span class="o">(</span><span class="n">Neuron</span> <span class="n">from</span><span class="o">,</span> <span class="n">Neuron</span> <span class="n">to</span><span class="o">,</span><span class="kt">float</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">weight</span> <span class="o">=</span> <span class="n">w</span><span class="o">;</span></span>
<span class='one-line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">from</span><span class="o">;</span></span>
<span class='one-line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">to</span><span class="o">;</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>A connection is drawn as a line.</div><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">display</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">stroke</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">strokeWeight</span><span class="o">(</span><span class="n">weight</span><span class="o">*</span><span class="mi">4</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">line</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">y</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Once we have the idea of a <span class="klass">Connection</span> object, we can write a function (let’s put it inside the <span class="klass">Network</span> class) that connects two neurons together—the goal being that in addition to making the neurons in <span class="function">setup()</span>, we can also connect them.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void setup() {
  size(640, 360);
  network = new Network(width/2,height/2);

  Neuron a = new Neuron(-200,0);
  Neuron b = new Neuron(0,100);
  Neuron c = new Neuron(0,-100);
  Neuron d = new Neuron(200,0);

  // Making connections between the neurons
  network.connect(a,b);
  network.connect(a,c);
  network.connect(b,d);
  network.connect(c,d);

  network.addNeuron(a);
  network.addNeuron(b);
  network.addNeuron(c);
  network.addNeuron(d);
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">setup</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">size</span><span class="o">(</span><span class="mi">640</span><span class="o">,</span> <span class="mi">360</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">network</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Network</span><span class="o">(</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">Neuron</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Neuron</span><span class="o">(-</span><span class="mi">200</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">Neuron</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Neuron</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">100</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">Neuron</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Neuron</span><span class="o">(</span><span class="mi">0</span><span class="o">,-</span><span class="mi">100</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">Neuron</span> <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Neuron</span><span class="o">(</span><span class="mi">200</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Making connections between the neurons</div><code><pre><span class='one-line'>  <span class="n">network</span><span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">network</span><span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">c</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">network</span><span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="n">b</span><span class="o">,</span><span class="n">d</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">network</span><span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="n">c</span><span class="o">,</span><span class="n">d</span><span class="o">);</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">network</span><span class="o">.</span><span class="na">addNeuron</span><span class="o">(</span><span class="n">a</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">network</span><span class="o">.</span><span class="na">addNeuron</span><span class="o">(</span><span class="n">b</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">network</span><span class="o">.</span><span class="na">addNeuron</span><span class="o">(</span><span class="n">c</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">network</span><span class="o">.</span><span class="na">addNeuron</span><span class="o">(</span><span class="n">d</span><span class="o">);</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>The <span class="klass">Network</span> class therefore needs a new function called <span class="function">connect()</span>, which makes a <span class="klass">Connection</span> object between the two specified neurons.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>  void connect(Neuron a, Neuron b) {
    // Connection has a random weight.
    Connection c = new Connection(a, b, random(1));

    // But what do we do with the Connection object?
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">connect</span><span class="o">(</span><span class="n">Neuron</span> <span class="n">a</span><span class="o">,</span> <span class="n">Neuron</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Connection has a random weight.</div><code><pre><span class='one-line'>    <span class="n">Connection</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Connection</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">random</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span></span>
<span class='one-line'> </span>
<span class='one-line'>    <span class="c1">// But what do we do with the Connection object?</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Presumably, we might think that the <span class="klass">Network</span> should store an <span class="klass">ArrayList</span> of connections, just like it stores an <span class="klass">ArrayList</span> of neurons.  While useful, in this case such an <span class="klass">ArrayList</span> is not necessary and is missing an important feature that we need.  Ultimately we plan to “feed forward" the neurons through the network, so the <span class="klass">Neuron</span> objects themselves must know to which neurons they are connected in the “forward” direction.  In other words, each neuron should have its own list of <span class="klass">Connection</span> objects.   When <span class="var">a</span> connects to <span class="var">b</span>, we want <span class="var">a</span> to store a reference of that connection so that it can pass its output to <span class="var">b</span> when the time comes.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>  void connect(Neuron a, Neuron b) {
    Connection c = new Connection(a, b, random(1));
    a.addConnection(c);
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">connect</span><span class="o">(</span><span class="n">Neuron</span> <span class="n">a</span><span class="o">,</span> <span class="n">Neuron</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">Connection</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Connection</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">random</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span></span>
<span class='one-line'>    <span class="n">a</span><span class="o">.</span><span class="na">addConnection</span><span class="o">(</span><span class="n">c</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>In some cases, we also might want <span class="klass">Neuron</span> <span class="var">b</span> to know about this connection, but in this particular example we are only going to pass information in one direction.</p>
<p>For this to work, we have to add an <span class="klass">ArrayList</span> of connections to the <span class="klass">Neuron</span> class. Then we implement the <span class="function">addConnection()</span> function that stores the connection in that <span class="klass">ArrayList</span>.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>class Neuron {
  PVector location;

  // The neuron stores its connections.
  ArrayList<Connection> connections;

  Neuron(float x, float y) {
    location = new PVector(x, y);
    connections = new ArrayList<Connection>();
  }

  //[full] Adding a connection to this neuron
  void addConnection(Connection c) {
    connections.add(c);
  }
  //[end]</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kd">class</span> <span class="nc">Neuron</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">PVector</span> <span class="n">location</span><span class="o">;</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The neuron stores its connections.</div><code><pre><span class='one-line'>  <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Connection</span><span class="o">&gt;</span> <span class="n">connections</span><span class="o">;</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">Neuron</span><span class="o">(</span><span class="kt">float</span> <span class="n">x</span><span class="o">,</span> <span class="kt">float</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">location</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PVector</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">connections</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Connection</span><span class="o">&gt;();</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Adding a connection to this neuron</div><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">addConnection</span><span class="o">(</span><span class="n">Connection</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">connections</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">c</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>The neuron’s <span class="function">display()</span> function can draw the connections as well.  And finally, we have our network diagram.</p>
<div class="image-container screenshot" >
	
	<canvas data-processing-sources="../NOC%20examples%20-%20processing/chp10/NOC_10_03_NetworkViz/NOC_10_03_NetworkViz.pde ../NOC%20examples%20-%20processing/chp10/NOC_10_03_NetworkViz/Connection.pde ../NOC%20examples%20-%20processing/chp10/NOC_10_03_NetworkViz/Network.pde ../NOC%20examples%20-%20processing/chp10/NOC_10_03_NetworkViz/Neuron.pde" class="screenshot">
		<p>Your browser does not support the canvas tag.</p>
	</canvas>
  <div class="sketch-controls">
    <button class="reset">RESET</button>
    <button class="pause">PAUSE</button>
  </div>
	
	
</div>
<p><a id="chapter10_example3" style="display: block;"></a><span class="example">Example 10.3: Neural network diagram</span></p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>  void display() {
    stroke(0);
    strokeWeight(1);
    fill(0);
    ellipse(location.x, location.y, 16, 16);

    //[full] Drawing all the connections
    for (Connection c : connections) {
      c.display();
    }
    //[end]
  }
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">display</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">stroke</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">strokeWeight</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">fill</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">ellipse</span><span class="o">(</span><span class="n">location</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">location</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">16</span><span class="o">);</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Drawing all the connections</div><code><pre><span class='one-line'>    <span class="k">for</span> <span class="o">(</span><span class="n">Connection</span> <span class="n">c</span> <span class="o">:</span> <span class="n">connections</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>      <span class="n">c</span><span class="o">.</span><span class="na">display</span><span class="o">();</span></span>
<span class='one-line'>    <span class="o">}</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div></section><section><a id="chapter10_section8" style="display: block;"></a><h3 id="108-animating-feed-forward">10.8  Animating Feed Forward</h3><p><a id="feed-forward-model-neural-networksanimating-8319f010-253f-0130-be1e-7cd1c3f718ad" style="display: block;"></a><a id="neural-networksanimating-831a0340-253f-0130-be1f-7cd1c3f718ad" style="display: block;"></a></p>
<p>An interesting problem to consider is how to visualize the flow of information as it travels throughout a neural network.    Our network is built on the feed forward model, meaning that an input arrives at the first neuron (drawn on the lefthand side of the window) and the output of that neuron flows across the connections to the right until it exits as output from the network itself.</p>
<p>Our first step is to add a function to the network to receive this input, which we’ll make a random number between 0 and 1.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void setup() {
  // All our old network set up code


  // A new function to send in an input
  network.feedforward(random(1));
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">setup</span><span class="o">()</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>All our old network set up code</div><code><pre><span class='one-line'> </span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>A new function to send in an input</div><code><pre><span class='one-line'>  <span class="n">network</span><span class="o">.</span><span class="na">feedforward</span><span class="o">(</span><span class="n">random</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>The network, which manages all the neurons, can choose to which neurons it should apply that input.  In this case, we’ll do something simple and just feed a single input into the first neuron in the <span class="klass">ArrayList</span>, which happens to be the left-most one.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>class Network {

  //[full] A new function to feed an input into the neuron
  void feedforward(float input) {
    Neuron start = neurons.get(0);
    start.feedforward(input);
  }
  //[end]</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kd">class</span> <span class="nc">Network</span> <span class="o">{</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> A new function to feed an input into the neuron</div><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">feedforward</span><span class="o">(</span><span class="kt">float</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">Neuron</span> <span class="n">start</span> <span class="o">=</span> <span class="n">neurons</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">start</span><span class="o">.</span><span class="na">feedforward</span><span class="o">(</span><span class="n">input</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>What did we do?  Well, we made it necessary to add a function called <span class="function">feedforward()</span> in the <span class="klass">Neuron</span> class that will receive the input and process it.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>class Neuron

  void feedforward(float input) {
     // What do we do with the input?

  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kd">class</span> <span class="nc">Neuron</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="kt">void</span> <span class="nf">feedforward</span><span class="o">(</span><span class="kt">float</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>What do we do with the input?</div><code><pre><span class='one-line'> </span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>If you recall from working with our perceptron, the standard task that the processing unit performs is to sum up all of its inputs.  So if our <span class="klass">Neuron</span> class adds a variable called <span class="var">sum</span>, it can simply accumulate the inputs as they are received.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>class Neuron

  int sum = 0; //[bold]

  void feedforward(float input) {
    // Accumulate the sums.
    sum += input; //[bold]
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kd">class</span> <span class="nc">Neuron</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <strong><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span></strong></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="kt">void</span> <span class="nf">feedforward</span><span class="o">(</span><span class="kt">float</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Accumulate the sums.</div><code><pre><span class='one-line'>    <strong><span class="n">sum</span> <span class="o">+=</span> <span class="n">input</span><span class="o">;</span></strong></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>The neuron can then decide whether it should “fire,” or pass an output through any of its connections to the next layer in the network.  Here we can create a really simple activation function: if the sum is greater than 1, fire!</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea> void feedforward(float input) {
    sum += input;
    // Activate the neuron and fire the outputs?
    if (sum > 1) {
      fire();
      // If we’ve fired off our output,
      // we can reset our sum to 0.
      sum = 0;
    }
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'> <span class="kt">void</span> <span class="nf">feedforward</span><span class="o">(</span><span class="kt">float</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">sum</span> <span class="o">+=</span> <span class="n">input</span><span class="o">;</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Activate the neuron and fire the outputs?</div><code><pre><span class='one-line'>    <span class="k">if</span> <span class="o">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>      <span class="n">fire</span><span class="o">();</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>If we’ve fired off our output,
we can reset our sum to 0.</div><code><pre><span class='one-line'>      <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span></span>
<span class='one-line'>    <span class="o">}</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Now, what do we do in the <span class="function">fire()</span> function?  If you recall, each neuron keeps track of its connections to other neurons.  So all we need to do is loop through those connections and <span class="function">feedforward()</span> the neuron’s output.  For this simple example, we’ll just take the neuron’s <span class="var">sum</span> variable and make it the output.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>  void fire() {
    for (Connection c : connections) {
      // The Neuron sends the sum out
      // through all of its connections
      c.feedforward(sum);
    }
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">fire</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="k">for</span> <span class="o">(</span><span class="n">Connection</span> <span class="n">c</span> <span class="o">:</span> <span class="n">connections</span><span class="o">)</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The Neuron sends the sum out
through all of its connections</div><code><pre><span class='one-line'>      <span class="n">c</span><span class="o">.</span><span class="na">feedforward</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span></span>
<span class='one-line'>    <span class="o">}</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p><a id="neural-networksreal-vs-simulated-831a8e70-253f-0130-be20-7cd1c3f718ad" style="display: block;"></a></p>
<p>Here’s where things get a little tricky.  After all, our job here is not to actually make a functioning neural network, but to animate a simulation of one.  If the neural network were just continuing its work, it would instantly pass those inputs (multiplied by the connection’s weight) along to the connected neurons.  We’d say something like:</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>class Connection {

  void feedforward(float val) {
    b.feedforward(val*weight);
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kd">class</span> <span class="nc">Connection</span> <span class="o">{</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="kt">void</span> <span class="nf">feedforward</span><span class="o">(</span><span class="kt">float</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">b</span><span class="o">.</span><span class="na">feedforward</span><span class="o">(</span><span class="n">val</span><span class="o">*</span><span class="n">weight</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>But this is not what we want. What we want to do is draw something that we can see traveling along the connection from <span class="klass">Neuron</span> <span class="var">a</span> to <span class="klass">Neuron</span> <span class="var">b</span>.</p>
<p>Let’s first think about how we might do that. We know the location of <span class="klass">Neuron</span> <span class="var">a</span>; it’s the <span class="klass">PVector</span> <span class="var">a.location</span>.  <span class="klass">Neuron</span> <span class="var">b</span> is located at <span class="var">b.location</span>.  We need to start something moving from <span class="klass">Neuron</span> <span class="var">a</span> by creating another <span class="klass">PVector</span> that will store the path of our traveling data.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>  PVector sender = a.location.get();</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="n">PVector</span> <span class="n">sender</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">get</span><span class="o">();</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Once we have a copy of that location, we can use any of the motion algorithms that we’ve studied throughout this book to move along this path.  Here—let’s pick something very simple and just interpolate from <span class="var">a</span> to <span class="var">b</span>.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>  sender.x = lerp(sender.x, b.location.x, 0.1);
  sender.y = lerp(sender.y, b.location.y, 0.1);</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="n">sender</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">lerp</span><span class="o">(</span><span class="n">sender</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="mf">0.1</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">sender</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">lerp</span><span class="o">(</span><span class="n">sender</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="mf">0.1</span><span class="o">);</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Along with the connection’s line, we can then draw a circle at that location:</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>  stroke(0);
  line(a.location.x, a.location.y, b.location.x, b.location.y);
  fill(0);
  ellipse(sender.x, sender.y, 8, 8); //[bold]</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="n">stroke</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">line</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">y</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">fill</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>  <strong><span class="n">ellipse</span><span class="o">(</span><span class="n">sender</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">sender</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">8</span><span class="o">);</span></strong></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>This resembles the following:</p>
<a id="chapter10_figure16" style="display: block;"></a><div class="image-container " >
	
	<img src="imgs/chapter10/ch10_16.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 10.16</p>
</div>
<p>OK, so that’s how we might move something along the connection.  But how do we know when to do so?   We start this process the moment the <span class="klass">Connection</span> object receives the “feedforward” signal.   We can keep track of this process by employing a simple <span class="klass">boolean</span> to know whether the connection is sending or not.    Before, we had:</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>  void feedforward(float val) {
    b.feedforward(val*weight);
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">feedforward</span><span class="o">(</span><span class="kt">float</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">b</span><span class="o">.</span><span class="na">feedforward</span><span class="o">(</span><span class="n">val</span><span class="o">*</span><span class="n">weight</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Now, instead of sending the value on straight away, we’ll trigger an animation:</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>class Connection {

  boolean sending = false;
  PVector sender;
  float output;

  void feedforward(float val) {
    // Sending is now true.
    sending = true;
    // Start the animation at the location of Neuron A.
    sender = a.location.get();
    // Store the output for when it is actually time to feed it forward.
    output = val*weight;
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kd">class</span> <span class="nc">Connection</span> <span class="o">{</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="kt">boolean</span> <span class="n">sending</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span></span>
<span class='one-line'>  <span class="n">PVector</span> <span class="n">sender</span><span class="o">;</span></span>
<span class='one-line'>  <span class="kt">float</span> <span class="n">output</span><span class="o">;</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="kt">void</span> <span class="nf">feedforward</span><span class="o">(</span><span class="kt">float</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Sending is now true.</div><code><pre><span class='one-line'>    <span class="n">sending</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Start the animation at the location of Neuron A.</div><code><pre><span class='one-line'>    <span class="n">sender</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">get</span><span class="o">();</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Store the output for when it is actually time to feed it forward.</div><code><pre><span class='one-line'>    <span class="n">output</span> <span class="o">=</span> <span class="n">val</span><span class="o">*</span><span class="n">weight</span><span class="o">;</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Notice how our <span class="klass">Connection</span> class now needs three new variables.  We need a <span class="klass">boolean</span> “sending” that starts as false and that will track whether or not the connection is actively sending (i.e. animating).  We need a <span class="klass">PVector</span> “sender” for the location where we’ll draw the traveling dot.  And since we aren’t passing the output along this instant, we’ll need to store it in a variable that will do the job later.</p>
<p>The <span class="function">feedforward()</span> function is called the moment the connection becomes active.  Once it’s active, we’ll need to call another function continuously (each time through <span class="function">draw()</span>), one that will update the location of the traveling data.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea> void update() {
    if (sending) {
      //[full] As long as we’re sending, interpolate our points.
      sender.x = lerp(sender.x, b.location.x, 0.1);
      sender.y = lerp(sender.y, b.location.y, 0.1);
      //[end]
    }
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'> <span class="kt">void</span> <span class="nf">update</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="k">if</span> <span class="o">(</span><span class="n">sending</span><span class="o">)</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> As long as we’re sending, interpolate our points.</div><code><pre><span class='one-line'>      <span class="n">sender</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">lerp</span><span class="o">(</span><span class="n">sender</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="mf">0.1</span><span class="o">);</span></span>
<span class='one-line'>      <span class="n">sender</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">lerp</span><span class="o">(</span><span class="n">sender</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="mf">0.1</span><span class="o">);</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>    <span class="o">}</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>We’re missing a key element, however.  We need to check if the sender has arrived at location b, and if it has, feed forward that output to the next neuron.</p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>  void update() {
    if (sending) {
      sender.x = lerp(sender.x, b.location.x, 0.1);
      sender.y = lerp(sender.y, b.location.y, 0.1);

      // How far are we from neuron b?
      float d = PVector.dist(sender, b.location); //[bold]

      // If we’re close enough (within one pixel) pass on the output. Turn off sending.
      if (d < 1) { //[bold]
        b.feedforward(output); //[bold]
        sending = false; //[bold]
      }
    }
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">update</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="k">if</span> <span class="o">(</span><span class="n">sending</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>      <span class="n">sender</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">lerp</span><span class="o">(</span><span class="n">sender</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="mf">0.1</span><span class="o">);</span></span>
<span class='one-line'>      <span class="n">sender</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">lerp</span><span class="o">(</span><span class="n">sender</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="mf">0.1</span><span class="o">);</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>How far are we from neuron b?</div><code><pre><span class='one-line'>      <strong><span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">PVector</span><span class="o">.</span><span class="na">dist</span><span class="o">(</span><span class="n">sender</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">location</span><span class="o">);</span></strong></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>If we’re close enough (within one pixel) pass on the output. Turn off sending.</div><code><pre><span class='one-line'>      <strong><span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span></strong></span>
<span class='one-line'>        <strong><span class="n">b</span><span class="o">.</span><span class="na">feedforward</span><span class="o">(</span><span class="n">output</span><span class="o">);</span></strong></span>
<span class='one-line'>        <strong><span class="n">sending</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span></strong></span>
<span class='one-line'>      <span class="o">}</span></span>
<span class='one-line'>    <span class="o">}</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Let’s look at the <span class="klass">Connection</span> class all together, as well as our new <span class="function">draw()</span> function.</p>
<div class="image-container screenshot" >
	
	<canvas data-processing-sources="../NOC%20examples%20-%20processing/chp10/NOC_10_04_NetworkAnimation/NOC_10_04_NetworkAnimation.pde ../NOC%20examples%20-%20processing/chp10/NOC_10_04_NetworkAnimation/Connection.pde ../NOC%20examples%20-%20processing/chp10/NOC_10_04_NetworkAnimation/Network.pde ../NOC%20examples%20-%20processing/chp10/NOC_10_04_NetworkAnimation/Neuron.pde" class="screenshot">
		<p>Your browser does not support the canvas tag.</p>
	</canvas>
  <div class="sketch-controls">
    <button class="reset">RESET</button>
    <button class="pause">PAUSE</button>
  </div>
	
	
</div>
<p><a id="chapter10_example4" style="display: block;"></a><span class="example">Example 10.4: Animating a neural network diagram</span></p>
<div class="source-code">
  <a class="toggle" href="chapter-10-neural-networks.html#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void draw() {
  background(255);
  // The Network now has a new update() method that updates all of the Connection objects.
  network.update(); //[bold]
  network.display();

  if (frameCount % 30 == 0) { //[bold]
    // We are choosing to send in an input every 30 frames.
    network.feedforward(random(1)); //[bold]
  } //[bold]
}

class Connection {
  // The Connection’s data
  float weight;
  Neuron a;
  Neuron b;

  // Variables to track the animation
  boolean sending = false;
  PVector sender;
  float output = 0;

  Connection(Neuron from, Neuron to, float w) {
    weight = w;
    a = from;
    b = to;
  }

  // The Connection is active with data traveling from a to b.
  void feedforward(float val) {
    output = val*weight;
    sender = a.location.get();
    sending = true;
  }

  // Update the animation if it is sending.
  void update() {
    if (sending) {
      sender.x = lerp(sender.x, b.location.x, 0.1);
      sender.y = lerp(sender.y, b.location.y, 0.1);
      float d = PVector.dist(sender, b.location);
      if (d < 1) {
        b.feedforward(output);
        sending = false;
      }
    }
  }

  // Draw the connection as a line and traveling circle.
  void display() {
    stroke(0);
    strokeWeight(1+weight*4);
    line(a.location.x, a.location.y, b.location.x, b.location.y);

    if (sending) {
      fill(0);
      strokeWeight(1);
      ellipse(sender.x, sender.y, 16, 16);
    }
  }
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">background</span><span class="o">(</span><span class="mi">255</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The Network now has a new update() method that updates all of the Connection objects.</div><code><pre><span class='one-line'>  <strong><span class="n">network</span><span class="o">.</span><span class="na">update</span><span class="o">();</span></strong></span>
<span class='one-line'>  <span class="n">network</span><span class="o">.</span><span class="na">display</span><span class="o">();</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <strong><span class="k">if</span> <span class="o">(</span><span class="n">frameCount</span> <span class="o">%</span> <span class="mi">30</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span></strong></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>We are choosing to send in an input every 30 frames.</div><code><pre><span class='one-line'>    <strong><span class="n">network</span><span class="o">.</span><span class="na">feedforward</span><span class="o">(</span><span class="n">random</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span></strong></span>
<span class='one-line'>  <strong><span class="o">}</span></strong></span>
<span class='one-line'><span class="o">}</span></span>
<span class='one-line'> </span>
<span class='one-line'><span class="kd">class</span> <span class="nc">Connection</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The Connection’s data</div><code><pre><span class='one-line'>  <span class="kt">float</span> <span class="n">weight</span><span class="o">;</span></span>
<span class='one-line'>  <span class="n">Neuron</span> <span class="n">a</span><span class="o">;</span></span>
<span class='one-line'>  <span class="n">Neuron</span> <span class="n">b</span><span class="o">;</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Variables to track the animation</div><code><pre><span class='one-line'>  <span class="kt">boolean</span> <span class="n">sending</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span></span>
<span class='one-line'>  <span class="n">PVector</span> <span class="n">sender</span><span class="o">;</span></span>
<span class='one-line'>  <span class="kt">float</span> <span class="n">output</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">Connection</span><span class="o">(</span><span class="n">Neuron</span> <span class="n">from</span><span class="o">,</span> <span class="n">Neuron</span> <span class="n">to</span><span class="o">,</span> <span class="kt">float</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">weight</span> <span class="o">=</span> <span class="n">w</span><span class="o">;</span></span>
<span class='one-line'>    <span class="n">a</span> <span class="o">=</span> <span class="n">from</span><span class="o">;</span></span>
<span class='one-line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">to</span><span class="o">;</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The Connection is active with data traveling from a to b.</div><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">feedforward</span><span class="o">(</span><span class="kt">float</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">output</span> <span class="o">=</span> <span class="n">val</span><span class="o">*</span><span class="n">weight</span><span class="o">;</span></span>
<span class='one-line'>    <span class="n">sender</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">get</span><span class="o">();</span></span>
<span class='one-line'>    <span class="n">sending</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Update the animation if it is sending.</div><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">update</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="k">if</span> <span class="o">(</span><span class="n">sending</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>      <span class="n">sender</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">lerp</span><span class="o">(</span><span class="n">sender</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="mf">0.1</span><span class="o">);</span></span>
<span class='one-line'>      <span class="n">sender</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">lerp</span><span class="o">(</span><span class="n">sender</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="mf">0.1</span><span class="o">);</span></span>
<span class='one-line'>      <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">PVector</span><span class="o">.</span><span class="na">dist</span><span class="o">(</span><span class="n">sender</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">location</span><span class="o">);</span></span>
<span class='one-line'>      <span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>        <span class="n">b</span><span class="o">.</span><span class="na">feedforward</span><span class="o">(</span><span class="n">output</span><span class="o">);</span></span>
<span class='one-line'>        <span class="n">sending</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span></span>
<span class='one-line'>      <span class="o">}</span></span>
<span class='one-line'>    <span class="o">}</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Draw the connection as a line and traveling circle.</div><code><pre><span class='one-line'>  <span class="kt">void</span> <span class="nf">display</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">stroke</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">strokeWeight</span><span class="o">(</span><span class="mi">1</span><span class="o">+</span><span class="n">weight</span><span class="o">*</span><span class="mi">4</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">line</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">a</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">location</span><span class="o">.</span><span class="na">y</span><span class="o">);</span></span>
<span class='one-line'> </span>
<span class='one-line'>    <span class="k">if</span> <span class="o">(</span><span class="n">sending</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>      <span class="n">fill</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>      <span class="n">strokeWeight</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span></span>
<span class='one-line'>      <span class="n">ellipse</span><span class="o">(</span><span class="n">sender</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">sender</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">16</span><span class="o">);</span></span>
<span class='one-line'>    <span class="o">}</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><div class="example">
  <a id="chapter10_exercise5" style="display: block;"></a><h4 id="exercise-105">Exercise 10.5</h4><p>The network in the above example was manually configured by setting the location of each neuron and its connections with hard-coded values.  Rewrite this example to generate the network’s layout via an algorithm.  Can you make a circular network diagram? A random one? An example of a multi-layered network is below.</p>
<div class="image-container screenshot" >
	
	<canvas data-processing-sources="../NOC%20examples%20-%20processing/chp10/Exercise_10_5_LayeredNetworkAnimation/Exercise_10_5_LayeredNetworkAnimation.pde ../NOC%20examples%20-%20processing/chp10/Exercise_10_5_LayeredNetworkAnimation/Connection.pde ../NOC%20examples%20-%20processing/chp10/Exercise_10_5_LayeredNetworkAnimation/Network.pde ../NOC%20examples%20-%20processing/chp10/Exercise_10_5_LayeredNetworkAnimation/Neuron.pde" class="screenshot">
		<p>Your browser does not support the canvas tag.</p>
	</canvas>
  <div class="sketch-controls">
    <button class="reset">RESET</button>
    <button class="pause">PAUSE</button>
  </div>
	
	
</div>

</div><div class="example">
  <a id="chapter10_exercise6" style="display: block;"></a><h4 id="exercise-106">Exercise 10.6</h4><p>Rewrite the example so that each neuron keeps track of its forward and backward connections.  Can you feed inputs through the network in any direction?</p>

</div><div class="example">
  <a id="chapter10_exercise7" style="display: block;"></a><h4 id="exercise-107">Exercise 10.7</h4><p>Instead of <span class="function">lerp()</span>, use moving bodies with steering forces to visualize the flow of information in the network.</p>

</div><div style="page-break-after:always;"> </div><div class="tip">
  <h4 id="the-ecosystem-project">The Ecosystem Project</h4><p>Step 10 Exercise:</p>
<p>Try incorporating the concept of a “brain” into your creatures.</p>
<div class="list">
	
	<ul>
		
			<li><p>
Use reinforcement learning in the creatures’ decision-making process.
</p>
</li>
		
			<li><p>
Create a creature that features a visualization of its brain as part of its design (even if the brain itself is not functional).
</p>
</li>
		
			<li><p>
Can the ecosystem as a whole emulate the brain?  Can elements of the environment be neurons and the creatures act as inputs and outputs?
</p>
</li>
		
	</ul>
</div>
</div><section><a id="_the_end" style="display: block;"></a><h4 id="the-end">The end</h4><p>If you’re still reading, thank you!  You’ve reached the end of the book.  But for as much material as this book contains, we’ve barely scratched the surface of the world we inhabit and of techniques for simulating it.  It’s my intention for this book to live as an ongoing project, and I hope to continue adding new tutorials and examples to the <a href="../index.html">book’s website</a> as well as expand and update the printed material.  Your feedback is truly appreciated, so please get in touch via email at (daniel@shiffman.net) or by contributing to the <a href="http://github.com/shiffman/The-Nature-of-Code/">GitHub repository</a>, in keeping with the open-source spirit of the project.  Share your work. Keep in touch.  Let’s be two with nature.</p>
<div style="page-break-after:always;"> </div></section></section>
  	</div>
  </div>

	<div id="bottom">
		<div id="footer">
			<div class="one-third" id="licenses">
        <h4>Licenses</h4>
        <p>
          <a class="license-badge" rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a>
          <a class="license-badge" rel="license" href="http://creativecommons.org/licenses/LGPL/2.1/"><img alt="LGPL License" style="border-width:0" src="http://www.gnu.org/graphics/lgplv3-88x31.png" /></a>
        </p>

        <p>
          The book's text and illustrations are licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/">Creative Commons Attribution-NonCommercial 3.0 Unported License</a>.
        </p>

        <p>
          All of the book's source code is licensed under the <a rel="license" href="http://creativecommons.org/licenses/LGPL/2.1/">GNU Lesser General Public License</a> as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.
        </p>

      </div>

      <div class="one-third">
        <h4>Colophon</h4>

        <p>This book was generated with <a href="https://github.com/runemadsen/Magic-Book-Project">The Magic Book Project</a>.

        <p>This book would not have been possible without the generous support of <a href="http://www.kickstarter.com/projects/shiffman/the-nature-of-code-book-project">Kickstarter</a> backers.</p> 

        <p>This book is typeset on the web in Georgia with headers in Proxima Nova.</p>

        <p>Please report any mistakes in the book or bugs in the source with a <a href="https://github.com/shiffman/The-Nature-of-Code/issues?sort=created&state=open">GitHub issue</a> or contact me at <span class="eml">daniel at shiffman dot net</span>.</p>
      </div>

      <div class="one-third">
        <h4>Author</h4>
        <p>Daniel Shiffman is a professor of the <a href="http://itp.nyu.edu/">Interactive Telecommunications Program</a> at New York University.</p>

        <p>He is the author of <a href="http://www.learningprocessing.com/">Learning Processing</a>.</p>

        <p><a href="https://twitter.com/shiffman">Twitter</a> <a href="http://github.com/shiffman">GitHub</a></p>
      </div>
		</div>
	</div>
</body>
</html>