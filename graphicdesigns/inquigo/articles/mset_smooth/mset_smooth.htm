        

<!DOCTYPE HTML>
<html>

	<head>
        <meta charset="ISO-8859-1">
		<meta name="keywords" content="quilez, inigo, iñigo, fractals, demoscene, computer graphics, mathematics, rendering, demo, 3D, realtime, shader, raytracing, shadertoy, glsl">
		<meta name="description" content="Tutorials and articles of Inigo Quilez on computer graphics, fractals, demoscene, shaders and more.">
		<meta name="author" content="Inigo Quilez">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		
		<meta property="og:title" content="Inigo Quilez" />
		<meta property="og:description" content="Articles on computer graphics, math and art">
		<meta property="og:type" content="article" />
		<meta property="og:image" content="https://iquilezles.org/logo.jpg" />
		<meta property="og:image:type" content="image/jpg" />
		<meta property="og:url" content="https://iquilezles.org" />
		
		<meta name="twitter:title" content="Inigo Quilez">
		<meta name="twitter:description" content="Articles on computer graphics, math and art">
		<meta name="twitter:image" content="https://iquilezles.org/logo.jpg">
		<meta name="twitter:card" content="summary_large_image">

		<link rel="canonical" href="https://iquilezles.org"/>
		<title>Inigo Quilez :: fractals, computer graphics, mathematics, shaders, demoscene and more</title>
		<link href="/style.css?v=11" rel="stylesheet">
		
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-M1E3CY9CCC"></script>
        <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config', 'G-M1E3CY9CCC');</script>

	</head>

	<body><div style="display:flex;flex-direction:column;min-height:100vh;">
		
		<header>
		
		<div>
		  <a class="menu" href="/index.html">Inigo Quilez</a>
		
		  &nbsp; :: &nbsp; <a class="menu" href="/www/index.htm">articles</a>&nbsp; :: &nbsp; <a class="menu" href="/www/articles/mset_smooth/mset_smooth.htm">smooth iteration count for generalized Mandelbrot sets - 2007</a>		</div>
		
		<!--<div style="font-size:0.75em;margin:0;padding:0;">-->
		<!--<div style="margin:0;padding:0;background-color:#00ff00;display:flex;justify-self:self-end;">-->
		<div style="padding:0;margin:0;border:0;display:flex;flex-flow:row wrap;justify-content:flex-end;">
			<a href="https://twitter.com/iquilezles"><img class="socialMediaIcon" src="/imgTwitter.png"/></a>
			<a href="https://www.youtube.com/channel/UCdmAhiG8HQDlz8uyekw4ENw"><img class="socialMediaIcon" src="/imgYoutube.png"/></a>
			<a href="https://www.shadertoy.com/user/iq/"><img class="socialMediaIcon" src="/imgShadertoy.png"/></a> 
            <a href="https://www.patreon.com/inigoquilez"><img class="socialMediaIcon" src="/imgPatreon.png"/></a>
			<a href="http://paypal.me/inigoquilez"><img class="socialMediaIcon" src="/imgPayPal.png"/></a> 
			<a href="https://www.tiktok.com/@inigoquilez"><img class="socialMediaIcon" src="/imgTikTok.png"/></a> 
		<!--<a href="https://space.bilibili.com/673661710"><img class="socialMediaIcon" src="/imgBiliBili.png"/></a>-->
		</div>
		
		</header>
		
        <div id="container" style="flex-grow:1;">


<h3>Intro</h3><hr>
It seems people have been using the so called smooth-iteration-count formula to render the Mandelbrot for a while now, which produces a smooth continuous gradient of color in the exterior of the M set as opposed to the old school discreet iteration count algorithm, but few know where the formula comes from. In this article I'll quickly explain how the formula is derived and how it generalizes to M sets and polynomial fractals of any positive integer degree.<br>
<br>
<center><img class="myPicture" src="gfx00.png"/><br><i>Smooth vs classic iteration count for f(z) = z²+c</i></center><br>
<br>
<br>
<h3>The basics</h3><hr>
Let's render the fractal generated by a polynomial of the form<br>
<br>
<span class="formulaText">f(z) = a<sub>d</sub>&sdot;z<sup>d</sup> + a<sub>d-1</sub>&sdot;z<sup>d-1</sup> + ... a<sub>2</sub>&sdot;z<sup>2</sup> + a<sub>1</sub>&sdot;z + a<sub>0</sub></span><br>
<br>
with <b>d</b> an integer (degree of the polynomial) and real, complex or quaternionic coefficients <b>a</b>. To make things easier to manipulate, but without lose of generality, we will assume <b>a<sub>d</sub></b> = 1. We are interested in studying the dynamics introduced by the iteration of such a polynomial map for different values of <b>a</b>, which is a "d" dimensional problem. In particular, we want to find the divergent, periodic (including convergent) and chaotic sets of the space when points are repeatedly mapped and re-mapped and re-re-mapped by <b>f(z)</b>.<br>
<br>
Traditionally, for simplifying the study and the visualization of such sets, all of the coefficients <b>a</b> except for one are considered constant. This one dimensional problem (on complex numbers, which are two dimensional themselves) is now easily displayed in a two dimensional screen. For example, for the traditional Mandelbrot set <span class="formulaText">f(z) = z<sup>2</sup>+c</span> one sets <b>d</b>=2 and <b>a<sub>2</sub></b> = 1, <b>a<sub>1</sub></b> = 0 and only <b>a<sub>0</sub></b> is considered variable (renamed to <b>c</b>). Another similar polynomial is &nbsp;<span class="formulaText">f(z) = z<sup>7</sup> + (3-c)z<sup>3</sup> = (c+1+i)z + c</span><br>
<br>
Note that we are playing with two different planes here. The parameter plane where <b>c</b> lives, the one we are making a picture of, and the dynamical plane which is different for each choice of <b>c</b> that we make, where <b>z</b> lives (and the Julia sets). In the dynamical plane, the points that satisfy f'(z)=0 are called the critical points, these are the points where the mapping behaves funny (it contracts the plane so much it cannot be reversed!). There are of course <b>d</b>-1 such points, one for each root of the equation f'(z)=0. Because all of our polynomials defined above satisfy f'(0) = 0, we'll be paying special attention to the behave of our map <b>f(z)</b> under iterations <span class="formulaText">z<sub>n+1</sub> = f(z<sub>n</sub>)</span> starting with <b>z<sub>0</sub></b>=0, which generates the critical <i>orbit</i> and determines the shape of the associated Julia set. This is the reason the classic Mandelbrot set and all of the fractals generated by the polynomials defined above start their iterations with <b>z</b>=0.<br>
<br>
This critical orbit can converge, can become periodic, can become chaotic or can diverge to infinity (which in our one dimensional complex case, it's the exterior of a disk of infinitely big radius). In classical renders of these fractals images, <b>c</b> points that produce orbits not diverging  to infinity are marked black, and otherwise points are colored according to how many iterations or applications of <b>f(z)</b> it took detect the orbit is divergent.<br>
<br>
To determine such condition, one has to do the following observation: given a sufficiently big (distant from the origin) point <b>z</b>, the map <b>f(z)</b> can be approximated by <span class="formulaText">f(z) = z<sup>d</sup></span> since the leading term of power <b>d</b> will grow way faster than the lower powers of <b>z</b>. That means, that after certain radius or distance from the origin, <b>f(z)</b> will only push the orbit to infinity, meaning the interesting orbits and hence values of <b>c</b> and the fractal itself are situated around the origin of the plane.<br>
<br>
One can compute exactly what the actual threshold radius that we need to check against is (you can read <a class="regular" href="http://iquilezles.org/www/articles/mset_1bulb/mset1bulb.htm">this article</a> to see how to compute it:<br>
<br>
<img class="formula" valign="bottom" src="gfx05.png"/><br>
<br>
For example, for the traditional Mandelbrot set <b>d</b> = 2 and therefore <b>B</b> = 2, which is the value used in the traditional rendering of the Mandelbrot set (you have seen this value squared to avoid having to take the square root in the computation of the length of <b>z</b>). However, for the smooth iteration count computation we are going to really leverage the approximation for <b>f(z)</b> just mentioned, which requires us to work a little bit closer to infinity than a distance of 2 from the origin. However, we don't really need to go that far, something in the order of 50 will be sufficient since by then the leading term of <b>f(z)</b> is relatively powerful enough compared to the others for the approximation to work. But regardless of the value of <b>B</b>, each point in the orbit of <b>f(z)</b> associated with a different value of <b>c</b>, or <b>f<sub>c</sub>(z)</b> if you want, is compared against it for an "escape" - a point that became bigger than <b>B</b> and therefore is guaranteed to diverge to infinity. Usually the number of iterations or applications of <b>f</b> is recorded and displayed as a color, what creates a series of color "bands".
<br>
<br>
<h3>The technique</h3><hr>
Now that we understand the setup, lets dive into the actual smooth iteration count formula. The observation is that once a point <b>z<sub>n</sub></b> in the orbit has become bigger than <b>B</b> and escaped, it is not the same if it barely escaped by becoming just slightly bigger than <b>B</b> or if actually escaped by a lot. We can actually measure this strength and remap it or normalize it to the interval [0, 1] so that we can use it as the fractional part on our otherwise discreet iteration counter, giving us effectively a smooth gradation between the escape bands.<br>
</br>
The lower bound for such a remap is simply <b>B</b> : any |<b>z<sub>n</sub></b>| (adding "n" now for the index in the orbit or iteration) exactly of size <b>B</B> will map to 0. The upper bound happens where a point <b>z<sub>n</sub></b> surpassed <b>B</b> by so much that it could have almost not needed the current iteration to escape but could have almost done it in the previous one. In that case, |<b>z<sub>n</sub></b>| is going to be really close to <b>B</b><sup><b>d</b></sup>, since according to our approximation that's where the next ring of escaping points will be (remember we are far enough from the origin, and each iteration or application of <b>f(z)</b> increases the size by |<b>z</b>|<sup><b>d</b></sup>). So, basically we have to remap values of |<b>z<sub>n</sub></b>| what are <b>B</b> to 0 and <b>B</b><sup><b>d</b></sup> to 1. We can achieve this simply by taking the logarithm of |<b>z<sub>n</sub></b>| in base <b>B</b> which will remap |<b>z<sub>n</sub></b>| to the range [1, d]:<br>
<br>
<img class="formula" valign="bottom" src="gfx06.png"/><br>
<br>
then doing a linear transform to bring it back to [0, 1], and finally subtract this from our integer number of iterations <b>n</b> to get the smooth iteration count:<br>
<br>
<img class="formula" valign="bottom" src="gfx07.png"/><br>
<br>
This produces a smooth color gradient, you can check it by implementing this yourself. However, it's not as uniform as we wish, the reason being that <b>h</b>(z<sub><b>n</b></sub>) is growing itself in powers of <b>d</b> with each extra iteration. To undo this exponential growth and linearize with respect to distance we can take once again a logarithm, the logarithm of <b>h</b> in base <b>d</b>, which also remaps [1, d] to [0, 1]:<br>
<br>
<img class="formula" valign="bottom" src="gfx08.png"/><br>
<br>
This produces the desired smooth iteration count (see image at the top of the article). And of course, it not only works for the classic Mandelbrot set, it also works for any of the polynomial generalizations we proposed due to the strength of the leading term in the polynomial near infinity. For example, for the polynomial &nbsp;<span class="formulaText">f(z) = z<sup>7</sup> + (3-c)z<sup>3</sup> = (c+1+i)z + c</span>&nbsp; we get the following smooth coloring:<br>
<br>
<div class="partsC">
<div class="part"><img class="myPicture" src="gfx09.png"/><br>Smooth iteration count</div>
<div class="part"><img class="myPicture" src="gfx10.png"/><br>Classic (integer) iteration count</div>
</div>
<br>
You find source code for this technique here: <a class="regular" href="https://www.shadertoy.com/view/MltXz2">https://www.shadertoy.com/view/MltXz2</a>:<br><br>
<div class="iframeCenter" style="max-width:800px;"><div>
<iframe frameborder="0" src="https://www.shadertoy.com/embed/MltXz2?gui=true&t=10&paused=true&muted=false" allowfullscreen></iframe>
</div></div>
<br>
<br>
One note on implementation: it is possible to run the smooth iteration formula on the square of the length of <b>z<sub>n</sub></b>, which avoids one square root computation (not much of a relative saving really). Also, if you are using the classic Mandelbrot set and <b>d</b> is 2, then you can replace the natural logarithms in the formula above by logarithms in base 2 and avoid the last division by ln d, and since the threshold <b>B</b> is a constant another one of the logarithms can be avoided as well:<br>
<br>
<img class="formula" valign="bottom" src="gfx12.png"/><br>
<br>
making the final code (again, only for the classic Mandelbrot set), see this example extracted from here: <a class="regular" href="https://www.shadertoy.com/view/4df3Rn">https://www.shadertoy.com/view/4df3Rn</a><br>
<br>
<div class="code"><span class="codeComment">// compute the smooth iteration count for a pointin the plane</span>
float IterateMandelbrot( in vec2 c )
{
    const float B = 256.0;

    float n = 0.0;
    vec2 z  = vec2(0.0);
    for( int i=0; i&lt;200; i++ )
    {
        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c; <span class="codeComment">// z = z² + c</span>
        if( dot(z,z)&gt;(B*B) ) break;
        n += 1.0;
    }

    //float sn = n - log(log(length(z))/log(B))/log(2.0); <span class="codeComment">// smooth iteration count</span>
    float sn = n - log2(log2(dot(z,z))) + 4.0;  <span class="codeComment">// equivalent optimized smooth iteration count</span>
    
    return sn;
}</div>
<br>
<!-- -------------------------------------------------------------------------------------------- -->
<br>
<br>
<br>




	
    

    </div> <!-- container -->
	<footer><a href="http://www.iquilezles.org">inigo quilez</a> - learning computer graphics since 1994</footer>
    </div></body>
</html>