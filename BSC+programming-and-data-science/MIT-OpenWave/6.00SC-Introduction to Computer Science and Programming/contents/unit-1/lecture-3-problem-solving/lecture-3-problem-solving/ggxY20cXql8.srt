1
00:00:00,040 --> 00:00:02,460
The following content is
provided under a Creative

2
00:00:02,460 --> 00:00:03,870
Commons license.

3
00:00:03,870 --> 00:00:06,910
Your support will help MIT
OpenCourseWare continue to

4
00:00:06,910 --> 00:00:10,560
offer high quality educational
resources for free.

5
00:00:10,560 --> 00:00:13,460
To make a donation or view
additional materials from

6
00:00:13,460 --> 00:00:19,290
hundreds of MIT courses, visit
MIT OpenCourseWare at

7
00:00:19,290 --> 00:00:21,860
ocw.mit.edu.

8
00:00:21,860 --> 00:00:24,570
PROFESSOR: I apologize to
those of you watching on

9
00:00:24,570 --> 00:00:25,640
OpenCourseWare.

10
00:00:25,640 --> 00:00:28,240
I forgot to turn on
my microphone.

11
00:00:28,240 --> 00:00:31,690
And you missed some incredibly
brilliant things.

12
00:00:31,690 --> 00:00:33,190
But such is life.

13
00:00:36,430 --> 00:00:39,930
Let me go back to where I was,
which was we we're looking at

14
00:00:39,930 --> 00:00:44,610
this code to find the cube
root of a perfect cube.

15
00:00:44,610 --> 00:00:47,880
We saw this last week, and
indeed, you also saw it in

16
00:00:47,880 --> 00:00:49,300
recitation.

17
00:00:49,300 --> 00:00:52,800
I'm not going to belabor it.

18
00:00:52,800 --> 00:00:57,400
I do want to ask you the
question, for what values will

19
00:00:57,400 --> 00:00:58,705
this program terminate?

20
00:01:01,710 --> 00:01:04,239
That is to say the only
input is to x.

21
00:01:04,239 --> 00:01:06,950
For what values of
x is this program

22
00:01:06,950 --> 00:01:09,453
guaranteed to always stop?

23
00:01:15,930 --> 00:01:18,050
Anybody want to volunteer
an answer to that?

24
00:01:21,380 --> 00:01:22,660
Ask a simpler question.

25
00:01:22,660 --> 00:01:25,360
Let's assume that
x is a number.

26
00:01:25,360 --> 00:01:27,020
In fact, let's assume
it's an integer.

27
00:01:29,930 --> 00:01:33,400
Will it terminate for all
positive integers, all

28
00:01:33,400 --> 00:01:35,900
positive values of x?

29
00:01:35,900 --> 00:01:36,950
Yeah.

30
00:01:36,950 --> 00:01:39,890
All negative values?

31
00:01:39,890 --> 00:01:41,690
As far as I can tell.

32
00:01:41,690 --> 00:01:43,250
How about 0?

33
00:01:43,250 --> 00:01:44,300
Yeah.

34
00:01:44,300 --> 00:01:48,640
So in fact, it terminates
for all values of x.

35
00:01:48,640 --> 00:01:51,470
How do I know that?

36
00:01:51,470 --> 00:01:53,560
And that's a key question.

37
00:01:53,560 --> 00:01:58,120
I know that because I've used,
and I mean by used as a mental

38
00:01:58,120 --> 00:02:01,620
tool, something in my head,
the notion of a

39
00:02:01,620 --> 00:02:02,870
decrementing function.

40
00:02:11,360 --> 00:02:16,250
And every time I write a loop,
I think about one of these,

41
00:02:16,250 --> 00:02:19,540
because that explains to
me why the loop is

42
00:02:19,540 --> 00:02:22,900
guaranteed to terminate.

43
00:02:22,900 --> 00:02:26,920
We'll go over here where we have
a bigger board and look

44
00:02:26,920 --> 00:02:29,690
at the properties that
a decrementing

45
00:02:29,690 --> 00:02:30,940
function needs to have.

46
00:02:35,850 --> 00:02:42,720
One, it will map some
set of program

47
00:02:42,720 --> 00:02:54,665
variables to an integer.

48
00:03:04,880 --> 00:03:10,490
Two, when the loop is entered
for the first time or when I

49
00:03:10,490 --> 00:03:14,070
encountered the test of the loop
for the first time, its

50
00:03:14,070 --> 00:03:15,710
value is non-negative.

51
00:03:30,770 --> 00:03:41,930
Three, when its value gets to
be less than or equal to 0,

52
00:03:41,930 --> 00:03:43,180
the loop terminates.

53
00:03:49,530 --> 00:03:56,600
And finally four, it's
decreased each

54
00:03:56,600 --> 00:03:58,566
time through the loop.

55
00:04:08,430 --> 00:04:13,290
So what we see is if it starts
to be a positive value or

56
00:04:13,290 --> 00:04:17,839
non-negative, and it's decreased
every time I execute

57
00:04:17,839 --> 00:04:22,710
the body of a loop, that
eventually, it's got to reach

58
00:04:22,710 --> 00:04:25,290
0 or something less than 0.

59
00:04:25,290 --> 00:04:26,720
And when it does,
the loop stops.

60
00:04:29,820 --> 00:04:33,840
If such a function exists, then
the loop is guaranteed to

61
00:04:33,840 --> 00:04:35,090
always terminate.

62
00:04:38,570 --> 00:04:42,190
Now, of course, one can count up
to a value instead of down.

63
00:04:42,190 --> 00:04:45,180
But there's always a trick we
can use of subtracting to make

64
00:04:45,180 --> 00:04:46,730
it the same.

65
00:04:46,730 --> 00:04:50,960
So what's the decrementing
function for this loop?

66
00:04:50,960 --> 00:04:52,625
How did I know it will
always terminate?

67
00:04:58,030 --> 00:04:58,460
Yeah?

68
00:04:58,460 --> 00:05:00,915
AUDIENCE: [INAUDIBLE].

69
00:05:00,915 --> 00:05:04,760
PROFESSOR: Answer equals
answer plus 1.

70
00:05:04,760 --> 00:05:07,030
I don't think so.

71
00:05:07,030 --> 00:05:09,010
Does that satisfy all
of these properties?

72
00:05:13,870 --> 00:05:17,320
Remember, a function is going
to map some set of program

73
00:05:17,320 --> 00:05:23,680
variables to an integer.

74
00:05:23,680 --> 00:05:26,440
So what are the interesting
program variables here?

75
00:05:26,440 --> 00:05:30,530
Well, there are only
two, ans and x.

76
00:05:30,530 --> 00:05:31,780
Right?

77
00:05:33,385 --> 00:05:35,140
At least, that's
all I can see.

78
00:05:39,270 --> 00:05:40,810
So what would be an interesting
function?

79
00:05:45,900 --> 00:05:47,150
Somebody?

80
00:05:48,950 --> 00:05:51,300
Surely, there's someone who
can figure this out.

81
00:05:55,520 --> 00:05:57,040
Yes?

82
00:05:57,040 --> 00:05:58,583
Or no, you're just scratching
your head.

83
00:05:58,583 --> 00:06:00,270
You fooled me.

84
00:06:00,270 --> 00:06:02,630
I can't see because of the
light, but I'm sure there must

85
00:06:02,630 --> 00:06:05,241
be dozens of hands up if
I could only see them.

86
00:06:07,890 --> 00:06:10,460
Actually, I don't see
any hands up.

87
00:06:13,010 --> 00:06:14,375
This is not so hard, guys.

88
00:06:19,430 --> 00:06:26,155
It's the absolute value of
x minus answer cubed.

89
00:06:36,810 --> 00:06:39,850
So what does this
value start at?

90
00:06:39,850 --> 00:06:41,920
Let's pick a value.

91
00:06:41,920 --> 00:06:47,080
Suppose that x is equal to 8.

92
00:06:52,240 --> 00:06:54,690
What is the initial value of
the decrementing function?

93
00:06:57,250 --> 00:06:59,070
Wow.

94
00:06:59,070 --> 00:07:00,230
Come on.

95
00:07:00,230 --> 00:07:02,450
Let's be a little cooperative,
please.

96
00:07:02,450 --> 00:07:03,030
Yes?

97
00:07:03,030 --> 00:07:07,022
AUDIENCE: So it's 8, answer
is 0 and absolute

98
00:07:07,022 --> 00:07:07,521
value of x is 8.

99
00:07:07,521 --> 00:07:13,140
PROFESSOR: So it's 8 minus
0, which is equal to 8.

100
00:07:13,140 --> 00:07:17,805
So it satisfies conditions
one and conditions two.

101
00:07:21,000 --> 00:07:23,695
What happens to this value every
time through the loop?

102
00:07:29,400 --> 00:07:32,390
Does x change?

103
00:07:32,390 --> 00:07:35,060
Does answer change?

104
00:07:35,060 --> 00:07:38,220
And how does it change?

105
00:07:38,220 --> 00:07:40,490
It's increasing.

106
00:07:40,490 --> 00:07:41,870
What does answer start at?

107
00:07:41,870 --> 00:07:44,730
It starts at 0, and
it increases.

108
00:07:44,730 --> 00:07:48,700
So I know that answer cubed
will always be positive.

109
00:07:48,700 --> 00:07:49,870
Right?

110
00:07:49,870 --> 00:07:51,500
So I know that every
time through the

111
00:07:51,500 --> 00:07:54,840
loop, it will be 8.

112
00:07:54,840 --> 00:07:57,350
The first time through,
it'll be 8 minus 1

113
00:07:57,350 --> 00:07:58,600
cubed, which is 7.

114
00:08:02,150 --> 00:08:06,030
And then the next time through,
it'll be 8 minus 2

115
00:08:06,030 --> 00:08:09,670
cubed, which is 0.

116
00:08:09,670 --> 00:08:10,920
And then, I exit the loop.

117
00:08:14,500 --> 00:08:16,820
And it's that kind of reasoning
that I used to

118
00:08:16,820 --> 00:08:21,800
convince myself that this
loop terminates.

119
00:08:21,800 --> 00:08:24,590
And every time I write a loop,
and I hope every time you

120
00:08:24,590 --> 00:08:29,680
write a loop, you will think
about what's the reason the

121
00:08:29,680 --> 00:08:31,370
loop is going to terminate.

122
00:08:31,370 --> 00:08:34,470
And you will do it by thinking
about what the decrementing

123
00:08:34,470 --> 00:08:35,720
function is.

124
00:08:37,929 --> 00:08:39,940
People get me on that?

125
00:08:39,940 --> 00:08:43,520
And whoever finally answered
a question surely

126
00:08:43,520 --> 00:08:44,770
deserves to be fed.

127
00:08:49,060 --> 00:08:51,300
I obviously have to bring better
candy to encourage

128
00:08:51,300 --> 00:08:55,070
better responses.

129
00:08:55,070 --> 00:08:59,930
Now, let's go back and look
at the program itself.

130
00:08:59,930 --> 00:09:05,230
Now that we know it stops, and
you can take my word for it

131
00:09:05,230 --> 00:09:09,350
that it actually computes the
correct answer, let's think

132
00:09:09,350 --> 00:09:11,200
about what kind of algorithm
this is.

133
00:09:11,200 --> 00:09:13,240
What's the method?

134
00:09:13,240 --> 00:09:17,040
This is an example of
guess and check.

135
00:09:17,040 --> 00:09:20,190
And it's a particular kind
called exhaustive enumeration.

136
00:09:37,680 --> 00:09:41,130
Each time through the loop, I'm
taking a guess at to what

137
00:09:41,130 --> 00:09:45,730
the value is, and I'm checking
whether it's true.

138
00:09:45,730 --> 00:09:48,330
But I'm enumerating
the guesses in a

139
00:09:48,330 --> 00:09:49,840
very systematic way.

140
00:09:49,840 --> 00:09:52,050
They're not just
random guesses.

141
00:09:52,050 --> 00:09:54,520
I'm enumerating all the
possible answers.

142
00:09:58,670 --> 00:10:02,460
If I get through the entire
space of answers, or possible

143
00:10:02,460 --> 00:10:06,180
answers, and I don't find a
solution, then I know that it

144
00:10:06,180 --> 00:10:09,850
doesn't exist, and it's
not a perfect cube.

145
00:10:09,850 --> 00:10:13,180
So that's why it's called
exhaustive enumeration because

146
00:10:13,180 --> 00:10:15,740
I'm exhausting the space
of possible answers.

147
00:10:20,880 --> 00:10:23,130
Does that makes sense
to everyone?

148
00:10:23,130 --> 00:10:25,350
So let's try it.

149
00:10:25,350 --> 00:10:31,810
Let's try it with say a very
large value of x, because

150
00:10:31,810 --> 00:10:34,150
that's always an issue, of
course, when we do exhaustive

151
00:10:34,150 --> 00:10:35,400
enumeration.

152
00:10:38,210 --> 00:10:40,160
So I'm going to enter
this value.

153
00:10:49,360 --> 00:10:51,350
Is that a perfect cube?

154
00:10:51,350 --> 00:10:52,600
Who thinks it is?

155
00:10:54,750 --> 00:10:56,330
Who can tell me what it is?

156
00:10:56,330 --> 00:10:59,140
What's the cube root of that?

157
00:10:59,140 --> 00:11:02,270
Well, this is a question I did
not expect you to answer.

158
00:11:02,270 --> 00:11:07,930
But it's 1,251.

159
00:11:07,930 --> 00:11:10,550
That'll be in the first quiz,
so make a note of it.

160
00:11:13,320 --> 00:11:16,160
Notice how quickly the
computer did this.

161
00:11:16,160 --> 00:11:17,920
It found the cube
root of quite a

162
00:11:17,920 --> 00:11:21,690
large number very quickly.

163
00:11:21,690 --> 00:11:24,380
And so while one might
initially think that

164
00:11:24,380 --> 00:11:29,890
exhaustive enumeration is a
silly technique because takes

165
00:11:29,890 --> 00:11:33,140
a lot of guesses, for an awful
lot of problems, we can

166
00:11:33,140 --> 00:11:38,230
actually just write a pretty
stupid program that's solves

167
00:11:38,230 --> 00:11:40,340
it by exhaustive enumeration.

168
00:11:40,340 --> 00:11:43,330
We typically refer to such
programs as brute force.

169
00:11:45,980 --> 00:11:48,930
And brute force is often
exactly the right

170
00:11:48,930 --> 00:11:51,680
way to solve a problem.

171
00:11:51,680 --> 00:11:53,140
Why does it work?

172
00:11:53,140 --> 00:11:54,735
Because computers
are really fast.

173
00:11:57,410 --> 00:11:59,550
How fast are computers?

174
00:11:59,550 --> 00:12:02,520
Well, today, a good computer
can execute in a single

175
00:12:02,520 --> 00:12:06,940
processor in the order of 100
million instructions a second.

176
00:12:06,940 --> 00:12:08,870
How fast is that?

177
00:12:08,870 --> 00:12:10,830
And now, we're going to see if
Mitchell has answered the

178
00:12:10,830 --> 00:12:13,620
question I asked in the
way in the class.

179
00:12:13,620 --> 00:12:17,710
How many instructions can a
computer execute between the

180
00:12:17,710 --> 00:12:20,240
time I say something and the
time the people in the back

181
00:12:20,240 --> 00:12:23,780
row hear it?

182
00:12:23,780 --> 00:12:27,950
Mitch thinks it's 400 million
instructions.

183
00:12:27,950 --> 00:12:29,370
I think that's about right.

184
00:12:29,370 --> 00:12:32,220
It's hundreds of millions
at any rate.

185
00:12:32,220 --> 00:12:34,750
It's kind of amazing between the
time I say something and

186
00:12:34,750 --> 00:12:39,370
the time you hear it, hundreds
of millions of instructions.

187
00:12:39,370 --> 00:12:42,900
It's mind boggling
how fast that is.

188
00:12:42,900 --> 00:12:48,030
And that's why we can often use
these kind of solutions.

189
00:12:48,030 --> 00:12:50,570
Next lecture, actually, even
a little bit later in this

190
00:12:50,570 --> 00:12:54,320
lecture, I hope to get to an
example of why that doesn't

191
00:12:54,320 --> 00:12:58,940
really get the job done,
at least not always.

192
00:12:58,940 --> 00:13:02,360
Before I do that, I want
to look at one

193
00:13:02,360 --> 00:13:04,910
more programming construct.

194
00:13:04,910 --> 00:13:09,070
And that's a variant
on the while loop.

195
00:13:09,070 --> 00:13:11,560
So if we think about what the
while loop we were just

196
00:13:11,560 --> 00:13:19,720
looking at did or does, as the
decrementing function told us,

197
00:13:19,720 --> 00:13:23,040
it's looking at all the possible
values of answer

198
00:13:23,040 --> 00:13:28,160
ranging from 0 to the
absolute value of x.

199
00:13:28,160 --> 00:13:32,110
And at each step testing and
doing something, we can

200
00:13:32,110 --> 00:13:36,575
abstract this process using
something called a for loop.

201
00:13:54,200 --> 00:13:57,380
So let's look at this code.

202
00:13:57,380 --> 00:14:01,610
It's essentially exactly
the same algorithm.

203
00:14:01,610 --> 00:14:05,840
I got bored of typing ans
times ans times ans.

204
00:14:05,840 --> 00:14:10,990
So I used a Python notation
for exponentiation, which

205
00:14:10,990 --> 00:14:12,800
you'll see is star, star.

206
00:14:16,590 --> 00:14:21,930
Now, be easier to read
if I get rid of that.

207
00:14:21,930 --> 00:14:24,760
But other than that, the
interesting thing I did was

208
00:14:24,760 --> 00:14:28,890
replace the while
loop by a for.

209
00:14:28,890 --> 00:14:34,170
So you'll see this line of code
there, for ans in range 0

210
00:14:34,170 --> 00:14:38,710
to abs of x plus 1.

211
00:14:38,710 --> 00:14:46,350
What that says is range is a
built-in function of Python

212
00:14:46,350 --> 00:14:52,130
that generates, in this case,
a sequence of integers,

213
00:14:52,130 --> 00:14:55,670
something called a tuple, which
we'll be looking at in a

214
00:14:55,670 --> 00:14:57,360
lecture or so.

215
00:14:57,360 --> 00:15:01,130
But for now, it's pretty simple
to think about what you

216
00:15:01,130 --> 00:15:12,230
get is if you look at the
expression range of x to y,

217
00:15:12,230 --> 00:15:19,605
that gives me a sequence
of values, x, x plus 1

218
00:15:19,605 --> 00:15:24,550
up to y minus 1.

219
00:15:24,550 --> 00:15:28,330
Notice not up to y, but
up to y minus 1.

220
00:15:28,330 --> 00:15:30,900
So it gives me a sequence
of length y--

221
00:15:34,080 --> 00:15:37,970
well, assuming that's 0.

222
00:15:37,970 --> 00:15:38,900
Right?

223
00:15:38,900 --> 00:15:40,880
It doesn't have to be 0.

224
00:15:40,880 --> 00:15:41,475
It can be anything.

225
00:15:41,475 --> 00:15:46,210
It can be another
value as well.

226
00:15:46,210 --> 00:15:48,950
0 in my example.

227
00:15:48,950 --> 00:15:54,450
And then, the for loop executes
it on this value and

228
00:15:54,450 --> 00:15:57,910
the next iteration on this
value, and finally, at the

229
00:15:57,910 --> 00:16:01,400
very end on that value.

230
00:16:01,400 --> 00:16:06,280
So it executes it one iteration
of the loop on each

231
00:16:06,280 --> 00:16:10,290
value in this sequence
of values generated

232
00:16:10,290 --> 00:16:11,540
by the range statement.

233
00:16:14,100 --> 00:16:16,460
And normally, it does
all of them.

234
00:16:16,460 --> 00:16:22,290
However, you'll see I've added
something called a break here,

235
00:16:22,290 --> 00:16:24,460
a command in Python.

236
00:16:24,460 --> 00:16:27,905
And what break says
is exit the loop.

237
00:16:30,720 --> 00:16:35,670
So it exits it prematurely
without executing all of the

238
00:16:35,670 --> 00:16:37,265
values generated by range.

239
00:16:42,670 --> 00:16:46,310
You can nest loops just like
you nest if statements.

240
00:16:46,310 --> 00:16:49,880
And if you do that break,
always executes--

241
00:16:49,880 --> 00:16:52,370
always exits rather the
innermost loop.

242
00:16:54,940 --> 00:16:57,700
So what this does is it's
generates a set

243
00:16:57,700 --> 00:17:00,390
of values to test.

244
00:17:00,390 --> 00:17:03,800
It checks whether or not
it's got the answer.

245
00:17:03,800 --> 00:17:06,290
If it does, it terminates
the loop.

246
00:17:09,780 --> 00:17:12,020
And eventually, you
exit the loop.

247
00:17:12,020 --> 00:17:14,869
And then, it just checks as
before whether or not it found

248
00:17:14,869 --> 00:17:19,589
a correct answer and does
the right thing.

249
00:17:19,589 --> 00:17:23,460
So you'll find, particularly
when you're iterating over

250
00:17:23,460 --> 00:17:26,470
integers, but later we'll see
when you're iterating over a

251
00:17:26,470 --> 00:17:31,410
lot of other kinds of things,
for loops are a very

252
00:17:31,410 --> 00:17:34,350
convenient shorthand.

253
00:17:34,350 --> 00:17:36,540
There's nothing you can't
do with a while loop.

254
00:17:36,540 --> 00:17:38,640
You don't need for loops.

255
00:17:38,640 --> 00:17:40,530
But they do make life easy.

256
00:17:40,530 --> 00:17:44,470
And over the semester, I think
you'll end up writing a lot

257
00:17:44,470 --> 00:17:47,650
more for loops than you
will while loops.

258
00:17:50,950 --> 00:17:52,380
Any questions about this?

259
00:17:55,560 --> 00:17:57,620
If not, I'm going to
move right along.

260
00:17:57,620 --> 00:18:01,280
So this is the moment.

261
00:18:01,280 --> 00:18:03,570
I'm going to move right along.

262
00:18:03,570 --> 00:18:06,840
So we've now got a program that
does something really

263
00:18:06,840 --> 00:18:08,770
silly, really.

264
00:18:08,770 --> 00:18:15,160
It finds cube roots
of perfect cubes.

265
00:18:15,160 --> 00:18:17,220
Well, that's not typically
useful.

266
00:18:17,220 --> 00:18:17,680
Right?

267
00:18:17,680 --> 00:18:21,960
You've even got these $0.50 four
function calculators that

268
00:18:21,960 --> 00:18:23,910
find square roots.

269
00:18:23,910 --> 00:18:28,570
And they don't insist that you
only give it perfect squares.

270
00:18:28,570 --> 00:18:31,130
So now, let's think about how
we would take this kind of

271
00:18:31,130 --> 00:18:36,440
program, and indeed, this kind
of method of writing programs

272
00:18:36,440 --> 00:18:38,570
and use it to find--

273
00:18:38,570 --> 00:18:43,610
for now, we'll look at the
square root of any number, of

274
00:18:43,610 --> 00:18:45,050
any floating point number.

275
00:18:48,820 --> 00:18:52,450
Well, the first question we need
to ask is what do I mean?

276
00:18:55,050 --> 00:18:56,930
That's kind of a subtle
question.

277
00:18:56,930 --> 00:18:58,945
What does it mean to find the
square root of a number?

278
00:19:01,480 --> 00:19:03,180
What does it mean, for
example, to find the

279
00:19:03,180 --> 00:19:04,430
square root of 2?

280
00:19:07,130 --> 00:19:14,340
Well, we know that that was an
endless series of digits

281
00:19:14,340 --> 00:19:16,190
before we can find the
square root of 2.

282
00:19:16,190 --> 00:19:16,550
Right?

283
00:19:16,550 --> 00:19:19,740
It does not have
a nice answer.

284
00:19:19,740 --> 00:19:23,030
So we can't just say we have to
find something that if we

285
00:19:23,030 --> 00:19:26,370
multiply it by itself,
it will equal 2.

286
00:19:26,370 --> 00:19:28,030
Because we can't find
such a thing.

287
00:19:30,800 --> 00:19:33,170
So we've got to think
about a different

288
00:19:33,170 --> 00:19:35,590
notion of what we mean.

289
00:19:35,590 --> 00:19:37,890
Furthermore, even for some
numbers which there is a

290
00:19:37,890 --> 00:19:42,860
square root, it might be a
million decimal places long,

291
00:19:42,860 --> 00:19:47,260
and consequently, really
hard to find.

292
00:19:47,260 --> 00:19:50,270
So we need to think
about a different

293
00:19:50,270 --> 00:19:53,920
kind of concept here.

294
00:19:53,920 --> 00:20:11,070
And it's the concept of an
approximation, finding an

295
00:20:11,070 --> 00:20:14,570
answer that is good enough.

296
00:20:14,570 --> 00:20:17,560
So what should we do here?

297
00:20:17,560 --> 00:20:19,770
How do we think about this?

298
00:20:19,770 --> 00:20:25,690
Typically, what we do when we
think about an approximation

299
00:20:25,690 --> 00:20:30,110
is we define how good
an approximation

300
00:20:30,110 --> 00:20:31,360
we're willing to accept.

301
00:20:35,590 --> 00:20:40,960
So for example, we might want
to say, I want to find a

302
00:20:40,960 --> 00:20:44,750
square root that lies
within epsilon of

303
00:20:44,750 --> 00:20:48,120
the true square root.

304
00:20:48,120 --> 00:21:11,410
So find a y such that y times
y is equal to what?

305
00:21:11,410 --> 00:21:12,180
What does it mean?

306
00:21:12,180 --> 00:21:15,605
How would I express it within
epsilon of the perfect answer?

307
00:21:18,240 --> 00:21:21,860
I don't want to say it's equal
to x, because that may be

308
00:21:21,860 --> 00:21:26,820
impossible or too time
consuming to find.

309
00:21:26,820 --> 00:21:30,890
So really, what I mean is
x plus or minus epsilon.

310
00:21:37,200 --> 00:21:38,350
So that's what I'm asking.

311
00:21:38,350 --> 00:21:39,930
Find one that's close enough.

312
00:21:43,290 --> 00:21:45,190
And that's what the next
piece of code I

313
00:21:45,190 --> 00:21:46,440
want to show you does.

314
00:22:12,620 --> 00:22:15,490
Excuse me.

315
00:22:15,490 --> 00:22:19,510
So I'm starting, just giving it
a value for x, so I don't

316
00:22:19,510 --> 00:22:20,680
have to keep typing one in.

317
00:22:20,680 --> 00:22:21,930
Let's say it's 25.

318
00:22:24,290 --> 00:22:28,630
I'm going to take epsilon
to be 0.01.

319
00:22:28,630 --> 00:22:31,585
So I want it within that
distance of the true answer.

320
00:22:34,330 --> 00:22:37,810
I'm going to keep track of the
number of guesses here, not

321
00:22:37,810 --> 00:22:40,540
because we need it to actually
compute the answer, but

322
00:22:40,540 --> 00:22:43,600
because I want to then discuss
how many iterations of the

323
00:22:43,600 --> 00:22:46,080
loop we're doing.

324
00:22:46,080 --> 00:22:51,270
We're going to start by setting
my first guess at 0.0.

325
00:22:51,270 --> 00:22:55,570
Again, this is going to be
exhaustive enumeration.

326
00:22:55,570 --> 00:23:00,250
Then, I'm going to essentially
encode this as a test of my

327
00:23:00,250 --> 00:23:05,280
while loop while the absolute
value of answer squared minus

328
00:23:05,280 --> 00:23:11,630
x is greater than or equal to
epsilon, and answer is less

329
00:23:11,630 --> 00:23:13,200
than equal to x.

330
00:23:13,200 --> 00:23:15,360
So it's now a more
complicated test.

331
00:23:15,360 --> 00:23:17,180
I've got a Boolean value.

332
00:23:17,180 --> 00:23:22,180
Two things have to be true to
execute the body of the loop.

333
00:23:22,180 --> 00:23:28,430
I'm going to increment answer
by a tiny amount, increment

334
00:23:28,430 --> 00:23:31,140
the number of guesses just so
I can keep track of it.

335
00:23:34,610 --> 00:23:36,710
Maybe I'm going to comment
this out for the first go

336
00:23:36,710 --> 00:23:41,850
around just so we don't see too
many print statements and

337
00:23:41,850 --> 00:23:43,100
keep doing it.

338
00:23:46,510 --> 00:23:48,370
And then when I'm done I'm going
to see whether or not

339
00:23:48,370 --> 00:23:54,630
what I found is indeed a square
root or close enough.

340
00:23:54,630 --> 00:23:58,470
So if we think about why this
loop terminates, why am I

341
00:23:58,470 --> 00:24:01,600
guaranteed that this loop
will terminate?

342
00:24:01,600 --> 00:24:03,660
What's my decrementing
function here?

343
00:24:08,440 --> 00:24:09,690
Somebody?

344
00:24:11,280 --> 00:24:13,380
What's the decrementing
function?

345
00:24:13,380 --> 00:24:17,180
What am I guaranteed to reduce
each time through, and when I

346
00:24:17,180 --> 00:24:18,430
get through, I'm done?

347
00:24:22,960 --> 00:24:24,250
Yeah?

348
00:24:24,250 --> 00:24:26,600
AUDIENCE: [INAUDIBLE]

349
00:24:26,600 --> 00:24:31,458
answer squared minus
x1 times 1.

350
00:24:31,458 --> 00:24:32,660
PROFESSOR: No.

351
00:24:32,660 --> 00:24:34,930
Close, sort of.

352
00:24:34,930 --> 00:24:37,640
But I appreciate
you're trying.

353
00:24:37,640 --> 00:24:40,840
That's worth something
just for the effort.

354
00:24:40,840 --> 00:24:43,450
Somebody else.

355
00:24:43,450 --> 00:24:48,040
Remember, if we look at the
properties it has to have,

356
00:24:48,040 --> 00:24:50,940
it's going to guarantee me that
when it gets to the right

357
00:24:50,940 --> 00:24:54,360
value, I exit the loop, which
suggests it's going to

358
00:24:54,360 --> 00:24:56,420
certainly be part of the
test of the while.

359
00:25:00,560 --> 00:25:02,790
Just look at this piece
over here at the end.

360
00:25:06,770 --> 00:25:09,450
Answer starts at 0.

361
00:25:09,450 --> 00:25:12,940
I keep incrementing it.

362
00:25:12,940 --> 00:25:20,910
Eventually, answer minus x
will hit a value, right?

363
00:25:20,910 --> 00:25:23,390
Eventually, I'll get to
the point that this

364
00:25:23,390 --> 00:25:25,920
condition must be true--

365
00:25:25,920 --> 00:25:27,150
must be false rather.

366
00:25:27,150 --> 00:25:28,400
And then, I exit the loop.

367
00:25:31,590 --> 00:25:35,650
So this piece is not
really the key.

368
00:25:35,650 --> 00:25:37,940
It's this piece that guarantees
me I'm going to get

369
00:25:37,940 --> 00:25:39,190
out eventually.

370
00:25:41,650 --> 00:25:44,090
This piece can get
me out sooner.

371
00:25:44,090 --> 00:25:45,870
It's kind of an optimization,
if you will.

372
00:25:49,980 --> 00:25:52,780
So I'm just going to go until
I find the answer.

373
00:25:52,780 --> 00:25:54,320
Let's see what happens
when I run it.

374
00:26:00,860 --> 00:26:06,190
It tells me that 4.99, et cetera
is close to the square

375
00:26:06,190 --> 00:26:09,350
root of 25.

376
00:26:09,350 --> 00:26:13,210
So there are some things
to note about this.

377
00:26:13,210 --> 00:26:19,000
First, it didn't find 5, 25
happens to be a perfect

378
00:26:19,000 --> 00:26:21,790
square, yet I didn't find it.

379
00:26:21,790 --> 00:26:24,210
Is that OK?

380
00:26:24,210 --> 00:26:25,050
Yeah.

381
00:26:25,050 --> 00:26:27,220
Because that wasn't
what I said.

382
00:26:27,220 --> 00:26:30,050
What I said is find
a y that has these

383
00:26:30,050 --> 00:26:32,860
properties over here.

384
00:26:32,860 --> 00:26:34,740
And I did.

385
00:26:34,740 --> 00:26:37,160
I didn't say find the y that
gets closest to the

386
00:26:37,160 --> 00:26:38,850
square root of x.

387
00:26:38,850 --> 00:26:43,340
I said find one that has
these properties.

388
00:26:43,340 --> 00:26:51,030
Effectively, what this is is a
specification of the problem.

389
00:26:56,410 --> 00:26:59,150
And I've now written a piece
of code that meets the

390
00:26:59,150 --> 00:27:00,730
specification.

391
00:27:00,730 --> 00:27:03,980
It does what I set out to do,
and that's good enough.

392
00:27:09,060 --> 00:27:15,410
Now, let's turn this print
statement back on.

393
00:27:20,370 --> 00:27:24,040
It took almost 1/2 million
guesses to get there.

394
00:27:28,200 --> 00:27:31,280
But it was still blindingly
fast.

395
00:27:31,280 --> 00:27:36,070
So once again, exhaustive
enumeration seems to be OK.

396
00:27:36,070 --> 00:27:42,770
Suppose, however, I choose
a bigger number.

397
00:27:42,770 --> 00:27:49,296
Now, first, let's choose
something that doesn't have a

398
00:27:49,296 --> 00:27:50,450
good answer.

399
00:27:50,450 --> 00:27:51,700
Let's see what it
does for that.

400
00:27:54,140 --> 00:27:55,110
All right.

401
00:27:55,110 --> 00:27:56,650
Pretty good.

402
00:27:56,650 --> 00:27:58,640
Also pretty fast.

403
00:27:58,640 --> 00:28:00,540
Not too many guesses.

404
00:28:00,540 --> 00:28:02,440
But now, let's try this one.

405
00:28:12,670 --> 00:28:14,230
Well, it's going to wait.

406
00:28:14,230 --> 00:28:16,110
It's going to get done, but it's
going to take a little

407
00:28:16,110 --> 00:28:21,060
bit longer than maybe
we want it to take.

408
00:28:21,060 --> 00:28:22,940
Why is it taking so long?

409
00:28:22,940 --> 00:28:23,490
There it is.

410
00:28:23,490 --> 00:28:28,320
It found an answer, which
I think is good.

411
00:28:28,320 --> 00:28:30,010
But as you can see, it
took quite a few

412
00:28:30,010 --> 00:28:33,770
guesses to get there.

413
00:28:33,770 --> 00:28:35,430
So why?

414
00:28:35,430 --> 00:28:38,010
Well, let me first ask
this question.

415
00:28:38,010 --> 00:28:45,710
Can we look at the code and
anticipate how many guesses

416
00:28:45,710 --> 00:28:49,350
it's going to have to take?

417
00:28:49,350 --> 00:28:52,650
We're going back to this issue
of computational complexity,

418
00:28:52,650 --> 00:28:56,390
but here, not of the problem
but of the solution.

419
00:28:56,390 --> 00:28:59,160
So this is algorithmic
analysis.

420
00:28:59,160 --> 00:29:03,440
We're analyzing the algorithm,
this exhaustive enumeration

421
00:29:03,440 --> 00:29:07,430
algorithm, and trying to figure
out how long it's

422
00:29:07,430 --> 00:29:10,420
likely to take to run.

423
00:29:10,420 --> 00:29:11,890
Well, what does the running
time of this

424
00:29:11,890 --> 00:29:13,220
algorithm depend upon?

425
00:29:16,740 --> 00:29:18,236
Yeah?

426
00:29:18,236 --> 00:29:19,550
AUDIENCE: [INAUDIBLE].

427
00:29:19,550 --> 00:29:24,180
PROFESSOR: It depends on
the actual square root.

428
00:29:24,180 --> 00:29:24,740
Yes.

429
00:29:24,740 --> 00:29:28,070
But in particular, the distance
of the actual square

430
00:29:28,070 --> 00:29:30,970
root from the starting point.

431
00:29:30,970 --> 00:29:33,760
So that's one factor
it depends on.

432
00:29:33,760 --> 00:29:35,520
But that's not the
only factor.

433
00:29:35,520 --> 00:29:36,790
What else does it depend on?

434
00:29:40,630 --> 00:29:45,290
Oh, do we have an injury?

435
00:29:45,290 --> 00:29:48,420
We had a dropped pass and
a deflection there.

436
00:29:48,420 --> 00:29:50,300
All right.

437
00:29:50,300 --> 00:29:51,680
Yes?

438
00:29:51,680 --> 00:29:54,855
AUDIENCE: It depends on the
level of accuracy, so how you

439
00:29:54,855 --> 00:29:55,560
define epsilon.

440
00:29:55,560 --> 00:29:58,790
PROFESSOR: It depends upon
the value of epsilon.

441
00:29:58,790 --> 00:30:00,040
Absolutely.

442
00:30:01,670 --> 00:30:03,190
How long it takes to run.

443
00:30:03,190 --> 00:30:04,440
AUDIENCE: [INAUDIBLE].

444
00:30:08,514 --> 00:30:10,665
PROFESSOR: Someone with
a concern for safety.

445
00:30:13,680 --> 00:30:17,040
it depends upon the actual value
of epsilon, because if

446
00:30:17,040 --> 00:30:22,510
epsilon is small, we may have
to take more steps to get a

447
00:30:22,510 --> 00:30:24,330
precise enough answer.

448
00:30:24,330 --> 00:30:27,970
And it depends upon
one more thing.

449
00:30:27,970 --> 00:30:28,410
Yeah?

450
00:30:28,410 --> 00:30:30,910
AUDIENCE: [INAUDIBLE] the
increment that [INAUDIBLE]?

451
00:30:30,910 --> 00:30:32,120
PROFESSOR: The increment.

452
00:30:32,120 --> 00:30:33,150
Exactly.

453
00:30:33,150 --> 00:30:36,740
Because the number of times we
go through the loop is going

454
00:30:36,740 --> 00:30:39,660
to be related to how
big a step we

455
00:30:39,660 --> 00:30:40,970
take each time through.

456
00:30:45,900 --> 00:30:47,470
No applause?

457
00:30:47,470 --> 00:30:50,670
Thank you.

458
00:30:50,670 --> 00:30:54,080
So it depends upon all
of these things.

459
00:30:54,080 --> 00:30:59,170
And here, since we're trying
to find a pretty [? big ?]

460
00:30:59,170 --> 00:31:05,130
square root and a sort of
precise answer, but we're

461
00:31:05,130 --> 00:31:07,540
taking tiny steps, it's
going to take a

462
00:31:07,540 --> 00:31:09,950
long time to execute.

463
00:31:09,950 --> 00:31:12,220
So we could make it faster.

464
00:31:12,220 --> 00:31:20,240
For example, suppose I change
the step size to this.

465
00:31:24,850 --> 00:31:28,580
Plus equal by says increment
the value by whatever the

466
00:31:28,580 --> 00:31:29,920
right side is.

467
00:31:29,920 --> 00:31:31,690
So I'm going to increment
it by 1.

468
00:31:44,430 --> 00:31:46,770
Wow, it was really fast.

469
00:31:46,770 --> 00:31:47,700
But it didn't work.

470
00:31:47,700 --> 00:31:51,430
It failed.

471
00:31:51,430 --> 00:31:54,840
That's not so good.

472
00:31:54,840 --> 00:31:56,410
So I can't just do that.

473
00:31:56,410 --> 00:31:58,820
And of course, it's not
surprising, because I ended up

474
00:31:58,820 --> 00:32:02,670
jumping all over the answer.

475
00:32:02,670 --> 00:32:08,730
I could make epsilon smaller,
but that seems like cheating.

476
00:32:08,730 --> 00:32:15,030
So really, what I need to do is
find a better algorithm, a

477
00:32:15,030 --> 00:32:17,040
better way to attack
the problem.

478
00:32:19,680 --> 00:32:22,420
Fortunately, I don't
have to invent it.

479
00:32:22,420 --> 00:32:26,880
Some people a lot smarter than
I am figured out a long time

480
00:32:26,880 --> 00:32:32,340
ago a good method for solving
this kind of problem.

481
00:32:32,340 --> 00:32:35,360
And they're doing it
using something

482
00:32:35,360 --> 00:32:36,940
called bisection search.

483
00:32:49,370 --> 00:32:53,040
As we look at this particular
implementation of it, we're

484
00:32:53,040 --> 00:32:58,060
going to use two algorithmic
techniques that you'll use

485
00:32:58,060 --> 00:33:01,930
over and over again because
they're generally useful.

486
00:33:01,930 --> 00:33:07,810
So the first one related to
bisection search is we'll cut

487
00:33:07,810 --> 00:33:18,415
the search space in half
each iteration.

488
00:33:23,720 --> 00:33:27,320
So with my brute force
algorithm, we're trimming the

489
00:33:27,320 --> 00:33:31,610
search base only a little
bit each step.

490
00:33:31,610 --> 00:33:38,040
So if we think about it, what it
looks like, we had a space

491
00:33:38,040 --> 00:33:40,000
of values to search
for the answer.

492
00:33:42,830 --> 00:33:45,780
And I started here.

493
00:33:45,780 --> 00:33:49,750
And each step, I just trimmed
off a tiny, tiny little bit,

494
00:33:49,750 --> 00:33:55,280
0.001, leaving me a lot
of space to search.

495
00:33:55,280 --> 00:33:57,640
And that's why it
took so long.

496
00:33:57,640 --> 00:34:05,170
When I do bisection search, the
basic idea is each step I

497
00:34:05,170 --> 00:34:09,170
want to cut the search
space in half.

498
00:34:09,170 --> 00:34:13,600
Get rid of half of the search
space each time.

499
00:34:13,600 --> 00:34:18,540
So one way I could do
it is I start with a

500
00:34:18,540 --> 00:34:22,870
guess say in the middle.

501
00:34:22,870 --> 00:34:28,060
Just pick some guess that's in
the middle of my search space.

502
00:34:28,060 --> 00:34:31,270
And now I say is it too
high or too low?

503
00:34:34,000 --> 00:34:35,850
I can easily answer
that question.

504
00:34:35,850 --> 00:34:37,560
I square it.

505
00:34:37,560 --> 00:34:40,420
See is my result bigger than
the actual square root or

506
00:34:40,420 --> 00:34:43,199
smaller than the actual
square root?

507
00:34:43,199 --> 00:34:47,370
That tells me whether my guess
is too big or too small.

508
00:34:47,370 --> 00:34:51,989
Once I know that, I know which
side of the guess the right

509
00:34:51,989 --> 00:34:53,239
answer is on.

510
00:34:55,800 --> 00:35:00,970
So if I knew that my guess was
too big, then I know there's

511
00:35:00,970 --> 00:35:04,410
no point in looking over
here for my next guess.

512
00:35:04,410 --> 00:35:07,560
So I can get rid of this
whole half in one step.

513
00:35:12,160 --> 00:35:13,690
Now, what should my
next guess be?

514
00:35:16,850 --> 00:35:17,320
Yeah?

515
00:35:17,320 --> 00:35:19,248
AUDIENCE: [INAUDIBLE].

516
00:35:19,248 --> 00:35:20,680
PROFESSOR: My next
guess should be

517
00:35:20,680 --> 00:35:23,960
half way through there.

518
00:35:23,960 --> 00:35:25,210
Exactly.

519
00:35:30,230 --> 00:35:37,530
And now, let's say this time
my answer is too small.

520
00:35:37,530 --> 00:35:39,080
Then I know I can
get rid of this.

521
00:35:42,820 --> 00:35:46,175
So now, I'm very quickly pruning
my search space.

522
00:35:52,550 --> 00:35:57,150
If I think about that, how many
times am I likely to have

523
00:35:57,150 --> 00:35:58,400
to prune it?

524
00:36:05,300 --> 00:36:08,480
It's much faster, right?

525
00:36:08,480 --> 00:36:14,680
As we'll see later, it's
basically log base 2.

526
00:36:14,680 --> 00:36:19,880
If I have some number of
values to look at--

527
00:36:19,880 --> 00:36:22,770
and by the way, how many values
do I have in my search

528
00:36:22,770 --> 00:36:26,130
space to start with?

529
00:36:26,130 --> 00:36:27,520
What determines it?

530
00:36:27,520 --> 00:36:36,250
Clearly, the first value and the
last value, but also, how

531
00:36:36,250 --> 00:36:38,425
small I'm dividing it up.

532
00:36:42,200 --> 00:36:43,080
Right?

533
00:36:43,080 --> 00:36:45,350
So I have to think
about that too.

534
00:36:45,350 --> 00:36:50,060
What is the precision with
which I do this.

535
00:36:50,060 --> 00:36:52,650
Am I looking at every
one millionth of a

536
00:36:52,650 --> 00:36:55,580
number or every 0.01?

537
00:36:55,580 --> 00:36:57,940
That will tell me
how big it is.

538
00:36:57,940 --> 00:37:05,740
Once I know how big my search
space is, I know that if I

539
00:37:05,740 --> 00:37:09,780
search it linearly looking at
every value, my worst cases, I

540
00:37:09,780 --> 00:37:11,860
look at everything until
I get to the end.

541
00:37:15,330 --> 00:37:17,370
Well, my best case is
I get lucky, and my

542
00:37:17,370 --> 00:37:19,230
first guess is right.

543
00:37:19,230 --> 00:37:23,700
But if I use bisection search,
my worst case is going to be

544
00:37:23,700 --> 00:37:27,360
log number of values
in that space.

545
00:37:27,360 --> 00:37:32,010
Because each time, I throw
half of them away.

546
00:37:32,010 --> 00:37:35,700
We'll see that in more
detail later on.

547
00:37:35,700 --> 00:37:37,800
Let's go back and look
at the code now.

548
00:37:57,980 --> 00:38:01,640
So it starts as before with
a value for epsilon.

549
00:38:01,640 --> 00:38:06,970
But now, I'm going to take a
lower bound, here, and an

550
00:38:06,970 --> 00:38:08,705
upper bound on my
search space.

551
00:38:12,430 --> 00:38:15,840
I'm going to say my initial
guess will be the upper bound

552
00:38:15,840 --> 00:38:19,100
plus the lower bound
over 2 halfway

553
00:38:19,100 --> 00:38:20,350
through my search space.

554
00:38:25,510 --> 00:38:30,390
And then, I'm just going to work
my way through it until I

555
00:38:30,390 --> 00:38:33,780
get to the answer or
don't find it.

556
00:38:37,380 --> 00:38:40,050
So should we look at what's
going on here?

557
00:38:40,050 --> 00:38:41,300
Let's try this.

558
00:38:43,420 --> 00:38:54,270
Well, let's first make sure it
works for a small value.

559
00:38:54,270 --> 00:38:57,580
Never test your program first
on something big.

560
00:38:57,580 --> 00:39:00,040
Always try your program in
something small first.

561
00:39:02,950 --> 00:39:04,200
Let's try it on that.

562
00:39:08,100 --> 00:39:09,350
Got an answer.

563
00:39:11,720 --> 00:39:14,930
Notice that it's different from
the answer we got last

564
00:39:14,930 --> 00:39:16,535
time we looked for the
square root of 25.

565
00:39:19,220 --> 00:39:24,830
But that's OK, because it's
still meets the specification.

566
00:39:24,830 --> 00:39:28,420
It's still within epsilon of
the actual square root.

567
00:39:28,420 --> 00:39:31,970
And I didn't have to say that
I wanted it below or the

568
00:39:31,970 --> 00:39:35,390
square root or above, just
said within epsilon.

569
00:39:35,390 --> 00:39:38,960
Sure enough, different
algorithm, different answer,

570
00:39:38,960 --> 00:39:44,990
but equally good, but
a lot faster.

571
00:39:44,990 --> 00:39:47,395
Now let's try it for
the big value.

572
00:40:04,130 --> 00:40:06,264
Wow, that was a lot
faster, wasn't it?

573
00:40:11,370 --> 00:40:14,350
It got me an answer.

574
00:40:14,350 --> 00:40:16,340
Probably, not exactly
the same answer as

575
00:40:16,340 --> 00:40:19,310
before but pretty close.

576
00:40:19,310 --> 00:40:23,530
But it did it in only
26 guesses.

577
00:40:23,530 --> 00:40:25,610
Pretty cool.

578
00:40:25,610 --> 00:40:30,410
And in fact, we'll see over and
over again that bisection

579
00:40:30,410 --> 00:40:34,250
search is a really good
technique for

580
00:40:34,250 --> 00:40:35,980
finding quick answers.

581
00:40:40,900 --> 00:40:43,850
And again, why is it 26?

582
00:40:43,850 --> 00:40:48,350
Well, we had some number of
guesses to start with.

583
00:40:48,350 --> 00:40:52,850
After 1, it was half as big,
then a quarter is big, and

584
00:40:52,850 --> 00:40:56,430
eventually, log 2 of the size.

585
00:40:56,430 --> 00:40:59,270
But what was the size?

586
00:40:59,270 --> 00:41:05,780
Was it the number 12345?

587
00:41:05,780 --> 00:41:06,380
No.

588
00:41:06,380 --> 00:41:10,270
We already sort of talked
about that.

589
00:41:10,270 --> 00:41:11,860
What was it?

590
00:41:11,860 --> 00:41:16,760
Let's look at the code, and
let's think about what was the

591
00:41:16,760 --> 00:41:18,465
size of our initial
search space.

592
00:41:22,320 --> 00:41:24,680
It's a little bit tricky to
think about this, right?

593
00:41:31,350 --> 00:41:35,830
Now, we have to think a little
bit harder about when we exit

594
00:41:35,830 --> 00:41:38,940
the loop, because in
fundamentally, that's telling

595
00:41:38,940 --> 00:41:40,345
me the size of the
search space.

596
00:41:42,890 --> 00:41:45,410
So what determined the size
of the search space?

597
00:41:54,386 --> 00:41:57,810
Well, we talked about the upper
and the lower bound.

598
00:41:57,810 --> 00:42:00,950
But what's telling me
roughly speaking how

599
00:42:00,950 --> 00:42:05,450
many divisions I have?

600
00:42:05,450 --> 00:42:06,700
It's epsilon.

601
00:42:08,700 --> 00:42:13,760
It's not 0.01 because when
I square it, it has to be

602
00:42:13,760 --> 00:42:16,110
smaller than 0.01.

603
00:42:16,110 --> 00:42:18,590
But that tells me roughly
how many I have.

604
00:42:21,740 --> 00:42:27,970
And so it's going to be roughly
12345 divided by 0.01

605
00:42:27,970 --> 00:42:35,170
squared, which turns out to
be 26.897 more or less.

606
00:42:35,170 --> 00:42:38,170
So we could predict it.

607
00:42:38,170 --> 00:42:41,360
And son of a gun, when we ran
it, we actually matched the

608
00:42:41,360 --> 00:42:43,760
prediction.

609
00:42:43,760 --> 00:42:46,930
That's the great thing about
algorithmic analysis.

610
00:42:46,930 --> 00:42:50,320
We can actually get accurate
guesses as to how long a

611
00:42:50,320 --> 00:42:53,560
program is likely
to take to run.

612
00:42:53,560 --> 00:42:56,815
This is an important thing
because sometimes we do that

613
00:42:56,815 --> 00:42:58,480
and we say, oh, it's going
to take a year.

614
00:42:58,480 --> 00:42:59,990
I better not even try.

615
00:42:59,990 --> 00:43:02,560
I better find a smarter
algorithm.

616
00:43:02,560 --> 00:43:05,140
Or we do it and say, well, it's
going to take almost no

617
00:43:05,140 --> 00:43:06,220
time at all.

618
00:43:06,220 --> 00:43:07,960
I'm not going to waste
my time looking

619
00:43:07,960 --> 00:43:09,470
for a smarter algorithm.

620
00:43:09,470 --> 00:43:12,950
I'm going to live with
the one I've got.

621
00:43:12,950 --> 00:43:15,530
It's important, and again, as
I said, it's a topic we're

622
00:43:15,530 --> 00:43:17,720
going to get back to.

623
00:43:17,720 --> 00:43:21,260
Of course, whether it's
26, 27, or even 50

624
00:43:21,260 --> 00:43:23,020
doesn't really matter.

625
00:43:23,020 --> 00:43:26,160
What matters is it's
not a billion.

626
00:43:26,160 --> 00:43:26,710
Right?

627
00:43:26,710 --> 00:43:29,640
Because we don't really care
small differences.

628
00:43:29,640 --> 00:43:32,730
Whether it takes 25 or it
takes 50 will be an

629
00:43:32,730 --> 00:43:35,140
imperceptible difference.

630
00:43:35,140 --> 00:43:38,110
It's whether it's a huge
difference that matters.

631
00:43:38,110 --> 00:43:42,450
And that's really the kind of
things we're going after is

632
00:43:42,450 --> 00:43:45,530
orders of magnitude.

633
00:43:45,530 --> 00:43:49,810
Now, I have a question
about this program.

634
00:43:49,810 --> 00:43:52,330
I've been obsessing about
whether it's fast enough.

635
00:43:52,330 --> 00:43:54,250
And we've shown it is.

636
00:43:54,250 --> 00:43:55,980
But does it work?

637
00:43:55,980 --> 00:43:57,550
Kind of more important.

638
00:43:57,550 --> 00:44:00,300
It's always possible to write
a really fast program that

639
00:44:00,300 --> 00:44:02,770
gives you the wrong answer.

640
00:44:02,770 --> 00:44:04,790
The problem is to write a fast
program that give you the

641
00:44:04,790 --> 00:44:06,530
right answer.

642
00:44:06,530 --> 00:44:10,140
Does this program always work?

643
00:44:10,140 --> 00:44:11,590
Well, it worked for 25.

644
00:44:11,590 --> 00:44:15,010
It worked for 12345.

645
00:44:15,010 --> 00:44:16,750
Is that good enough?

646
00:44:16,750 --> 00:44:17,560
Probably not.

647
00:44:17,560 --> 00:44:21,360
We might want to try it
in some other values.

648
00:44:21,360 --> 00:44:23,040
I'll ask a simpler question.

649
00:44:23,040 --> 00:44:27,215
Does it always work on
positive values?

650
00:44:34,110 --> 00:44:34,440
All right.

651
00:44:34,440 --> 00:44:35,680
I'll give you a hint.

652
00:44:35,680 --> 00:44:37,370
No.

653
00:44:37,370 --> 00:44:38,620
It does not.

654
00:44:40,820 --> 00:44:44,190
I'm not going to, however,
tell you why it doesn't,

655
00:44:44,190 --> 00:44:46,040
because I want you to
think about it.

656
00:44:46,040 --> 00:44:47,690
And I want you to
tell me why it

657
00:44:47,690 --> 00:44:49,850
doesn't in the next lecture.

658
00:44:49,850 --> 00:44:55,810
But because I'm not a complete
sadist, I'll give you a hint.

659
00:44:55,810 --> 00:45:01,190
When we use bisection search, or
for that matter, any search

660
00:45:01,190 --> 00:45:08,630
method, we are depending upon
the fact that the answer lies

661
00:45:08,630 --> 00:45:10,470
somewhere in the region
we're searching.

662
00:45:13,840 --> 00:45:20,190
If indeed the answer is out
here or out here, then it

663
00:45:20,190 --> 00:45:24,670
doesn't matter how carefully
I search this region.

664
00:45:24,670 --> 00:45:26,130
I'm not going to find
the answer.

665
00:45:28,910 --> 00:45:35,260
And so this program doesn't work
on some potential values

666
00:45:35,260 --> 00:45:40,250
of x because the actual square
root of x will not lie in the

667
00:45:40,250 --> 00:45:44,000
region that the program
is searching.

668
00:45:44,000 --> 00:45:47,790
I leave it to you to think about
what such values are.

669
00:45:47,790 --> 00:45:52,540
And we can talk about that
on the next lecture.

670
00:45:55,440 --> 00:45:59,420
Suppose I want to use this
program to find the cube root.

671
00:45:59,420 --> 00:46:01,180
Suppose it worked, and
I want it to use it

672
00:46:01,180 --> 00:46:03,150
to find a cube root.

673
00:46:03,150 --> 00:46:04,170
What would I have to change?

674
00:46:04,170 --> 00:46:06,890
How would I change it, so it
found cube roots instead of

675
00:46:06,890 --> 00:46:08,140
square roots?

676
00:46:11,370 --> 00:46:12,740
Well, I can take it up.

677
00:46:12,740 --> 00:46:17,060
I could use cut and paste, and
paste it into my editor and

678
00:46:17,060 --> 00:46:18,670
get a new program.

679
00:46:18,670 --> 00:46:20,570
And how would I change
that new program to

680
00:46:20,570 --> 00:46:21,820
make it do cube roots?

681
00:46:24,480 --> 00:46:27,270
Not very hard.

682
00:46:27,270 --> 00:46:29,235
Think only two places
have to get changed.

683
00:46:33,150 --> 00:46:34,940
That's for the simplicity,
say cube

684
00:46:34,940 --> 00:46:36,305
roots of positive numbers.

685
00:46:43,220 --> 00:46:46,590
I think you said the
right thing.

686
00:46:46,590 --> 00:46:52,270
All I have to do is change that
two to a three and that

687
00:46:52,270 --> 00:46:56,220
two to a three, and I'm done.

688
00:46:56,220 --> 00:46:59,450
And I should probably change the
message to say cube root.

689
00:47:02,740 --> 00:47:03,990
Pretty easy.

690
00:47:06,550 --> 00:47:11,690
On the other hand, suppose I
also want it to find the

691
00:47:11,690 --> 00:47:15,150
fourth root, and the fifth
root, and the sixth root,

692
00:47:15,150 --> 00:47:17,180
however many roots.

693
00:47:17,180 --> 00:47:19,900
Well, I'm going to get pretty
tired of cutting, and pasting,

694
00:47:19,900 --> 00:47:23,790
and building a whole
bunch of things.

695
00:47:23,790 --> 00:47:27,590
So really, what I want to do
is find a way to write the

696
00:47:27,590 --> 00:47:35,100
code that will find the nth root
of a number for any n.

697
00:47:38,180 --> 00:47:42,270
To do that, I'm going
to introduce a

698
00:47:42,270 --> 00:47:44,690
new programming concept.

699
00:47:44,690 --> 00:47:47,670
And that concept is
the function.

700
00:47:47,670 --> 00:47:50,570
And that will be the main topic
of Thursday's lecture.