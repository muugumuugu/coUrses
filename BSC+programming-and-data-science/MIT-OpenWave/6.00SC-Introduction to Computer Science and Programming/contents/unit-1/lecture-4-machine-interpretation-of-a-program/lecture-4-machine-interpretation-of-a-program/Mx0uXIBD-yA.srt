1
00:00:00,040 --> 00:00:02,460
The following content is
provided under a Creative

2
00:00:02,460 --> 00:00:03,870
Commons license.

3
00:00:03,870 --> 00:00:06,910
Your support will help MIT
OpenCourseWare continue to

4
00:00:06,910 --> 00:00:10,560
offer high quality educational
resources for free.

5
00:00:10,560 --> 00:00:13,460
To make a donation or view
additional materials from

6
00:00:13,460 --> 00:00:19,290
hundreds of MIT courses, visit
MIT OpenCourseWare at

7
00:00:19,290 --> 00:00:20,540
ocw.mit.edu.

8
00:00:22,790 --> 00:00:24,880
PROFESSOR: For those of you who
are unaccustomed to seeing

9
00:00:24,880 --> 00:00:27,325
it, that blue stuff through
the window is called sky.

10
00:00:32,159 --> 00:00:33,340
OK.

11
00:00:33,340 --> 00:00:37,220
I left you last time
with a question.

12
00:00:37,220 --> 00:00:41,680
I'd shown you a bisection search
implementation, or I

13
00:00:41,680 --> 00:00:44,550
should say putative
implementation of the square

14
00:00:44,550 --> 00:00:49,400
root, and told you that it was
flawed, and asked you to think

15
00:00:49,400 --> 00:00:51,610
about what was wrong with it.

16
00:00:51,610 --> 00:00:53,320
So first, I'd just like
to take a poll.

17
00:00:53,320 --> 00:00:57,230
How many of you know what the
problem is, or at least what a

18
00:00:57,230 --> 00:00:59,280
problem is?

19
00:00:59,280 --> 00:01:01,320
OK well that's a good start.

20
00:01:01,320 --> 00:01:04,319
And I won't ask how many of
you don't know, because I

21
00:01:04,319 --> 00:01:06,700
presume that's the
rest of you.

22
00:01:06,700 --> 00:01:08,760
So let's look at it now.

23
00:01:08,760 --> 00:01:11,750
I'm not going to ask you the
answer, because I want to show

24
00:01:11,750 --> 00:01:13,890
people how to find it.

25
00:01:13,890 --> 00:01:18,500
So here's a slightly simplified
version of it.

26
00:01:25,920 --> 00:01:28,300
Just get rid of this stuff here,
so it doesn't confuse

27
00:01:28,300 --> 00:01:29,550
the picture.

28
00:01:35,070 --> 00:01:38,120
So this is roughly the one we
looked at on Tuesday, but I

29
00:01:38,120 --> 00:01:40,250
just took out some print
statements and things and

30
00:01:40,250 --> 00:01:42,230
simplified it.

31
00:01:42,230 --> 00:01:46,770
And let's just run it.

32
00:01:46,770 --> 00:01:49,620
And we'll run it with
trying to find the

33
00:01:49,620 --> 00:01:53,610
square root of 0.5.

34
00:01:53,610 --> 00:01:55,320
See what happens
when we run it.

35
00:02:01,730 --> 00:02:04,280
Well, not much happens
when we run it.

36
00:02:04,280 --> 00:02:05,700
Actually quite a lot
is happening.

37
00:02:05,700 --> 00:02:08,000
We just can't see it.

38
00:02:08,000 --> 00:02:12,960
So this program is running
longer than I expected it to.

39
00:02:12,960 --> 00:02:18,990
So if you go to the keyboard and
you hit Control and C. It

40
00:02:18,990 --> 00:02:20,190
will interrupt the program.

41
00:02:20,190 --> 00:02:23,980
It generates what's called
a keyboard interrupt,

42
00:02:23,980 --> 00:02:27,430
and it stops it.

43
00:02:27,430 --> 00:02:29,490
And it tells us where it
happened to stop it.

44
00:02:29,490 --> 00:02:33,300
It happened to stop
it in line seven--

45
00:02:33,300 --> 00:02:36,030
the test of the while loop.

46
00:02:36,030 --> 00:02:38,650
And the problem is, the program
just seemed to be

47
00:02:38,650 --> 00:02:40,740
running forever.

48
00:02:40,740 --> 00:02:45,240
So despite my, perhaps
persuasive, argument last time

49
00:02:45,240 --> 00:02:48,070
about the decrementing function,
there's clearly a

50
00:02:48,070 --> 00:02:50,220
flaw in my logic.

51
00:02:50,220 --> 00:02:53,730
And, in fact, it does not
always terminate.

52
00:02:53,730 --> 00:02:57,510
So what do we do about it?

53
00:02:57,510 --> 00:02:59,260
Well this is the main trick.

54
00:02:59,260 --> 00:03:03,410
And one of the things I need
you to understand this

55
00:03:03,410 --> 00:03:08,010
semester is perhaps the most
important thing you'll learn

56
00:03:08,010 --> 00:03:10,940
is how to debug programs.

57
00:03:10,940 --> 00:03:14,330
Too many people think the hard
part is done when they write

58
00:03:14,330 --> 00:03:16,060
the code the first time.

59
00:03:16,060 --> 00:03:18,500
No, that's actually
the easy part.

60
00:03:18,500 --> 00:03:22,820
The hard part is actually
getting it to work.

61
00:03:22,820 --> 00:03:27,600
So the thing you need to learn
is how to debug code, and the

62
00:03:27,600 --> 00:03:29,580
nice thing is it's a
transferable skill.

63
00:03:29,580 --> 00:03:34,010
It's also fine for debugging
lab experiences or family

64
00:03:34,010 --> 00:03:38,290
members or anything else that
can be seriously awry.

65
00:03:38,290 --> 00:03:41,520
So the way I do it when I
program is typically with

66
00:03:41,520 --> 00:03:43,660
print statements.

67
00:03:43,660 --> 00:03:47,950
So the fact that the program was
running forever, suggests

68
00:03:47,950 --> 00:03:50,510
that I'm not exiting
the while loop.

69
00:03:50,510 --> 00:03:53,550
So clearly, I need to print
something in the while loop.

70
00:03:56,350 --> 00:04:00,080
And the only three variables
it seems to be using are

71
00:04:00,080 --> 00:04:04,280
answer, low, and high.

72
00:04:04,280 --> 00:04:06,110
Those are the three
that change.

73
00:04:06,110 --> 00:04:09,680
So let's see what
the value is.

74
00:04:09,680 --> 00:04:13,430
Notice, by the way, that I
actually went to the trouble

75
00:04:13,430 --> 00:04:18,899
to type ans equals ans, low
equals low, et cetera.

76
00:04:18,899 --> 00:04:22,225
A lot of people would just say,
OK I'm going to print and

77
00:04:22,225 --> 00:04:25,420
they'll ans comma
low comma high.

78
00:04:25,420 --> 00:04:27,040
And then when they run
the code they'll

79
00:04:27,040 --> 00:04:29,440
forget which is which.

80
00:04:29,440 --> 00:04:33,880
The most common problem that
people have in debugging

81
00:04:33,880 --> 00:04:38,410
programs is that
they are lazy.

82
00:04:38,410 --> 00:04:41,330
They think they're saving
themselves work, and in fact

83
00:04:41,330 --> 00:04:42,830
they're creating work.

84
00:04:42,830 --> 00:04:45,390
So my first piece of
advice to you as

85
00:04:45,390 --> 00:04:49,100
debuggers is don't be lazy.

86
00:04:49,100 --> 00:04:51,970
Maybe you heard this from your
mother at some point in life,

87
00:04:51,970 --> 00:04:53,080
or your father.

88
00:04:53,080 --> 00:04:55,000
But now you're hearing
it from me.

89
00:04:55,000 --> 00:04:58,850
Try and just do it right
the first time.

90
00:04:58,850 --> 00:05:00,985
So let's run it and see
what happens now.

91
00:05:04,470 --> 00:05:06,085
Well at least it's printing
some output.

92
00:05:09,550 --> 00:05:13,610
And it's chugging away
and chug-- uh-oh--

93
00:05:13,610 --> 00:05:18,580
so now, we see we have
a real problem.

94
00:05:18,580 --> 00:05:22,820
We've reached a fixed point,
where every time through the

95
00:05:22,820 --> 00:05:25,610
loop, nothing is changing.

96
00:05:25,610 --> 00:05:27,760
Well the first time we go
through the loop and nothing

97
00:05:27,760 --> 00:05:31,550
changes we know we're in
trouble, because nothing's

98
00:05:31,550 --> 00:05:32,620
going to ever change.

99
00:05:32,620 --> 00:05:35,790
And therefore, we're going to
be in the loop forever.

100
00:05:35,790 --> 00:05:39,120
So we see, I've gone
to a stage where

101
00:05:39,120 --> 00:05:42,660
everything equals 0.5.

102
00:05:42,660 --> 00:05:46,620
And now if I go back and look at
the code, and I ask myself

103
00:05:46,620 --> 00:05:52,070
the question well what happens
when everything is 0.5, and I

104
00:05:52,070 --> 00:05:54,040
can see the problem.

105
00:05:54,040 --> 00:05:55,480
It's this statement here.

106
00:06:00,270 --> 00:06:01,670
Yep, turn it around maybe.

107
00:06:04,590 --> 00:06:08,600
But that's never going to change
now, because it's 0.5

108
00:06:08,600 --> 00:06:15,230
plus 0.5, divided by 2 is 0.5.

109
00:06:15,230 --> 00:06:17,610
And it'll just stay
there forever.

110
00:06:17,610 --> 00:06:19,030
So that's my problem.

111
00:06:19,030 --> 00:06:22,770
I have to somehow change
my code now, so that

112
00:06:22,770 --> 00:06:24,020
this doesn't happen.

113
00:06:26,830 --> 00:06:29,610
So what is the problem?

114
00:06:29,610 --> 00:06:31,950
Now somebody can tell
me, simply.

115
00:06:31,950 --> 00:06:34,130
What is the problem here?

116
00:06:34,130 --> 00:06:37,570
What was the flaw in my
reasoning when I first set

117
00:06:37,570 --> 00:06:41,026
this program up?

118
00:06:41,026 --> 00:06:42,433
Yeah?

119
00:06:42,433 --> 00:06:44,652
AUDIENCE: [INAUDIBLE]

120
00:06:44,652 --> 00:06:46,223
PROFESSOR: Louder please?

121
00:06:46,223 --> 00:06:48,155
AUDIENCE: You don't have a high
minus low is less than or

122
00:06:48,155 --> 00:06:52,019
equal to epsilon.

123
00:06:52,019 --> 00:06:54,700
PROFESSOR: So the comment was I
don't have a high minus low

124
00:06:54,700 --> 00:06:58,230
is less than or equal
to epsilon.

125
00:06:58,230 --> 00:07:01,570
True, but that's not really
the real flaw.

126
00:07:01,570 --> 00:07:03,569
Yeah?

127
00:07:03,569 --> 00:07:05,048
AUDIENCE: The fraction is
greater than the original

128
00:07:05,048 --> 00:07:08,499
fraction, so the solution is
not in the search space.

129
00:07:08,499 --> 00:07:09,980
PROFESSOR: Exactly.

130
00:07:09,980 --> 00:07:16,700
So the answer is the problem was
that I did a search in a

131
00:07:16,700 --> 00:07:20,640
region, and the answer wasn't
in that region.

132
00:07:20,640 --> 00:07:25,770
Because the square root
of 0.5 does not lie

133
00:07:25,770 --> 00:07:29,650
between 0 and 0.5.

134
00:07:29,650 --> 00:07:32,860
Silly me, when I thought about
it, I didn't think of finding

135
00:07:32,860 --> 00:07:36,680
the square root of numbers
less than 1.

136
00:07:36,680 --> 00:07:40,380
So what's a simple fix?

137
00:07:40,380 --> 00:07:44,500
Well what I can do is the
following: I'll go back and

138
00:07:44,500 --> 00:07:48,895
say high is going to be
the max of x and 1.

139
00:07:54,200 --> 00:07:57,430
So now I'm going to ensure that
the square root actually

140
00:07:57,430 --> 00:07:59,200
does lie in the region
I'm searching.

141
00:08:02,050 --> 00:08:02,870
I hope.

142
00:08:02,870 --> 00:08:05,498
Let's run it.

143
00:08:05,498 --> 00:08:07,290
Ah.

144
00:08:07,290 --> 00:08:09,580
All right, well I got to some
stuff at the end which you

145
00:08:09,580 --> 00:08:14,800
shouldn't worry about, but it
found something that I guess

146
00:08:14,800 --> 00:08:16,050
is a good enough answer.

147
00:08:21,724 --> 00:08:38,990
We'll get rid of that code I
put in this morning which

148
00:08:38,990 --> 00:08:40,289
we'll get to this later.

149
00:08:48,090 --> 00:08:52,450
OK so I've now fixed
the program.

150
00:08:52,450 --> 00:08:53,410
Everyone with me on that?

151
00:08:53,410 --> 00:08:55,750
Any questions?

152
00:08:55,750 --> 00:08:59,600
And the thing to understand is
conceptually what was wrong

153
00:08:59,600 --> 00:09:03,290
with my reasoning, that I'm
doing a search in a region

154
00:09:03,290 --> 00:09:05,140
where the answer doesn't lie.

155
00:09:05,140 --> 00:09:06,840
So I'm not going to find it.

156
00:09:06,840 --> 00:09:10,920
And the other thing to
understand is my systematic

157
00:09:10,920 --> 00:09:13,650
way of finding the bug.

158
00:09:13,650 --> 00:09:16,120
Now I confess I knew the bug
was there when I wrote the

159
00:09:16,120 --> 00:09:18,630
code, so I kind of cheated
with the debugging.

160
00:09:18,630 --> 00:09:20,380
But even if I hadn't
known, this is what

161
00:09:20,380 --> 00:09:21,490
I would have done.

162
00:09:21,490 --> 00:09:24,610
I would have put in that
print statement.

163
00:09:24,610 --> 00:09:28,770
All right, so now we have
actually a pretty good piece

164
00:09:28,770 --> 00:09:31,580
of code for finding
square roots.

165
00:09:31,580 --> 00:09:34,540
And as we looked at on Tuesday,
I can use the same

166
00:09:34,540 --> 00:09:35,890
piece of code.

167
00:09:35,890 --> 00:09:39,640
I can modify it to get cube
roots, or fourth roots, or

168
00:09:39,640 --> 00:09:41,160
fifth roots.

169
00:09:41,160 --> 00:09:46,030
And so I have a general
framework for doing things.

170
00:09:46,030 --> 00:09:52,020
But it's pretty unsatisfying in
that sense, because let's

171
00:09:52,020 --> 00:09:54,320
look at it.

172
00:09:54,320 --> 00:09:58,060
If I wanted to find the square
root of some number other than

173
00:09:58,060 --> 00:10:04,216
0.5, I have to go and edit the
code, replace the assignment

174
00:10:04,216 --> 00:10:07,940
to x by whatever I'm
trying to do.

175
00:10:07,940 --> 00:10:11,880
If I want to do cube roots I
have to cut and paste and edit

176
00:10:11,880 --> 00:10:13,130
and do things.

177
00:10:15,180 --> 00:10:19,560
There's no very good way to now
embed this piece of code

178
00:10:19,560 --> 00:10:22,390
inside a larger computation.

179
00:10:22,390 --> 00:10:27,330
Imagine that I've got some
10,000 line program that needs

180
00:10:27,330 --> 00:10:31,010
to find the square root six or
seven times, well now I'm

181
00:10:31,010 --> 00:10:33,500
going to have six or seven
copies of this code in my

182
00:10:33,500 --> 00:10:36,440
program, for every time I
need the square root.

183
00:10:39,230 --> 00:10:41,535
Clearly not what
you want to do.

184
00:10:44,070 --> 00:10:49,870
In general, having more
code is a bad thing.

185
00:10:49,870 --> 00:10:53,460
So it's not like you're given an
essay to write and someone

186
00:10:53,460 --> 00:10:57,030
tells you it's got to be 5,000
words, and you just sweat

187
00:10:57,030 --> 00:11:01,810
blood trying to figure out how
to stretch it to be that long.

188
00:11:01,810 --> 00:11:04,020
In code, it's the other
way around.

189
00:11:04,020 --> 00:11:07,520
Most of the time we want to make
it shorter not longer.

190
00:11:07,520 --> 00:11:11,330
And the reason we want to do
that is the difficulty of

191
00:11:11,330 --> 00:11:16,280
getting code to work grows,
maybe even grows

192
00:11:16,280 --> 00:11:19,860
quadratically, or worse but
the size of the code.

193
00:11:19,860 --> 00:11:21,820
So the more code you have,
the harder it is

194
00:11:21,820 --> 00:11:23,370
to get it to work.

195
00:11:23,370 --> 00:11:26,950
So one of the things good
programmers learn to do is

196
00:11:26,950 --> 00:11:30,170
write less code.

197
00:11:30,170 --> 00:11:32,840
And so we don't measure
productivity of a programmer

198
00:11:32,840 --> 00:11:36,540
by the number of lines of code
they produce each day, but we

199
00:11:36,540 --> 00:11:38,890
measure it by the amount
of functionality they

200
00:11:38,890 --> 00:11:40,560
produce each day.

201
00:11:40,560 --> 00:11:43,390
And we give them bonus points
if they achieve the desired

202
00:11:43,390 --> 00:11:46,610
functionality with less code.

203
00:11:46,610 --> 00:11:51,470
So let's talk about how
we can write less code

204
00:11:51,470 --> 00:11:54,980
and accomplish more.

205
00:11:54,980 --> 00:11:59,320
Well to do that, we're going
to look at a new language

206
00:11:59,320 --> 00:12:00,090
mechanism--

207
00:12:00,090 --> 00:12:03,410
actually not new, but
new to this class--

208
00:12:03,410 --> 00:12:05,750
called a function.

209
00:12:05,750 --> 00:12:11,310
But before we do that, I want
to pull back and talk about

210
00:12:11,310 --> 00:12:14,880
what it is we hope to accomplish
by introducing

211
00:12:14,880 --> 00:12:18,610
functions into our programming
language.

212
00:12:18,610 --> 00:12:24,160
We want to provide a mechanism
that provides for two things:

213
00:12:24,160 --> 00:12:31,900
decomposition and abstraction.

214
00:12:42,400 --> 00:12:46,590
What decomposition does, is
it creates structure.

215
00:12:55,770 --> 00:12:59,740
It allows us to break our
program up into something

216
00:12:59,740 --> 00:13:00,990
called modules.

217
00:13:04,370 --> 00:13:07,440
And the module we'll focus on
today is function, but later

218
00:13:07,440 --> 00:13:10,320
we'll see there's another
important kind of module in

219
00:13:10,320 --> 00:13:13,900
Python called the class.

220
00:13:13,900 --> 00:13:22,650
And the advantage of a module is
it should be self-contained

221
00:13:22,650 --> 00:13:23,900
and reusable.

222
00:13:26,010 --> 00:13:30,510
So it's a self-contained unit
of functionality that can be

223
00:13:30,510 --> 00:13:32,086
used in multiple contexts.

224
00:13:35,680 --> 00:13:39,310
Abstraction suppresses
details.

225
00:13:48,410 --> 00:13:52,620
It allows us to use a piece
of code as if it

226
00:13:52,620 --> 00:13:55,070
were a black box.

227
00:13:55,070 --> 00:13:59,870
That is, something whose
interior details we can't see,

228
00:13:59,870 --> 00:14:03,640
don't need to see, and shouldn't
even want to see.

229
00:14:06,670 --> 00:14:09,220
We only need to understand
what it does,

230
00:14:09,220 --> 00:14:11,580
not how it does it.

231
00:14:11,580 --> 00:14:15,610
And that lets us use code
that other people

232
00:14:15,610 --> 00:14:18,620
have written easily.

233
00:14:18,620 --> 00:14:21,095
And, in fact, use code that
we have written easily.

234
00:14:25,180 --> 00:14:28,790
It's one of those few occasions
where I think Thomas

235
00:14:28,790 --> 00:14:32,900
Gray was right, when he said,
"ignorance is bliss."

236
00:14:32,900 --> 00:14:35,505
Sometimes knowing
less is better.

237
00:14:38,040 --> 00:14:41,400
All right, so let's look at
the way functions work.

238
00:14:41,400 --> 00:14:44,860
The functions let us
break code into

239
00:14:44,860 --> 00:14:49,390
reusable, coherent pieces.

240
00:14:49,390 --> 00:14:52,930
Now we've already looked at
similar kinds of things.

241
00:14:52,930 --> 00:14:57,090
When we looked at say floating
point numbers, and we wrote

242
00:14:57,090 --> 00:15:01,050
operations like plus or divide,
whatever, we didn't

243
00:15:01,050 --> 00:15:03,240
worry about how they
were actually

244
00:15:03,240 --> 00:15:05,460
implemented in the machine.

245
00:15:05,460 --> 00:15:08,030
We said OK they do something,
they're kind of like dividing

246
00:15:08,030 --> 00:15:10,570
real numbers, let's not worry
about the details.

247
00:15:13,810 --> 00:15:15,420
We do that with a
lot of things.

248
00:15:15,420 --> 00:15:16,590
We looked at strings.

249
00:15:16,590 --> 00:15:18,740
We concatenated strings.

250
00:15:18,740 --> 00:15:21,370
Well we didn't worry about
how did Python

251
00:15:21,370 --> 00:15:22,590
go about doing that.

252
00:15:22,590 --> 00:15:25,610
We just assumed it did it,
and it had the meaning

253
00:15:25,610 --> 00:15:27,710
we wanted it to.

254
00:15:27,710 --> 00:15:32,100
What functions let us do is
extend the language in some

255
00:15:32,100 --> 00:15:38,290
sense by adding new primitives
that we can use just the way

256
00:15:38,290 --> 00:15:39,745
we used the built-in
primitives.

257
00:15:42,250 --> 00:15:46,060
So let's look at an
example here.

258
00:15:46,060 --> 00:15:47,625
I've written a very
simple function.

259
00:15:56,440 --> 00:15:59,670
Does something that we actually
did already when we

260
00:15:59,670 --> 00:16:02,220
looked at square roots.

261
00:16:02,220 --> 00:16:06,360
It's a function called
within epsilon.

262
00:16:06,360 --> 00:16:09,990
And let me comment this out
while I'm thinking about it,

263
00:16:09,990 --> 00:16:11,435
so we don't have to live
with it later.

264
00:16:17,150 --> 00:16:21,100
And I now want to walk you,
slowly, through what this

265
00:16:21,100 --> 00:16:23,550
function does.

266
00:16:23,550 --> 00:16:30,400
So at the start, it uses the
keyword Def, short for define.

267
00:16:30,400 --> 00:16:32,850
Following that is a name.

268
00:16:32,850 --> 00:16:35,520
I chose the name
within epsilon.

269
00:16:35,520 --> 00:16:40,230
You can choose any name you
want for a function.

270
00:16:40,230 --> 00:16:43,660
I'm strongly encourage you to
choose mnemonic names, that is

271
00:16:43,660 --> 00:16:47,200
to say names that
have a meaning.

272
00:16:47,200 --> 00:16:50,430
So in some sense you see it says
within epsilon, and you

273
00:16:50,430 --> 00:16:53,430
know what it does already.

274
00:16:53,430 --> 00:16:57,070
Following that, it has three
things called formal

275
00:16:57,070 --> 00:16:59,050
parameters.

276
00:16:59,050 --> 00:17:02,460
I'll come back to in a minute,
what that means.

277
00:17:02,460 --> 00:17:04,690
And then after that, it's
got something called

278
00:17:04,690 --> 00:17:07,960
the function body.

279
00:17:07,960 --> 00:17:21,589
So we see that a function has a
name, it has parameters, and

280
00:17:21,589 --> 00:17:22,839
it has a body.

281
00:17:25,119 --> 00:17:28,990
The body is the code that's
part of the function.

282
00:17:36,380 --> 00:17:41,600
In the body, you can write
any code you want.

283
00:17:41,600 --> 00:17:44,310
Plus, there's something you
can't write outside of a

284
00:17:44,310 --> 00:17:48,160
function, called return.

285
00:17:48,160 --> 00:17:54,760
That's a special command that
says whoever calls me has

286
00:17:54,760 --> 00:17:57,570
called me to have me
compute a value.

287
00:17:57,570 --> 00:18:01,570
I'm going to return the value
that this person would want.

288
00:18:01,570 --> 00:18:05,090
And then here we see something
that's very important.

289
00:18:05,090 --> 00:18:09,380
This is where we get
abstraction, and that's the

290
00:18:09,380 --> 00:18:12,420
specification of the function.

291
00:18:12,420 --> 00:18:15,170
And it says here, there
are two pieces to it.

292
00:18:15,170 --> 00:18:21,720
One that its parameters x, y,
and epsilon, are all floats.

293
00:18:21,720 --> 00:18:25,015
And furthermore, epsilon
is greater than 0.

294
00:18:28,450 --> 00:18:34,790
You can imagine this is
important, and it returns true

295
00:18:34,790 --> 00:18:38,840
if x is within epsilon of y.

296
00:18:38,840 --> 00:18:42,450
Otherwise it will
return false.

297
00:18:42,450 --> 00:18:46,960
If I want to use within epsilon,
I don't need to look

298
00:18:46,960 --> 00:18:49,130
at the code.

299
00:18:49,130 --> 00:18:53,190
I look instead at the
specification.

300
00:18:53,190 --> 00:18:56,730
Now here where the code is one
line, maybe I haven't gained a

301
00:18:56,730 --> 00:18:58,650
lot by looking at the
specification

302
00:18:58,650 --> 00:18:59,900
instead of the code.

303
00:18:59,900 --> 00:19:04,350
But you can imagine if the code
were 1,000 lines, I'd

304
00:19:04,350 --> 00:19:08,900
much rather read the
specification than the code.

305
00:19:08,900 --> 00:19:14,920
We'll also see for other reasons
later why it's in fact

306
00:19:14,920 --> 00:19:16,640
dangerous to look at the code.

307
00:19:20,210 --> 00:19:23,960
How do I use it?

308
00:19:23,960 --> 00:19:27,210
I use it by invoking it.

309
00:19:27,210 --> 00:19:34,560
So I could, for example write
something like print within

310
00:19:34,560 --> 00:19:45,210
epsilon, of two, three, one.

311
00:19:45,210 --> 00:19:46,460
What's it going to print?

312
00:19:48,990 --> 00:19:50,840
Pardon?

313
00:19:50,840 --> 00:19:52,410
Why is it going to print
an error do you think?

314
00:19:52,410 --> 00:19:54,390
AUDIENCE: Because you
haven't put epsilon.

315
00:19:54,390 --> 00:19:55,875
PROFESSOR: Ah, typed it wrong.

316
00:19:55,875 --> 00:19:58,350
Thank you.

317
00:19:58,350 --> 00:19:59,340
You're correct.

318
00:19:59,340 --> 00:20:01,320
It would have printed
an error.

319
00:20:01,320 --> 00:20:04,785
Now what will it print?

320
00:20:04,785 --> 00:20:06,035
AUDIENCE: [INAUDIBLE]

321
00:20:08,270 --> 00:20:09,520
PROFESSOR: Sure enough.

322
00:20:11,840 --> 00:20:19,850
I could also, if I chose,
write something like val

323
00:20:19,850 --> 00:20:37,575
equals that, then if I want
I could print val.

324
00:20:42,750 --> 00:20:44,890
Now it's going to print false.

325
00:20:44,890 --> 00:20:49,760
So within epsilon is just like
plus or something else, does

326
00:20:49,760 --> 00:20:52,070
some computation,
returns a value.

327
00:20:52,070 --> 00:20:56,530
I can use that value any place
I could have used an

328
00:20:56,530 --> 00:20:57,780
expression.

329
00:20:59,530 --> 00:21:03,130
Now one more thing to
look at with this.

330
00:21:03,130 --> 00:21:05,825
Suppose I don't return
anything.

331
00:21:11,800 --> 00:21:14,910
Anyone want to guess what
it's going to do now?

332
00:21:14,910 --> 00:21:17,830
I point this out, because this
is a very common error.

333
00:21:17,830 --> 00:21:22,580
People write lots of code,
calculate some wonderful value

334
00:21:22,580 --> 00:21:25,060
and then forget to return it.

335
00:21:25,060 --> 00:21:27,830
What's it going to do now?

336
00:21:27,830 --> 00:21:29,270
Well let's run it and see.

337
00:21:29,270 --> 00:21:32,770
That, by the way, is a good
habit to get into.

338
00:21:32,770 --> 00:21:35,730
It's going to return the
special value none.

339
00:21:35,730 --> 00:21:38,150
Remember we looked at that
earlier, meaning I

340
00:21:38,150 --> 00:21:41,180
don't have a value.

341
00:21:41,180 --> 00:21:45,330
So if you see in your code some
none popping up where you

342
00:21:45,330 --> 00:21:50,820
don't expect it to, it's
probably because you forgot to

343
00:21:50,820 --> 00:21:53,630
return a value.

344
00:21:53,630 --> 00:21:54,900
So just keep that in mind.

345
00:21:57,980 --> 00:22:04,870
All right, now there's a
big advantage of this.

346
00:22:04,870 --> 00:22:10,630
Once I've written this code I
can now anywhere I want call

347
00:22:10,630 --> 00:22:14,760
within epsilon, and I don't have
to duplicate the code.

348
00:22:14,760 --> 00:22:16,010
I only do it once.

349
00:22:19,040 --> 00:22:22,010
As I said earlier maybe I'm not
gaining much, because the

350
00:22:22,010 --> 00:22:25,040
body is so short.

351
00:22:25,040 --> 00:22:29,490
On the other hand, I'm still
gaining something.

352
00:22:29,490 --> 00:22:35,880
Notice that when I look at the
code down here, it's easy to

353
00:22:35,880 --> 00:22:39,080
read, I'm printing within
epsilon two, three, and one.

354
00:22:42,010 --> 00:22:45,360
And I don't have to decode this
and tell me that that's

355
00:22:45,360 --> 00:22:47,420
what that's doing.

356
00:22:47,420 --> 00:22:51,920
So if I have a function and I
choose the names properly,

357
00:22:51,920 --> 00:22:56,460
code that uses the function
is much easier to read.

358
00:22:56,460 --> 00:22:57,710
And that can be a big value.

359
00:23:04,000 --> 00:23:06,620
All right, let's look
at another example.

360
00:23:12,880 --> 00:23:16,440
So here I've got this
function, f.

361
00:23:19,470 --> 00:23:22,670
I've chose a non-mnemonic name,
because there isn't much

362
00:23:22,670 --> 00:23:23,920
meaning to this function.

363
00:23:27,650 --> 00:23:31,220
What f does, it is a
formal parameter x.

364
00:23:31,220 --> 00:23:34,220
It sets x to x plus 1.

365
00:23:34,220 --> 00:23:37,650
Then it prints x
and returns x--

366
00:23:37,650 --> 00:23:38,900
pretty boring.

367
00:23:46,340 --> 00:23:47,960
So let's see what
it does here.

368
00:23:52,300 --> 00:23:58,260
So now I'm going to set x to
three, set z, or zed if you

369
00:23:58,260 --> 00:24:02,330
happen to be Canadian,
to f of x.

370
00:24:02,330 --> 00:24:05,900
And then print the values
of z and x.

371
00:24:05,900 --> 00:24:10,330
Also in f, before I return
x, I'm going to print it.

372
00:24:14,160 --> 00:24:16,030
So let's see what happens
when I run this one.

373
00:24:20,210 --> 00:24:25,590
It prints four, four,
and then three.

374
00:24:25,590 --> 00:24:28,570
All right, what's going on?

375
00:24:28,570 --> 00:24:31,250
Why did it do that?

376
00:24:31,250 --> 00:24:36,650
Well it's pretty easy to see
why it printed four here,

377
00:24:36,650 --> 00:24:46,020
because I called f of x with
an x equal to 3, and then I

378
00:24:46,020 --> 00:24:47,940
incremented it by one, and
then I printed it.

379
00:24:51,380 --> 00:25:00,120
It's probably also easy to
understand why z was four,

380
00:25:00,120 --> 00:25:05,200
because I returned the value of
x here, which was four and

381
00:25:05,200 --> 00:25:06,870
it printed it.

382
00:25:06,870 --> 00:25:08,750
But why is this x three?

383
00:25:12,130 --> 00:25:19,550
And the answer is this x and
that x have nothing to do with

384
00:25:19,550 --> 00:25:20,800
each other.

385
00:25:23,540 --> 00:25:24,660
Right?

386
00:25:24,660 --> 00:25:29,050
I could just as easily have
chosen some other value for

387
00:25:29,050 --> 00:25:35,340
the formal parameter, say
George, and said George is

388
00:25:35,340 --> 00:25:38,455
equal to George plus 1, print
George, return George.

389
00:25:42,550 --> 00:25:48,080
There is no relation between the
name of the formal and, in

390
00:25:48,080 --> 00:25:54,130
this case, x defined in the
calling environment.

391
00:25:54,130 --> 00:25:57,180
So now let's think about that
by working slowly and

392
00:25:57,180 --> 00:26:02,120
carefully through what happens
when we call a function.

393
00:26:05,440 --> 00:26:09,190
So the first thing that happens
at the call, and I'll

394
00:26:09,190 --> 00:26:22,910
just work it through this one,
is the formal parameter, x in

395
00:26:22,910 --> 00:26:29,520
this case, is bound--

396
00:26:29,520 --> 00:26:32,670
and I'll come back to what
binding means, that's a

397
00:26:32,670 --> 00:26:34,280
critical concept here--

398
00:26:37,960 --> 00:26:46,805
to the value of the
actual parameter.

399
00:26:50,300 --> 00:26:58,550
So these are important terms,
actual and formal, which in

400
00:26:58,550 --> 00:27:02,065
this case, also happens
to be called x.

401
00:27:07,130 --> 00:27:20,900
But what's happening here, is
upon entry of a function, a

402
00:27:20,900 --> 00:27:23,020
new scope is created.

403
00:27:33,160 --> 00:27:35,340
What's a scope?

404
00:27:35,340 --> 00:27:45,070
A scope is a mapping from
names to objects.

405
00:27:57,380 --> 00:28:01,510
So if we look at what's going
on over here, we can draw a

406
00:28:01,510 --> 00:28:03,420
little picture.

407
00:28:03,420 --> 00:28:04,910
Well before I draw a picture,
I'm going to look at a

408
00:28:04,910 --> 00:28:07,860
slightly more complicated
example.

409
00:28:07,860 --> 00:28:10,740
Well, yeah let's do that.

410
00:28:10,740 --> 00:28:16,530
This one is not in your
handout, but it is

411
00:28:16,530 --> 00:28:19,900
illustrative of, I think, what's
really going on here.

412
00:28:32,590 --> 00:28:35,060
Here I've got another
beautifully named function, in

413
00:28:35,060 --> 00:28:42,250
this case f1, and inside it,
I've defined another function,

414
00:28:42,250 --> 00:28:45,406
called g, which takes
no arguments.

415
00:28:48,720 --> 00:28:51,460
I've set x to abc.

416
00:28:55,460 --> 00:28:58,550
Then I haven't shown you these
assert statements yet, or

417
00:28:58,550 --> 00:29:00,480
haven't talked about them.

418
00:29:00,480 --> 00:29:07,350
Assert is a command in which the
keyword assert is followed

419
00:29:07,350 --> 00:29:10,040
by an expression that
evaluates to

420
00:29:10,040 --> 00:29:12,950
either true or false.

421
00:29:12,950 --> 00:29:16,830
If it evaluates to true,
it does nothing.

422
00:29:16,830 --> 00:29:18,420
It just continues.

423
00:29:18,420 --> 00:29:21,610
If it evaluates to false,
it stops your

424
00:29:21,610 --> 00:29:24,480
program dead in its tracks.

425
00:29:24,480 --> 00:29:28,140
So I've just used it here as a
trick to make my program stop

426
00:29:28,140 --> 00:29:30,930
when I run it.

427
00:29:30,930 --> 00:29:36,140
In general, you'll find that
I use asserts quite a lot.

428
00:29:36,140 --> 00:29:41,020
So for example, in the next
piece of code, which

429
00:29:41,020 --> 00:29:43,310
is called find root.

430
00:29:43,310 --> 00:29:47,150
It takes the root, is it square,
or cube, whatever, the

431
00:29:47,150 --> 00:29:50,690
value, and epsilon.

432
00:29:50,690 --> 00:29:53,730
It assumes that powers, and
int, and val, and epsilon

433
00:29:53,730 --> 00:29:57,880
float, in the specification.

434
00:29:57,880 --> 00:30:01,320
And then you'll notice, I
start by putting in an

435
00:30:01,320 --> 00:30:04,250
assertion here.

436
00:30:04,250 --> 00:30:08,610
And what I'm asserting is that
the actuals to which these

437
00:30:08,610 --> 00:30:12,530
formals are bound, have the
properties the specification

438
00:30:12,530 --> 00:30:15,080
says they do.

439
00:30:15,080 --> 00:30:18,150
This is what's called defensive
programming.

440
00:30:18,150 --> 00:30:21,760
In principle, I shouldn't have
to do that, because in

441
00:30:21,760 --> 00:30:27,130
principle, nobody should call
this with incorrect values.

442
00:30:27,130 --> 00:30:29,490
But, in fact, it can happen.

443
00:30:29,490 --> 00:30:32,550
Programmers occasionally
make mistakes.

444
00:30:32,550 --> 00:30:36,190
And so I'm protecting myself
by checking that the

445
00:30:36,190 --> 00:30:39,060
assumptions are met, and
if they're not, my

446
00:30:39,060 --> 00:30:41,960
program will just stop.

447
00:30:41,960 --> 00:30:44,550
Then I can go hunt down the fool
that called it with the

448
00:30:44,550 --> 00:30:46,390
wrong parameters--

449
00:30:46,390 --> 00:30:47,640
probably myself.

450
00:30:49,770 --> 00:30:52,760
So asserts are good for that,
and I'll use them a lot for

451
00:30:52,760 --> 00:30:54,750
these kinds of things.

452
00:30:54,750 --> 00:30:58,590
I'll also use them when I
think I know what value

453
00:30:58,590 --> 00:31:01,030
something should be in a program
at some point, and I'm

454
00:31:01,030 --> 00:31:02,920
not sure it really is.

455
00:31:02,920 --> 00:31:05,710
I'll assert that it has the
value I think it is.

456
00:31:05,710 --> 00:31:09,390
I'll assert that x is six, if I
think it's going to be six.

457
00:31:09,390 --> 00:31:11,840
And then my program will
conveniently stop for me if

458
00:31:11,840 --> 00:31:13,490
it's not true.

459
00:31:13,490 --> 00:31:14,820
All right so that's assert.

460
00:31:19,970 --> 00:31:22,800
Other than that, I think there's
nothing here you

461
00:31:22,800 --> 00:31:24,050
haven't seen before.

462
00:31:27,350 --> 00:31:31,610
So what's going to happen, we're
going to step through

463
00:31:31,610 --> 00:31:33,645
this piece by piece.

464
00:31:37,220 --> 00:31:45,250
So initially, as we look at it,
we enter the main body of

465
00:31:45,250 --> 00:31:49,090
the program, which is not
wrapped in a function.

466
00:31:49,090 --> 00:31:52,210
So what IDLE will do, or the
interpreter will do, is it

467
00:31:52,210 --> 00:31:57,730
will start by executing
each def.

468
00:31:57,730 --> 00:32:01,030
But executing a def doesn't do
anything, but put some names

469
00:32:01,030 --> 00:32:03,570
in the environment.

470
00:32:03,570 --> 00:32:05,910
Then it will go and start
actually running and

471
00:32:05,910 --> 00:32:11,440
interpreting the code that's not
nested inside a function.

472
00:32:11,440 --> 00:32:15,700
So the first thing that will
happen is the interpreter will

473
00:32:15,700 --> 00:32:20,240
build for me what's
called the scope.

474
00:32:20,240 --> 00:32:23,680
I've already mentioned,
that's a mapping

475
00:32:23,680 --> 00:32:27,260
from names to objects.

476
00:32:27,260 --> 00:32:35,881
So in the outermost scope, it
will first find the name f1.

477
00:32:41,140 --> 00:32:46,860
F1 it will tell me that f1 maps
to an object that happens

478
00:32:46,860 --> 00:32:48,110
to be a function.

479
00:32:53,180 --> 00:32:56,270
So it will come over here--

480
00:32:56,270 --> 00:32:59,310
and I'm just going to draw some
picture, we'll assume

481
00:32:59,310 --> 00:33:02,860
that's the memory of
the computer--

482
00:33:02,860 --> 00:33:05,590
and it will map to something
that happens to be a bunch of

483
00:33:05,590 --> 00:33:07,210
code, if you will.

484
00:33:07,210 --> 00:33:08,460
All right?

485
00:33:11,190 --> 00:33:13,060
It will then stop.

486
00:33:16,650 --> 00:33:20,650
It will then notice that it's
got, at the outermost level a

487
00:33:20,650 --> 00:33:21,985
variable called x.

488
00:33:26,230 --> 00:33:30,500
And that will map to an integer,
which will initially

489
00:33:30,500 --> 00:33:32,730
have no value in it.

490
00:33:32,730 --> 00:33:36,830
And then after the assignment,
it will now be bound to the

491
00:33:36,830 --> 00:33:38,800
object three.

492
00:33:43,860 --> 00:33:52,030
It will then create another
object z, but before it can

493
00:33:52,030 --> 00:33:56,250
bind a value to it, it will
invoke the function f1.

494
00:33:59,460 --> 00:34:02,245
Now the interpreter starts
to execute f1.

495
00:34:05,460 --> 00:34:11,659
When it does that, it will
create another scope.

496
00:34:11,659 --> 00:34:13,805
So this is the main scope.

497
00:34:18,400 --> 00:34:22,310
It will next create a scope
called the f1 scope.

498
00:34:26,520 --> 00:34:34,500
In that, it will have another
name g, which will be

499
00:34:34,500 --> 00:34:35,750
bound to some code.

500
00:34:42,600 --> 00:34:49,489
It will have a name x, which
will be initially

501
00:34:49,489 --> 00:34:54,302
bound to the actual.

502
00:34:54,302 --> 00:34:58,750
So in this case, it will be
bound to the object three.

503
00:35:06,070 --> 00:35:08,480
We'll then eventually
do a print.

504
00:35:08,480 --> 00:35:13,205
It will involve g, which will
now create the g scope.

505
00:35:21,500 --> 00:35:29,640
And the g scope will create a
name x, which in this case

506
00:35:29,640 --> 00:35:32,030
will be bound to
the string abc.

507
00:35:38,070 --> 00:35:42,670
It will then start executing
g, and it will stop.

508
00:35:45,890 --> 00:35:47,670
So let's see what
that looks like.

509
00:35:53,270 --> 00:35:55,865
Sure enough, it got an
assert false, gave

510
00:35:55,865 --> 00:35:58,630
an assertion error.

511
00:35:58,630 --> 00:36:05,120
What I can do now is go up to
this debug here, and go to

512
00:36:05,120 --> 00:36:08,810
what's called a stack viewer.

513
00:36:08,810 --> 00:36:15,800
Each of these scopes is what's
called a stack frame.

514
00:36:15,800 --> 00:36:18,890
Now why are they called
stack frames?

515
00:36:22,110 --> 00:36:28,105
Because when we do it, we begin
with the main scope.

516
00:36:32,520 --> 00:36:35,955
We call f, and we
get the scope.

517
00:36:38,830 --> 00:36:42,190
f calls g and we get
the g scope.

518
00:36:46,450 --> 00:36:50,060
When g completes, which alas
it doesn't because of the

519
00:36:50,060 --> 00:36:57,820
error, it pops the stack, and
gets rid of the g scope.

520
00:36:57,820 --> 00:37:02,690
And now the stack is the f and
the main, and then when f

521
00:37:02,690 --> 00:37:06,180
completes, it will have
just the main.

522
00:37:06,180 --> 00:37:09,530
So it's last in, first out,
which is typically called a

523
00:37:09,530 --> 00:37:11,060
stack in computing--

524
00:37:13,660 --> 00:37:18,520
or a LIFO, if you're a course
15 major, and do accounting.

525
00:37:18,520 --> 00:37:22,330
So let's look at the
stack viewer.

526
00:37:22,330 --> 00:37:25,780
And I apologize for the small
type font, but I was unable to

527
00:37:25,780 --> 00:37:28,970
make it look bigger.

528
00:37:28,970 --> 00:37:33,200
So it says at the top we've
got an assertion error.

529
00:37:33,200 --> 00:37:39,240
And then you'll note it's got
three stacks: the main, the f1

530
00:37:39,240 --> 00:37:41,390
stack, and the g stack.

531
00:37:41,390 --> 00:37:44,860
I forgot I called
it f1, not f.

532
00:37:44,860 --> 00:37:47,670
Then I can inspect
them further.

533
00:37:47,670 --> 00:37:52,350
So the g stack has local
and global variables.

534
00:37:52,350 --> 00:37:58,850
The local variables include
x, which is equal to abc.

535
00:37:58,850 --> 00:38:02,310
Globals we'll get to later.

536
00:38:02,310 --> 00:38:10,040
If I look at f1, it also has a
local called x, but its value

537
00:38:10,040 --> 00:38:14,390
is now four, not abc.

538
00:38:14,390 --> 00:38:16,790
And it has a value called
g, which is a

539
00:38:16,790 --> 00:38:21,470
function, as we discussed.

540
00:38:21,470 --> 00:38:32,660
And if I look at main, it has a
bunch of things, but it has

541
00:38:32,660 --> 00:38:35,480
everything that's available in
the interpreter, which because

542
00:38:35,480 --> 00:38:38,200
we've looked at within
epsilon it's there.

543
00:38:38,200 --> 00:38:42,730
But you'll notice it's x is 3.

544
00:38:42,730 --> 00:38:44,340
All right?

545
00:38:44,340 --> 00:38:48,860
So the stack viewer can be very
handy, to look at what

546
00:38:48,860 --> 00:38:50,610
you've got, when you've
got a bunch of calls.

547
00:38:53,720 --> 00:39:00,010
Now if we go back to our code
here, and we'll take this out.

548
00:39:00,010 --> 00:39:07,015
And suppose what we do is
we assert false here.

549
00:39:14,510 --> 00:39:23,980
Now if we look at the stack
viewer, we see that we have f1

550
00:39:23,980 --> 00:39:27,780
in main, but g is
no longer there.

551
00:39:27,780 --> 00:39:29,610
It's gone.

552
00:39:29,610 --> 00:39:32,390
All those variables don't exist
anymore, because I'm no

553
00:39:32,390 --> 00:39:33,640
longer in g.

554
00:39:36,090 --> 00:39:38,400
This is the nice thing, because
it means if you call

555
00:39:38,400 --> 00:39:40,670
something 1,000 times,
it doesn't

556
00:39:40,670 --> 00:39:42,530
use up all your memory.

557
00:39:42,530 --> 00:39:44,920
Every time it's finished,
it gets rid of what

558
00:39:44,920 --> 00:39:46,170
it no longer needs.

559
00:39:51,580 --> 00:39:52,550
All right?

560
00:39:52,550 --> 00:39:54,300
Does that make sense?

561
00:39:54,300 --> 00:39:55,940
This is an important
thing to get--

562
00:39:55,940 --> 00:39:59,036
yeah, thank you, question.

563
00:39:59,036 --> 00:39:59,530
AUDIENCE: --the assertion.

564
00:39:59,530 --> 00:40:00,518
PROFESSOR: Where did I--

565
00:40:00,518 --> 00:40:03,482
AUDIENCE: Where did you put this
other assertion, when you

566
00:40:03,482 --> 00:40:04,470
just changed--

567
00:40:04,470 --> 00:40:05,458
PROFESSOR: Ah, where did I
put the other assertion?

568
00:40:05,458 --> 00:40:15,850
If we look at the code, you'll
see I put it after I call g,

569
00:40:15,850 --> 00:40:22,040
and g is by now returned, but
before I left f1, which is why

570
00:40:22,040 --> 00:40:26,060
the f1 stack is still present.

571
00:40:26,060 --> 00:40:28,810
That makes sense to you?

572
00:40:28,810 --> 00:40:34,320
Which stacks exist, which stack
frames exist, depends

573
00:40:34,320 --> 00:40:37,360
upon which functions
are still active.

574
00:40:37,360 --> 00:40:38,830
Yeah?

575
00:40:38,830 --> 00:40:39,679
AUDIENCE: How come
you don't need a

576
00:40:39,679 --> 00:40:43,430
return under the g function?

577
00:40:43,430 --> 00:40:44,973
PROFESSOR: Oh, because there's
not going to be anything

578
00:40:44,973 --> 00:40:46,080
interesting.

579
00:40:46,080 --> 00:40:47,662
It's useless.

580
00:40:47,662 --> 00:40:48,010
Right?

581
00:40:48,010 --> 00:40:49,750
Why don't I need a
return under g?

582
00:40:49,750 --> 00:40:52,070
Well if I wanted it to do
something useful, I would need

583
00:40:52,070 --> 00:40:53,385
to return something.

584
00:40:53,385 --> 00:40:56,260
But I'd probably also want to
pass it some arguments, rather

585
00:40:56,260 --> 00:40:58,810
than have it take no
arguments, as well.

586
00:40:58,810 --> 00:41:01,290
So it's here just to be the
simplest thing I could put

587
00:41:01,290 --> 00:41:03,450
that created a stack frame.

588
00:41:03,450 --> 00:41:08,250
But don't try and interpre it as
being anything meaningful.

589
00:41:08,250 --> 00:41:09,414
Yeah?

590
00:41:09,414 --> 00:41:11,662
AUDIENCE: Would you run into
problems assuming that g did

591
00:41:11,662 --> 00:41:13,270
something to x and
then returned it?

592
00:41:13,270 --> 00:41:14,716
Would you run into any problems
that you named the

593
00:41:14,716 --> 00:41:17,126
variable the same?

594
00:41:17,126 --> 00:41:18,572
You know, that you
used x twice?

595
00:41:18,572 --> 00:41:19,054
Would you want to--

596
00:41:19,054 --> 00:41:20,030
PROFESSOR: No.

597
00:41:20,030 --> 00:41:24,620
If an x exists, or any variable
exists within a

598
00:41:24,620 --> 00:41:28,540
function body, when you leave
that function, that variable

599
00:41:28,540 --> 00:41:31,010
is gone forever.

600
00:41:31,010 --> 00:41:34,340
These are just names.

601
00:41:34,340 --> 00:41:36,920
They have no intrinsic
meaning.

602
00:41:36,920 --> 00:41:40,900
So one of the ways to think
about it, and we'll see this

603
00:41:40,900 --> 00:41:43,720
later when we get to classes--

604
00:41:43,720 --> 00:41:45,170
a lot later.

605
00:41:45,170 --> 00:41:48,860
You could, if you wanted, think
about this as really the

606
00:41:48,860 --> 00:41:55,000
name g.x, and you could really
think of this as the name of

607
00:41:55,000 --> 00:42:01,710
f1.x, and you could think of
this as the name of main.x,

608
00:42:01,710 --> 00:42:06,090
indicating that they're
really not the same.

609
00:42:06,090 --> 00:42:10,430
But it would be kind of a pain
to write them all that way.

610
00:42:10,430 --> 00:42:11,670
OK?

611
00:42:11,670 --> 00:42:13,650
So different scopes have
different names

612
00:42:13,650 --> 00:42:16,040
available to them.

613
00:42:16,040 --> 00:42:18,810
You can use the names in the
scope, and you have to keep

614
00:42:18,810 --> 00:42:20,700
track of what they mean.

615
00:42:23,990 --> 00:42:24,260
OK?

616
00:42:24,260 --> 00:42:25,110
Any other questions?

617
00:42:25,110 --> 00:42:28,200
These are great questions, and
I really do appreciate them.

618
00:42:28,200 --> 00:42:28,910
Yeah?

619
00:42:28,910 --> 00:42:30,842
AUDIENCE: Does this also
happen with four loops?

620
00:42:30,842 --> 00:42:33,257
Like if you say 4x in
range something,

621
00:42:33,257 --> 00:42:34,706
can you use x later?

622
00:42:34,706 --> 00:42:35,672
Or is it x--

623
00:42:35,672 --> 00:42:36,638
PROFESSOR: You can
use x later.

624
00:42:36,638 --> 00:42:38,087
AUDIENCE: Okay so--

625
00:42:38,087 --> 00:42:40,140
PROFESSOR: x will be available
outside the loop.

626
00:42:43,020 --> 00:42:46,470
This was if you said for x in
something, is x available

627
00:42:46,470 --> 00:42:47,170
outside the loop?

628
00:42:47,170 --> 00:42:48,600
Yes.

629
00:42:48,600 --> 00:42:51,130
And in fact, you'll often want
to test what the final value

630
00:42:51,130 --> 00:42:53,480
of x is, when you
leave the loop.

631
00:42:56,810 --> 00:42:59,650
OK, the next thing on your
handout, and I'm not going to

632
00:42:59,650 --> 00:43:05,520
go over it, is using functions
to implement something that

633
00:43:05,520 --> 00:43:07,480
finds roots.

634
00:43:07,480 --> 00:43:09,630
There's no real point in
my walking you through

635
00:43:09,630 --> 00:43:11,570
this code in class.

636
00:43:11,570 --> 00:43:13,520
I did include it
in the handout.

637
00:43:13,520 --> 00:43:16,500
And by the way, the handouts
are all available after

638
00:43:16,500 --> 00:43:18,910
lecture, online.

639
00:43:18,910 --> 00:43:22,380
Is that, I think you should work
through in your own, and

640
00:43:22,380 --> 00:43:25,340
make sure you understand it,
to get a sense of how

641
00:43:25,340 --> 00:43:26,960
functions work.

642
00:43:26,960 --> 00:43:29,650
And it's certainly related to
the current problem set, which

643
00:43:29,650 --> 00:43:32,190
would be another good reason
to work through it--

644
00:43:32,190 --> 00:43:34,430
the problem set that will
be posted today--

645
00:43:34,430 --> 00:43:38,210
the new problem set, PS 2.

646
00:43:38,210 --> 00:43:42,750
Note again how careful I am
about the specifications.

647
00:43:42,750 --> 00:43:56,600
And I should point out something
interesting, if I

648
00:43:56,600 --> 00:44:02,330
type find root, open para--
well let's do this here.

649
00:44:14,070 --> 00:44:16,910
Let's clear things up.

650
00:44:16,910 --> 00:44:22,210
Let's get rid of things
that will cause

651
00:44:22,210 --> 00:44:23,460
the program to halt.

652
00:44:33,190 --> 00:44:37,740
Notice that when I type find
root open, open paren, it's

653
00:44:37,740 --> 00:44:39,230
given me the values--

654
00:44:39,230 --> 00:44:42,860
the names of the formal
parameters, which I've chosen

655
00:44:42,860 --> 00:44:46,430
in such way that will remind me
what their value should be.

656
00:44:46,430 --> 00:44:51,260
And it's also given me part of
the specification, the piece

657
00:44:51,260 --> 00:44:56,830
in the triple quotation marks
to tell me the rules I'm

658
00:44:56,830 --> 00:44:59,890
supposed to be following
here on these things.

659
00:44:59,890 --> 00:45:02,080
So it's a very handy thing.

660
00:45:02,080 --> 00:45:05,990
And as you use IDLE, you'll get
used to the fact that this

661
00:45:05,990 --> 00:45:09,480
is a convenience.

662
00:45:09,480 --> 00:45:12,290
All right, work your way
through that code.

663
00:45:12,290 --> 00:45:14,820
Make sure you know
what it does.

664
00:45:14,820 --> 00:45:20,670
Finally, today I want to switch
gears, and talk about

665
00:45:20,670 --> 00:45:22,870
something else.

666
00:45:22,870 --> 00:45:26,620
Up till now, all of the programs
we've looked at have

667
00:45:26,620 --> 00:45:28,590
been numeric--

668
00:45:28,590 --> 00:45:30,060
they've played with numbers.

669
00:45:30,060 --> 00:45:33,060
And I've done that, because I
assumed you guys all had some

670
00:45:33,060 --> 00:45:36,420
intuition about numbers.

671
00:45:36,420 --> 00:45:39,890
I've use strings as a primitive
data element to

672
00:45:39,890 --> 00:45:43,250
print things, but we haven't
done anything very interesting

673
00:45:43,250 --> 00:45:44,500
with strings.

674
00:45:46,570 --> 00:45:52,590
However strings are indeed quite
interesting, in that

675
00:45:52,590 --> 00:45:56,910
they're the first non-scalar
value we've looked at.

676
00:45:56,910 --> 00:46:01,250
You'll recall non-scalar values
are values that can be

677
00:46:01,250 --> 00:46:03,880
decomposed.

678
00:46:03,880 --> 00:46:25,110
So if we now look at the code
again, I've got this little

679
00:46:25,110 --> 00:46:28,530
piece of code called
sumDigits.

680
00:46:28,530 --> 00:46:31,500
So before, the for statement
we looked at

681
00:46:31,500 --> 00:46:34,570
was for x in range.

682
00:46:34,570 --> 00:46:42,850
Well you can apply it to a for
statement to any type that has

683
00:46:42,850 --> 00:46:46,110
a way to enumerate
its elements.

684
00:46:46,110 --> 00:46:56,860
So for c in STR, actually of
1952, so I've taken the number

685
00:46:56,860 --> 00:47:01,240
1952 and converted it to a
string so it will now be quote

686
00:47:01,240 --> 00:47:07,110
one nine five two, I can now
do something to every

687
00:47:07,110 --> 00:47:10,780
character in that string.

688
00:47:10,780 --> 00:47:13,840
And what I'm doing is converting
it back to an int,

689
00:47:13,840 --> 00:47:16,010
and then adding it.

690
00:47:16,010 --> 00:47:18,140
So this will give me the
sum of the digits.

691
00:47:25,290 --> 00:47:26,540
17.

692
00:47:28,300 --> 00:47:32,500
This is a very convenient
mechanism, and you'll use for

693
00:47:32,500 --> 00:47:34,270
a lot, this way.

694
00:47:34,270 --> 00:47:36,830
You'll use it in fact more for
this sort of thing then you

695
00:47:36,830 --> 00:47:38,480
will for ints.

696
00:47:41,420 --> 00:47:43,680
Now I can also select values.

697
00:47:46,370 --> 00:47:48,140
So if I look at--

698
00:47:57,470 --> 00:47:59,370
I don't know what's
going on here.

699
00:47:59,370 --> 00:48:02,470
Every once in while when you go
back and forth between the

700
00:48:02,470 --> 00:48:05,910
editor and the shell, the shell
hangs and you have to go

701
00:48:05,910 --> 00:48:07,055
try it again.

702
00:48:07,055 --> 00:48:16,850
If I go to s equals abc, I can
look at individual elements of

703
00:48:16,850 --> 00:48:22,780
s, for example s sub
0, which will be a.

704
00:48:22,780 --> 00:48:25,950
I can also look at
slices of s.

705
00:48:25,950 --> 00:48:28,970
So for example s
from 0 to one.

706
00:48:33,920 --> 00:48:35,950
That's interesting.

707
00:48:35,950 --> 00:48:37,080
What is it doing?

708
00:48:37,080 --> 00:48:38,230
Now try and infer.

709
00:48:38,230 --> 00:48:39,480
I'll give you another example.

710
00:48:47,060 --> 00:48:49,990
So you'll remember when we
did range from x to y, it

711
00:48:49,990 --> 00:48:52,770
went y minus 1.

712
00:48:52,770 --> 00:48:54,455
Same kind of thing is
happening here.

713
00:48:58,430 --> 00:49:02,460
So that's why s from 0 to one
gives me only one character,

714
00:49:02,460 --> 00:49:07,190
but s from 0 to two gives me
the character string ab.

715
00:49:07,190 --> 00:49:17,800
This is what's called slicing,
and it's very common.

716
00:49:17,800 --> 00:49:21,540
What a slice does, is it
makes a new copy--

717
00:49:21,540 --> 00:49:24,970
makes a new object, in this
case-- which is a sub-string

718
00:49:24,970 --> 00:49:26,220
of the original string.

719
00:49:30,180 --> 00:49:32,590
There are many other things
I can do on strings.

720
00:49:32,590 --> 00:49:41,470
I can do something like s.find,
and it will tell me

721
00:49:41,470 --> 00:49:45,230
that b is at position
number one in s.

722
00:49:45,230 --> 00:49:51,440
So use Google, whatever you use,
to find the Python web

723
00:49:51,440 --> 00:49:53,830
page that describe strings, and
it will give you all of

724
00:49:53,830 --> 00:49:56,880
the operations you can do.

725
00:49:56,880 --> 00:49:58,130
And they're quite convenient.

726
00:50:02,310 --> 00:50:05,060
One other scalar type that
you're going to need for the

727
00:50:05,060 --> 00:50:09,520
problem set is tuples, and
that will be discussed in

728
00:50:09,520 --> 00:50:12,300
recitation tomorrow.

729
00:50:12,300 --> 00:50:13,550
OK, thanks a lot.