1
00:00:00,040 --> 00:00:02,460
The following content is
provided under a Creative

2
00:00:02,460 --> 00:00:03,870
Commons license.

3
00:00:03,870 --> 00:00:06,910
Your support will help MIT
OpenCourseWare continue to

4
00:00:06,910 --> 00:00:10,560
offer high quality educational
resources for free.

5
00:00:10,560 --> 00:00:13,460
To make a donation or view
additional materials from

6
00:00:13,460 --> 00:00:18,440
hundreds of MIT courses, visit
MIT OpenCourseWare at

7
00:00:18,440 --> 00:00:19,690
ocw.mit.edu.

8
00:00:22,800 --> 00:00:23,940
PROFESSOR: Good morning.

9
00:00:23,940 --> 00:00:25,400
AUDIENCE: Good morning.

10
00:00:25,400 --> 00:00:27,280
PROFESSOR: Thank you.

11
00:00:27,280 --> 00:00:28,440
OK.

12
00:00:28,440 --> 00:00:32,960
So we're about to launch into
learning some basic elements

13
00:00:32,960 --> 00:00:35,430
of Python today.

14
00:00:35,430 --> 00:00:39,220
The elements I'm going to talk
about are common to every

15
00:00:39,220 --> 00:00:44,030
programming language that I
know, at least in concept, and

16
00:00:44,030 --> 00:00:46,950
of course slightly different
in detail.

17
00:00:46,950 --> 00:00:49,560
But as I said last time,
everything you're going to

18
00:00:49,560 --> 00:00:53,125
learn about Python should
be readily transferable.

19
00:00:55,720 --> 00:01:03,390
I'll be using, for all of the
examples I present, something

20
00:01:03,390 --> 00:01:07,810
called an integrated development
environment, and

21
00:01:07,810 --> 00:01:13,775
in particular, one that's built
for Python called IDLE.

22
00:01:22,030 --> 00:01:25,185
Usually we talk about these
things as IDEs.

23
00:01:39,010 --> 00:01:45,160
I'm told, I don't know if it's
true, that the IDE for Python

24
00:01:45,160 --> 00:01:51,500
is called IDLE after Eric Idle
of Monty Python, which was

25
00:01:51,500 --> 00:01:53,800
also, I'm told, the inspiration
for the name of

26
00:01:53,800 --> 00:01:55,050
the programming language.

27
00:01:57,960 --> 00:02:00,860
So what is an integrated
programming environment?

28
00:02:00,860 --> 00:02:10,259
In this case, it includes a
specialized text editor that

29
00:02:10,259 --> 00:02:15,760
provides highlighting,
auto-completion, smart indent,

30
00:02:15,760 --> 00:02:19,020
and you'll see shortly why all
that's very important, and a

31
00:02:19,020 --> 00:02:23,220
few other amenities that make it
easier to use this to type

32
00:02:23,220 --> 00:02:28,690
Python than typing it into
a generic text editor.

33
00:02:28,690 --> 00:02:35,150
It includes something called
a shell, which is the

34
00:02:35,150 --> 00:02:39,245
environment that actually
interprets the Python code.

35
00:02:42,000 --> 00:02:46,950
And the nice thing about it
is it includes syntax

36
00:02:46,950 --> 00:02:48,200
highlighting.

37
00:02:50,150 --> 00:02:54,300
So the shell gives you some
information about the syntax,

38
00:02:54,300 --> 00:02:58,650
as does the text editor
of course.

39
00:02:58,650 --> 00:03:01,950
And finally, it includes
an integrated debugger.

40
00:03:05,640 --> 00:03:08,470
This could be useful in the
unlikely event that your

41
00:03:08,470 --> 00:03:12,940
programs have errors when
you write them.

42
00:03:12,940 --> 00:03:16,860
Though truth be told, I've been
programming in Python for

43
00:03:16,860 --> 00:03:20,760
years and I don't know that I've
ever used the debugger.

44
00:03:20,760 --> 00:03:23,200
It's not that I don't make
mistakes, it's just that I'm

45
00:03:23,200 --> 00:03:26,660
kind of a Luddite, and I
typically use print statements

46
00:03:26,660 --> 00:03:28,430
for debugging.

47
00:03:28,430 --> 00:03:31,800
And in fact, almost every
programmer that I know, when

48
00:03:31,800 --> 00:03:35,280
push comes to shove, ends up
using print statements.

49
00:03:35,280 --> 00:03:40,800
But the debugger is there,
should you care to take a try.

50
00:03:40,800 --> 00:03:41,690
All right.

51
00:03:41,690 --> 00:03:46,940
So you'll see on the screen
here an IDLE shell.

52
00:03:46,940 --> 00:03:50,800
In the shell, we can
type things.

53
00:03:50,800 --> 00:03:53,100
What are we going to type?

54
00:03:53,100 --> 00:03:58,681
Well the first thing to
understand is that at the core

55
00:03:58,681 --> 00:04:02,970
of Python, and probably the
most important thing to

56
00:04:02,970 --> 00:04:06,235
understand, are something
called objects.

57
00:04:10,380 --> 00:04:14,990
Everything in Python
is an object.

58
00:04:14,990 --> 00:04:18,579
So every kind of entity that you
can create in Python is an

59
00:04:18,579 --> 00:04:24,040
object, and in fact, Python
code itself is an object.

60
00:04:24,040 --> 00:04:26,830
You'll remember, we talked about
stored program computers

61
00:04:26,830 --> 00:04:31,480
last time, and the concept that
a program is data, just

62
00:04:31,480 --> 00:04:35,020
like a number is data.

63
00:04:35,020 --> 00:04:46,250
Each object has a type that
tells us the kind of object it

64
00:04:46,250 --> 00:04:52,910
is, and in particular, what
we can do with it.

65
00:04:52,910 --> 00:04:58,020
And then there's a built-in
function, called type, that

66
00:04:58,020 --> 00:05:00,370
can be used to find out
the type of an object.

67
00:05:04,520 --> 00:05:09,510
As we'll see, there are two
fundamental kinds of types.

68
00:05:13,500 --> 00:05:16,640
Scalar and non-scalar.

69
00:05:21,070 --> 00:05:25,330
We'll start with talking
about scalar types.

70
00:05:25,330 --> 00:05:29,030
And the key thing to think about
there is that they are

71
00:05:29,030 --> 00:05:30,280
indivisible.

72
00:05:33,660 --> 00:05:37,300
Think of them as the atoms of
the programming language.

73
00:05:37,300 --> 00:05:40,100
Now, I know that some of you
have studied physics and know

74
00:05:40,100 --> 00:05:44,210
that atoms are in principle
divisible, but of course, only

75
00:05:44,210 --> 00:05:48,020
at great expense and with
serious consequences.

76
00:05:48,020 --> 00:05:49,500
And we've seen the
same thing here.

77
00:05:49,500 --> 00:05:54,390
You can, if you're desperate,
chop up these scalar types,

78
00:05:54,390 --> 00:06:00,030
but it almost always leads
to something bad.

79
00:06:00,030 --> 00:06:00,380
All right.

80
00:06:00,380 --> 00:06:02,230
Well let's look at some.

81
00:06:02,230 --> 00:06:07,890
Well, the first one you'll see
is used to represent integers,

82
00:06:07,890 --> 00:06:10,100
and that's called int.

83
00:06:10,100 --> 00:06:14,140
For every type, or every
built-in type, there's the

84
00:06:14,140 --> 00:06:17,110
notion of a literal, which
is how we type it.

85
00:06:17,110 --> 00:06:24,470
So for example, we can type 3,
and that will now tell us it

86
00:06:24,470 --> 00:06:27,400
is the value 3.

87
00:06:27,400 --> 00:06:29,430
You'll note it's typed
it in blue.

88
00:06:29,430 --> 00:06:32,660
And I can ask what
the type of 3 is.

89
00:06:32,660 --> 00:06:35,940
So you'll notice as I type
things into the shell, it's

90
00:06:35,940 --> 00:06:38,660
using colors to give
me a hint.

91
00:06:38,660 --> 00:06:42,850
So it's this fuchsia color for
the word type, telling me

92
00:06:42,850 --> 00:06:46,320
that's a built-in function.

93
00:06:46,320 --> 00:06:50,370
And now if I ask it, it will
tell me that the type of the

94
00:06:50,370 --> 00:06:54,930
literal 3 is "int".

95
00:06:54,930 --> 00:06:57,930
So it's an integer.

96
00:06:57,930 --> 00:07:00,410
And I can use other
sorts of things.

97
00:07:06,430 --> 00:07:06,900
All right.

98
00:07:06,900 --> 00:07:10,930
There's also a type float.

99
00:07:10,930 --> 00:07:14,130
So those correspond to
the real numbers.

100
00:07:14,130 --> 00:07:18,470
So I can do something
like that.

101
00:07:18,470 --> 00:07:22,170
And we'll talk about this in a
second, but you'll notice if I

102
00:07:22,170 --> 00:07:26,210
do type of 3.2, it tells
me it's a float.

103
00:07:26,210 --> 00:07:31,980
And for that matter, I can do
type of 3.0, and it will tell

104
00:07:31,980 --> 00:07:35,060
me it's a float.

105
00:07:35,060 --> 00:07:37,996
So there's a difference
between 3 and 3.0.

106
00:07:37,996 --> 00:07:41,940
One is an int, and
one is a float.

107
00:07:41,940 --> 00:07:46,630
Now you'll notice something
kind of weird here.

108
00:07:46,630 --> 00:07:51,940
When the interpreter printed
back the value of the literal

109
00:07:51,940 --> 00:07:57,590
3.2, it gave me 3.2 and a bunch
of zeroes, and then this

110
00:07:57,590 --> 00:08:01,580
funny 2 standing at the end.

111
00:08:01,580 --> 00:08:06,040
In a few lectures, I'll explain
why it does this, but

112
00:08:06,040 --> 00:08:11,620
for now, you should just take
this as a warning that floats

113
00:08:11,620 --> 00:08:15,650
are not the same thing
as real numbers.

114
00:08:15,650 --> 00:08:18,490
You learned about reals,
presumably in middle school or

115
00:08:18,490 --> 00:08:21,390
high school.

116
00:08:21,390 --> 00:08:25,180
Floats are a computer
scientist's approximation to

117
00:08:25,180 --> 00:08:28,990
reals, but they're not
quite the same.

118
00:08:28,990 --> 00:08:32,780
The good news is almost all the
time, you can pretend that

119
00:08:32,780 --> 00:08:36,580
a floating point number is a
real, but as we'll see in a

120
00:08:36,580 --> 00:08:41,039
few lectures, every once in a
while it can really sit up and

121
00:08:41,039 --> 00:08:43,520
bite you, if you believe that.

122
00:08:43,520 --> 00:08:46,010
But for now, we'll just pretend
that they're reals.

123
00:08:51,660 --> 00:08:55,030
There's Booleans, a nice scalar
type of which there are

124
00:08:55,030 --> 00:08:56,280
only two values.

125
00:08:59,960 --> 00:09:03,200
One of them is true, and what
do you think the other

126
00:09:03,200 --> 00:09:04,895
Boolean value is?

127
00:09:04,895 --> 00:09:06,200
AUDIENCE: False?

128
00:09:06,200 --> 00:09:07,230
PROFESSOR: Thank you.

129
00:09:07,230 --> 00:09:08,570
So somebody said false.

130
00:09:08,570 --> 00:09:12,000
I have no idea who, but
whoever it is, there's

131
00:09:12,000 --> 00:09:14,300
probably some candy to be had.

132
00:09:14,300 --> 00:09:16,940
Oh, I managed to find the one
place in the room where there

133
00:09:16,940 --> 00:09:18,520
was an empty.

134
00:09:18,520 --> 00:09:21,220
I'm hoping that people will now
scramble and fight for it,

135
00:09:21,220 --> 00:09:25,070
like a foul ball at
a baseball game.

136
00:09:25,070 --> 00:09:27,320
No, people are too
polite thus far.

137
00:09:27,320 --> 00:09:28,520
All right.

138
00:09:28,520 --> 00:09:31,840
So we have true and false
as the type Booleans.

139
00:09:31,840 --> 00:09:33,870
And then we can do operations
on them.

140
00:09:33,870 --> 00:09:42,650
So for example, true and false
is false, as you might guess.

141
00:09:42,650 --> 00:09:49,650
Finally, there's this funny
value, none, which doesn't

142
00:09:49,650 --> 00:09:51,620
print anything when I type it.

143
00:09:51,620 --> 00:09:56,150
And if I look at the type
of none, we'll see

144
00:09:56,150 --> 00:09:59,130
it's the none type.

145
00:09:59,130 --> 00:10:01,070
Not very interesting.

146
00:10:01,070 --> 00:10:05,000
Fundamentally, as we'll see,
that gets used when you want

147
00:10:05,000 --> 00:10:06,700
to put in something temporary.

148
00:10:06,700 --> 00:10:09,760
When you don't yet know what its
value is going to be, you

149
00:10:09,760 --> 00:10:13,170
know it's going to eventually
have one, so maybe you start

150
00:10:13,170 --> 00:10:15,180
out calling it none.

151
00:10:15,180 --> 00:10:17,440
And then you can check,
and we'll see

152
00:10:17,440 --> 00:10:20,180
how we might do that.

153
00:10:20,180 --> 00:10:25,925
So those are the fundamental
scalar types,

154
00:10:25,925 --> 00:10:29,800
the indivisible ones.

155
00:10:29,800 --> 00:10:35,290
Interestingly enough, Python
does not have what is a common

156
00:10:35,290 --> 00:10:39,650
scalar type in every other
language called char, short

157
00:10:39,650 --> 00:10:41,740
for character.

158
00:10:41,740 --> 00:10:48,190
Instead, what it has is strings
that can be used to

159
00:10:48,190 --> 00:10:51,360
represent strings
of characters.

160
00:10:51,360 --> 00:10:58,500
So for example, I can write the
string "a", and if I ask

161
00:10:58,500 --> 00:11:03,200
for the type of it, it
tells me it's an

162
00:11:03,200 --> 00:11:05,485
str, short for string.

163
00:11:09,450 --> 00:11:12,770
Happens to be a string of
length 1, which we might

164
00:11:12,770 --> 00:11:15,730
usually think of as
a character, but

165
00:11:15,730 --> 00:11:17,510
there is no type char.

166
00:11:17,510 --> 00:11:19,080
So it's not a problem.

167
00:11:19,080 --> 00:11:21,920
We just have to remember it.

168
00:11:21,920 --> 00:11:28,270
Literals of type string can be
written with single quotes or

169
00:11:28,270 --> 00:11:29,520
with double quotes.

170
00:11:32,110 --> 00:11:34,720
There's no difference.

171
00:11:34,720 --> 00:11:39,250
Just convenient that you can do
it either way, and we can

172
00:11:39,250 --> 00:11:42,600
build strings of things.

173
00:11:42,600 --> 00:11:49,940
It's worth noting that the type
of, say, the string 123

174
00:11:49,940 --> 00:12:00,390
is str, whereas the type of 123
without the quotes is int.

175
00:12:00,390 --> 00:12:03,020
So we have to be a little bit
careful sometimes as to

176
00:12:03,020 --> 00:12:07,860
whether we're dealing with
strings or ints when we look

177
00:12:07,860 --> 00:12:09,110
at these literals.

178
00:12:11,530 --> 00:12:17,060
You can only get so far with
literals, things you can type.

179
00:12:17,060 --> 00:12:20,310
So of course, Python has in
it something called an

180
00:12:20,310 --> 00:12:21,870
expression.

181
00:12:21,870 --> 00:12:23,620
Again, this shouldn't
surprise anybody.

182
00:12:31,185 --> 00:12:40,830
And an expression
is a sequence of

183
00:12:40,830 --> 00:12:45,305
operands and operators.

184
00:12:50,950 --> 00:12:52,340
The operands are objects.

185
00:12:59,610 --> 00:13:05,900
So for example, we can write
the expression 3 plus 2.

186
00:13:05,900 --> 00:13:09,180
And when we type an expression
into IDLE, it automatically

187
00:13:09,180 --> 00:13:13,240
evaluates it and prints the
value of the expression.

188
00:13:13,240 --> 00:13:15,605
In this case, of
course it's 5.

189
00:13:18,230 --> 00:13:22,500
One thing to be a little careful
about is if I type the

190
00:13:22,500 --> 00:13:29,005
expression 3/2, slash is the
divide operator, I get 1.

191
00:13:32,150 --> 00:13:35,620
Whereas if I type the expression
3.0 divided

192
00:13:35,620 --> 00:13:43,310
by 2.0, I get 1.5.

193
00:13:43,310 --> 00:13:49,760
So dividing two integers
in Python 2.x gives you

194
00:13:49,760 --> 00:13:51,405
essentially a floor operator.

195
00:13:53,940 --> 00:13:59,120
In 3.0, by the way, integer
division is not allowed.

196
00:13:59,120 --> 00:14:01,780
It always converts it to floats
and does a floating

197
00:14:01,780 --> 00:14:03,670
point division.

198
00:14:03,670 --> 00:14:06,370
But for many of you this will
be something that will trip

199
00:14:06,370 --> 00:14:08,520
you up as a bug.

200
00:14:08,520 --> 00:14:12,970
If you want to get real
division, write

201
00:14:12,970 --> 00:14:15,030
floating point numbers.

202
00:14:15,030 --> 00:14:20,640
Otherwise, unpleasant
things may happen.

203
00:14:20,640 --> 00:14:24,240
Some other interesting things
I can type, just as I could

204
00:14:24,240 --> 00:14:32,050
type 3 plus 2, I can
type a plus b.

205
00:14:32,050 --> 00:14:33,300
What do you think
I'll get there?

206
00:14:37,160 --> 00:14:38,490
It does concatenation.

207
00:14:41,680 --> 00:14:49,190
So what we see here is that
the operator plus is

208
00:14:49,190 --> 00:14:50,440
overloaded.

209
00:14:59,060 --> 00:15:11,120
So overloaded operators have a
meaning that depends upon the

210
00:15:11,120 --> 00:15:12,370
type of the operands.

211
00:15:25,710 --> 00:15:28,170
And of course, we've already
seen that with the slash

212
00:15:28,170 --> 00:15:31,430
operator, which means one thing
for ints and another

213
00:15:31,430 --> 00:15:33,310
things for floats.

214
00:15:33,310 --> 00:15:35,585
And of course, we see the
same thing with plus.

215
00:15:39,700 --> 00:15:41,490
What do you think will
happen here?

216
00:15:41,490 --> 00:15:44,810
3 blank 3?

217
00:15:44,810 --> 00:15:46,060
Any guesses?

218
00:15:48,390 --> 00:15:50,120
I get a syntax error.

219
00:15:50,120 --> 00:15:52,810
Remember, we talked about
that on Tuesday.

220
00:15:52,810 --> 00:15:57,490
It's not a valid Python
expression,

221
00:15:57,490 --> 00:16:00,670
so we get an error.

222
00:16:00,670 --> 00:16:01,920
How about this one?

223
00:16:06,380 --> 00:16:09,400
That is syntactically valid.

224
00:16:09,400 --> 00:16:13,280
It's got operand, operator,
operand.

225
00:16:13,280 --> 00:16:17,830
What do you think it will do
when I hit Return here?

226
00:16:17,830 --> 00:16:20,040
Somebody?

227
00:16:20,040 --> 00:16:22,000
AUDIENCE: A static
semantics error?

228
00:16:22,000 --> 00:16:22,490
PROFESSOR: Pardon?

229
00:16:22,490 --> 00:16:24,450
AUDIENCE: A static
semantics error?

230
00:16:24,450 --> 00:16:26,410
PROFESSOR: A static
semantics error.

231
00:16:26,410 --> 00:16:26,900
And because of these--

232
00:16:26,900 --> 00:16:28,500
Wait, I can't see
who said that.

233
00:16:28,500 --> 00:16:29,995
Raise your hand?

234
00:16:29,995 --> 00:16:31,480
Oh, come on.

235
00:16:31,480 --> 00:16:33,955
All the way back there?

236
00:16:33,955 --> 00:16:34,945
All right.

237
00:16:34,945 --> 00:16:37,915
I have the most chance of
carrying with one of these.

238
00:16:43,870 --> 00:16:45,260
I'm going to lie.

239
00:16:45,260 --> 00:16:47,460
Those of you who are watching
OpenCourseWare, it was a

240
00:16:47,460 --> 00:16:48,710
perfect throw.

241
00:16:51,450 --> 00:16:52,210
OK.

242
00:16:52,210 --> 00:16:58,310
So indeed, we get a static
semantic error of a particular

243
00:16:58,310 --> 00:17:01,770
kind, called the type error,
saying you cannot concatenate

244
00:17:01,770 --> 00:17:04,440
an str and an int.

245
00:17:08,140 --> 00:17:12,345
Type errors are actually
good things.

246
00:17:15,190 --> 00:17:19,530
The language does type checking
in order to reduce

247
00:17:19,530 --> 00:17:22,450
the probability that a
programmer will write a

248
00:17:22,450 --> 00:17:28,980
program with a meaning that
will surprise its author.

249
00:17:28,980 --> 00:17:32,380
So it looks at it and says,
somebody might have a weird

250
00:17:32,380 --> 00:17:35,760
guess what this means, but just
to be safe, we're going

251
00:17:35,760 --> 00:17:38,560
to disallow it rather than--

252
00:17:38,560 --> 00:17:40,750
it could, of course, make
up some funny meaning

253
00:17:40,750 --> 00:17:42,600
if it wanted to.

254
00:17:42,600 --> 00:17:43,970
But it doesn't.

255
00:17:43,970 --> 00:17:48,740
And I think you'll find type
checking saves you from a lot

256
00:17:48,740 --> 00:17:55,020
of careless programming
errors as you go on.

257
00:17:55,020 --> 00:17:56,410
All right, let's continue.

258
00:17:56,410 --> 00:17:58,840
Let's look at some
other things.

259
00:17:58,840 --> 00:18:00,090
I can write this.

260
00:18:04,920 --> 00:18:07,450
Because that's just two
strings, and it just

261
00:18:07,450 --> 00:18:12,370
concatenates them, the string
a and the string 3.

262
00:18:12,370 --> 00:18:14,310
Or interestingly,
I can do this.

263
00:18:18,690 --> 00:18:22,530
So now what we're seeing is
that you can take any type

264
00:18:22,530 --> 00:18:29,260
name, use it as a conversion
function to attempt to convert

265
00:18:29,260 --> 00:18:31,950
one type to another.

266
00:18:31,950 --> 00:18:37,330
So this has now converted the
int 3 to the str "3".

267
00:18:41,690 --> 00:18:44,815
Similarly, I can do something
like this.

268
00:18:51,010 --> 00:18:56,430
And here, it's converted the
str "3" to the int 3.

269
00:19:00,250 --> 00:19:01,865
On the other hand,
I could do this.

270
00:19:12,280 --> 00:19:17,670
And it will tell me it's a
static semantic error.

271
00:19:17,670 --> 00:19:23,450
It can't convert 0.0
into an int.

272
00:19:23,450 --> 00:19:31,840
Similarly, it can't
convert 2.1.

273
00:19:31,840 --> 00:19:33,670
Or can it?

274
00:19:33,670 --> 00:19:37,460
So now I've given it the float
2.1, and I've tried to

275
00:19:37,460 --> 00:19:39,120
convert it to int.

276
00:19:39,120 --> 00:19:41,760
Not the string 2.1,
but the float.

277
00:19:41,760 --> 00:19:43,010
And it succeeds.

278
00:19:45,580 --> 00:19:49,110
And it succeeded by essentially
truncating it.

279
00:19:53,280 --> 00:19:55,280
Is this a good thing
or a bad thing?

280
00:19:57,960 --> 00:20:00,690
To me, it's kind
of a bad thing.

281
00:20:00,690 --> 00:20:04,050
If I've typed something like
that or I've evaluated some

282
00:20:04,050 --> 00:20:08,610
expression that happened to
work that way, more likely

283
00:20:08,610 --> 00:20:10,010
than not, I'm confused.

284
00:20:10,010 --> 00:20:13,660
And I would probably have
preferred to get a type error,

285
00:20:13,660 --> 00:20:17,180
rather than it deciding
how to do it.

286
00:20:17,180 --> 00:20:20,740
It's one of the things I don't
like about Python.

287
00:20:20,740 --> 00:20:22,600
It's too generous.

288
00:20:22,600 --> 00:20:24,760
It lets me get away with
stuff it shouldn't

289
00:20:24,760 --> 00:20:26,560
let me get away with.

290
00:20:26,560 --> 00:20:31,020
Other languages, for example
Java, are much stricter.

291
00:20:31,020 --> 00:20:35,310
This is a design decision and
it is the way it is, and we

292
00:20:35,310 --> 00:20:36,896
have to live with it.

293
00:20:36,896 --> 00:20:37,830
AUDIENCE: Professor?

294
00:20:37,830 --> 00:20:38,290
Yes?

295
00:20:38,290 --> 00:20:40,720
AUDIENCE: Is that the same
reason that 3 divided by 2

296
00:20:40,720 --> 00:20:42,664
turned into 1 up top?

297
00:20:42,664 --> 00:20:43,150
PROFESSOR: Yeah.

298
00:20:43,150 --> 00:20:44,620
Exactly.

299
00:20:44,620 --> 00:20:48,965
If it's the same reason that
that happens, this will never

300
00:20:48,965 --> 00:20:52,304
go that far.

301
00:20:52,304 --> 00:20:53,735
[UNINTELLIGIBLE].

302
00:20:53,735 --> 00:20:55,440
Yeah, exactly.

303
00:20:55,440 --> 00:20:56,590
It's the same reason.

304
00:20:56,590 --> 00:20:59,380
The question was, is it the same
reason that 3 divided by

305
00:20:59,380 --> 00:21:02,940
2 doesn't give you the
answer you would get

306
00:21:02,940 --> 00:21:03,880
with floating point.

307
00:21:03,880 --> 00:21:08,130
And it's because Python
has tried to help you.

308
00:21:08,130 --> 00:21:13,210
Again, Python 3.0 is a little
stricter about these things.

309
00:21:13,210 --> 00:21:15,590
We'll talk much more about
this during the term.

310
00:21:18,600 --> 00:21:22,370
This is close to the last time
you'll see me typing things

311
00:21:22,370 --> 00:21:24,940
directly into IDLE.

312
00:21:24,940 --> 00:21:28,220
For the most part, as you write
programs, you'll use the

313
00:21:28,220 --> 00:21:32,220
text editor to produce them
and then go to the

314
00:21:32,220 --> 00:21:34,080
shell to run them.

315
00:21:34,080 --> 00:21:36,180
But you want to--

316
00:21:36,180 --> 00:21:38,920
obviously, if I had a 100 line
program, I wouldn't want to

317
00:21:38,920 --> 00:21:42,690
sit here and retype it every
time I needed to change it.

318
00:21:42,690 --> 00:21:45,320
So instead, I use the editor
in IDLE to produce the

319
00:21:45,320 --> 00:21:49,320
programs, and then
I can run them.

320
00:21:49,320 --> 00:21:52,200
And that's what I wanted
to start doing.

321
00:21:52,200 --> 00:21:58,160
I should probably mention that
what most people call a

322
00:21:58,160 --> 00:22:03,650
program, some Python programmers
call a script.

323
00:22:07,130 --> 00:22:10,790
Think of those two things
as synonyms.

324
00:22:10,790 --> 00:22:15,020
But you will see people
use both of them.

325
00:22:15,020 --> 00:22:19,180
I will typically call
them a program.

326
00:22:19,180 --> 00:22:19,530
All right.

327
00:22:19,530 --> 00:22:22,790
Let's look at an example.

328
00:22:22,790 --> 00:22:27,450
So the first thing to say is
that things look a little bit

329
00:22:27,450 --> 00:22:30,950
different when they're executed
from a script than

330
00:22:30,950 --> 00:22:35,040
when you execute them directly
in the interpreter.

331
00:22:35,040 --> 00:22:37,825
So I happen to have
a script here.

332
00:22:40,900 --> 00:22:44,440
If a line in a script starts
with a sharp sign or a number

333
00:22:44,440 --> 00:22:47,360
sign, that makes it a comment.

334
00:22:47,360 --> 00:22:49,300
So it's not executed.

335
00:22:49,300 --> 00:22:53,365
So I've started here just by
commenting out everything.

336
00:22:57,070 --> 00:22:58,660
But now--

337
00:22:58,660 --> 00:22:59,910
whoops--

338
00:23:05,230 --> 00:23:08,250
what happens if I just put
the number 3 here?

339
00:23:08,250 --> 00:23:12,600
We saw when I typed it into
IDLE, it echoed it in some

340
00:23:12,600 --> 00:23:14,615
sense and gave me what it was.

341
00:23:14,615 --> 00:23:18,170
Or just to be clear, I'm
going to put in the

342
00:23:18,170 --> 00:23:21,630
expression type of 3.

343
00:23:21,630 --> 00:23:27,380
I'll save it, and then I'll
hit F5 to run it.

344
00:23:27,380 --> 00:23:28,840
And it does nothing.

345
00:23:28,840 --> 00:23:29,190
Right?

346
00:23:29,190 --> 00:23:30,470
You saw it move.

347
00:23:30,470 --> 00:23:32,360
It didn't print anything.

348
00:23:32,360 --> 00:23:34,770
So when you type an expression
into the shell,

349
00:23:34,770 --> 00:23:36,690
it prints the value.

350
00:23:36,690 --> 00:23:39,760
But when it executes a script
with an expression, it

351
00:23:39,760 --> 00:23:42,430
evaluates the expression
but does not

352
00:23:42,430 --> 00:23:45,590
display it on the screen.

353
00:23:45,590 --> 00:23:48,420
Well, so what do we
do about that?

354
00:23:48,420 --> 00:23:52,520
There is something called
a print command.

355
00:23:52,520 --> 00:24:01,260
So I can do this, Print type of
3, and now if I run it, it

356
00:24:01,260 --> 00:24:03,890
will actually appear.

357
00:24:03,890 --> 00:24:06,200
So whenever you want to get
something to appear, you have

358
00:24:06,200 --> 00:24:09,600
to use the Print command.

359
00:24:09,600 --> 00:24:11,315
Not a very complicated
concept.

360
00:24:16,220 --> 00:24:25,240
A program, or a script, is
a sequence of commands.

361
00:24:28,610 --> 00:24:33,100
Each one tells the interpreter
to do something.

362
00:24:33,100 --> 00:24:35,660
So a command is Print,
for example.

363
00:24:42,470 --> 00:24:42,930
OK.

364
00:24:42,930 --> 00:24:43,980
So that's there.

365
00:24:43,980 --> 00:24:44,960
That's kind of boring.

366
00:24:44,960 --> 00:24:46,210
I'll get rid of that.

367
00:24:49,480 --> 00:24:55,040
The next command is a really
interesting one.

368
00:24:55,040 --> 00:24:58,750
It's an assignment statement.

369
00:24:58,750 --> 00:25:04,850
A key concept in almost every
programming language is that

370
00:25:04,850 --> 00:25:06,100
of a variable.

371
00:25:08,570 --> 00:25:12,010
Different languages have
different notions of what a

372
00:25:12,010 --> 00:25:14,940
variable means.

373
00:25:14,940 --> 00:25:21,540
In Python, a variable is simply
a name for an object.

374
00:25:43,880 --> 00:25:47,520
And what an assignment statement
does in Python, is

375
00:25:47,520 --> 00:25:51,315
it binds the name
to an object.

376
00:26:05,860 --> 00:26:11,390
So the assignment stetement you
see here binds the name x

377
00:26:11,390 --> 00:26:12,715
to the object 3.

378
00:26:17,650 --> 00:26:22,750
The next statement rebinds the
name x to the value of the

379
00:26:22,750 --> 00:26:25,530
expression x times x.

380
00:26:25,530 --> 00:26:30,190
So it takes the old value of x,
evaluates the expression,

381
00:26:30,190 --> 00:26:33,200
and then binds the name
x to the new value.

382
00:26:33,200 --> 00:26:36,870
So at the end of the
second statement, x

383
00:26:36,870 --> 00:26:38,560
will be bound to 9.

384
00:26:38,560 --> 00:26:41,020
By the way, these are really
stupid comments

385
00:26:41,020 --> 00:26:43,320
I've written here.

386
00:26:43,320 --> 00:26:44,920
I put them in just to
show you what these

387
00:26:44,920 --> 00:26:46,390
statements are doing.

388
00:26:46,390 --> 00:26:49,210
For goodness sake, when you
write comments in your

389
00:26:49,210 --> 00:26:54,070
programs, assume that the reader
can read Python, and

390
00:26:54,070 --> 00:26:55,690
you don't have to explain
the programming

391
00:26:55,690 --> 00:26:58,310
language in your comments.

392
00:26:58,310 --> 00:27:01,360
That's not to say you shouldn't
write any comments.

393
00:27:01,360 --> 00:27:04,270
The purpose of a comment
is to make the

394
00:27:04,270 --> 00:27:08,030
program easier to read.

395
00:27:08,030 --> 00:27:11,390
And so typically, comments are
there to explain things.

396
00:27:13,950 --> 00:27:18,430
Not to explain the language or
its semantics, but to explain

397
00:27:18,430 --> 00:27:22,530
your thinking when you
wrote the program.

398
00:27:22,530 --> 00:27:26,450
What is the algorithm
you've used?

399
00:27:26,450 --> 00:27:29,950
And we'll see some useful
examples of comments, probably

400
00:27:29,950 --> 00:27:32,610
not today, but later.

401
00:27:32,610 --> 00:27:32,950
All right.

402
00:27:32,950 --> 00:27:34,570
So let's execute this script.

403
00:27:38,820 --> 00:27:41,890
Sure enough, it printed 9.

404
00:27:41,890 --> 00:27:43,365
Just what we would have hoped.

405
00:27:49,410 --> 00:27:49,770
All right.

406
00:27:49,770 --> 00:27:51,970
Now let's try some
other things.

407
00:27:57,220 --> 00:28:00,840
Print lets us output things.

408
00:28:00,840 --> 00:28:05,240
Raw input lets us
input things.

409
00:28:05,240 --> 00:28:10,070
Get things from the keyboard,
essentially.

410
00:28:10,070 --> 00:28:14,830
So this statement here is making
a request to whoever is

411
00:28:14,830 --> 00:28:17,280
using the program to
enter a number.

412
00:28:19,910 --> 00:28:26,100
There are two kinds of input
statements in Python 2.x.

413
00:28:26,100 --> 00:28:29,270
There's raw input, which is the
only one you will see me

414
00:28:29,270 --> 00:28:32,860
use, and input.

415
00:28:32,860 --> 00:28:38,770
Raw input, by the way, is the
only one that exists in 3.0.

416
00:28:38,770 --> 00:28:44,080
So please, just use raw input.

417
00:28:44,080 --> 00:28:48,710
The difference is, raw input
always expects, interprets

418
00:28:48,710 --> 00:28:52,690
what the user types
as a string.

419
00:28:52,690 --> 00:29:02,160
So it will see here, it says,
y equals float of raw input.

420
00:29:02,160 --> 00:29:03,600
Enter a number.

421
00:29:03,600 --> 00:29:06,750
So let's run it.

422
00:29:06,750 --> 00:29:12,220
So it's taken the argument to
raw input, the string enter a

423
00:29:12,220 --> 00:29:14,740
number asked me to
enter a number.

424
00:29:14,740 --> 00:29:15,990
I'll enter a number.

425
00:29:20,280 --> 00:29:28,390
And then it's converted
it to a float.

426
00:29:28,390 --> 00:29:29,845
Suppose I get rid of that.

427
00:29:32,600 --> 00:29:33,850
Suppose I do this.

428
00:29:50,560 --> 00:29:51,810
That should work.

429
00:30:06,170 --> 00:30:07,620
So now something has happened.

430
00:30:07,620 --> 00:30:11,140
It's printed both
of them as 3.0.

431
00:30:11,140 --> 00:30:14,480
It looks like they're
the same, but in

432
00:30:14,480 --> 00:30:17,880
fact, they're not.

433
00:30:17,880 --> 00:30:20,280
And this is something
to beware of.

434
00:30:20,280 --> 00:30:28,000
What we've seen here is when
it prints a string, it does

435
00:30:28,000 --> 00:30:31,760
not print the quotation marks.

436
00:30:31,760 --> 00:30:38,930
So even though, if I were to put
this in here, I'll put in

437
00:30:38,930 --> 00:30:40,480
two print types of y.

438
00:30:47,520 --> 00:30:50,590
And I'll comment this out
because I'm getting kind of

439
00:30:50,590 --> 00:30:51,950
tired of seeing 9.

440
00:31:03,230 --> 00:31:04,980
You'll note that one
is a string and

441
00:31:04,980 --> 00:31:07,860
the other is a float.

442
00:31:07,860 --> 00:31:10,130
Again, I point this out because
this is something that

443
00:31:10,130 --> 00:31:14,040
can confuse people when they're
debugging programs.

444
00:31:14,040 --> 00:31:16,530
Because you think it's
a float, when

445
00:31:16,530 --> 00:31:17,780
in fact it's a string.

446
00:31:20,750 --> 00:31:21,180
OK.

447
00:31:21,180 --> 00:31:24,830
Nothing deep, but these are the
things that sort of get

448
00:31:24,830 --> 00:31:27,650
people in trouble.

449
00:31:27,650 --> 00:31:32,590
Now the kinds of programs we've
been looking at so far

450
00:31:32,590 --> 00:31:34,730
are what are called straight
line programs.

451
00:31:43,740 --> 00:31:48,750
What distinguishes a straight
line program is it's a

452
00:31:48,750 --> 00:31:52,860
sequence of commands you execute
one after another.

453
00:31:52,860 --> 00:31:57,000
You execute every command
without making any deviations,

454
00:31:57,000 --> 00:32:00,340
without going back with any
loops to execute a command

455
00:32:00,340 --> 00:32:01,930
more than once.

456
00:32:01,930 --> 00:32:05,940
So in a straight line program,
every command gets executed

457
00:32:05,940 --> 00:32:07,235
exactly once.

458
00:32:10,430 --> 00:32:16,010
There is a very elegant, and
even useful theory that talks

459
00:32:16,010 --> 00:32:19,050
about different layers of,
levels of complexity of

460
00:32:19,050 --> 00:32:23,220
programs and says, for
example, what kind of

461
00:32:23,220 --> 00:32:27,380
functions can you compute with
straight line programs.

462
00:32:27,380 --> 00:32:30,290
We'll talk more about that
field, which is called

463
00:32:30,290 --> 00:32:34,240
complexity theory, later
in this semester.

464
00:32:34,240 --> 00:32:37,130
But for now, the thing to
realize is that straight line

465
00:32:37,130 --> 00:32:40,500
programs are just dead boring.

466
00:32:40,500 --> 00:32:45,010
You can't compute anything
interesting with one.

467
00:32:45,010 --> 00:32:47,240
Last time we talked about
a recipe as an

468
00:32:47,240 --> 00:32:50,700
analogy for a program.

469
00:32:50,700 --> 00:32:54,850
Imagine a recipe
with no tests.

470
00:32:54,850 --> 00:32:57,320
So every recipe, or almost
every recipe I

471
00:32:57,320 --> 00:33:00,700
know, has some decisions.

472
00:33:00,700 --> 00:33:03,240
Taste it and add salt
if you need it.

473
00:33:03,240 --> 00:33:06,640
Or poke at the meat and
see if it's done.

474
00:33:06,640 --> 00:33:08,770
Or cook it until the
thermometer says

475
00:33:08,770 --> 00:33:11,880
some degree on it.

476
00:33:11,880 --> 00:33:14,380
Those are the kinds of
tests we need to

477
00:33:14,380 --> 00:33:17,660
make interesting programs.

478
00:33:17,660 --> 00:33:22,630
The most primitive kind of test
we see is what's called a

479
00:33:22,630 --> 00:33:23,880
conditional statement.

480
00:33:31,940 --> 00:33:36,400
And those are written using the
word if, and optionally as

481
00:33:36,400 --> 00:33:44,800
we'll see, the words else or
elif, standing for else, if.

482
00:33:44,800 --> 00:33:46,770
So let's look at an
example here.

483
00:33:52,420 --> 00:33:54,030
Where'd my mouse,
oh there it is.

484
00:34:05,540 --> 00:34:06,790
Yes?

485
00:34:08,530 --> 00:34:09,850
Somebody has a question?

486
00:34:09,850 --> 00:34:11,600
Shout it out.

487
00:34:11,600 --> 00:34:11,989
AUDIENCE: Sorry.

488
00:34:11,989 --> 00:34:15,322
I was wondering, when the user's
prompted to put in the

489
00:34:15,322 --> 00:34:18,654
raw input, instead of putting
in a float, puts in string,

490
00:34:18,654 --> 00:34:21,462
could you define it as
a floating integer?

491
00:34:21,462 --> 00:34:23,040
How would you interpret
that input?

492
00:34:23,040 --> 00:34:25,270
PROFESSOR: I didn't
get the question.

493
00:34:25,270 --> 00:34:28,310
So this is an argument to
raw input, or their

494
00:34:28,310 --> 00:34:31,080
response to raw input.

495
00:34:31,080 --> 00:34:32,949
AUDIENCE: So yeah, for the
raw input where you

496
00:34:32,949 --> 00:34:34,280
define it as a quote--

497
00:34:34,280 --> 00:34:34,772
PROFESSOR: Yeah.

498
00:34:34,772 --> 00:34:36,248
AUDIENCE: It usually
puts in a string.

499
00:34:36,248 --> 00:34:38,710
How does Python interpret
that?

500
00:34:38,710 --> 00:34:40,600
PROFESSOR: It will interpret
it as a string containing

501
00:34:40,600 --> 00:34:42,606
quotation marks.

502
00:34:42,606 --> 00:34:43,020
AUDIENCE: OK.

503
00:34:43,020 --> 00:34:46,420
PROFESSOR: So typically you
don't type a string, because

504
00:34:46,420 --> 00:34:50,270
it interprets everything you
type as if it were a string.

505
00:34:50,270 --> 00:34:53,254
So don't bother typing
strings.

506
00:34:53,254 --> 00:34:54,179
Good question.

507
00:34:54,179 --> 00:34:57,045
Thank you.

508
00:34:57,045 --> 00:34:57,490
All right.

509
00:34:57,490 --> 00:34:58,740
So let's look at this.

510
00:35:03,670 --> 00:35:08,120
So here I'm going to get an
int, or at least a string.

511
00:35:08,120 --> 00:35:10,610
I'll convert it to an int.

512
00:35:10,610 --> 00:35:14,690
Then I'll say, if x remainder
two, that's what the percent

513
00:35:14,690 --> 00:35:17,980
sign is, it's a remainder
or a mod operator,

514
00:35:17,980 --> 00:35:21,100
is equal equal zero.

515
00:35:21,100 --> 00:35:22,460
That's important.

516
00:35:22,460 --> 00:35:29,100
You'll notice that we used an
equal sign to do assignments.

517
00:35:29,100 --> 00:35:33,580
If we want to do a comparison,
whether two objects have the

518
00:35:33,580 --> 00:35:36,710
same value, we don't write
a single equal.

519
00:35:36,710 --> 00:35:39,290
We write a double equal.

520
00:35:39,290 --> 00:35:42,930
So whenever you're testing for
equality of objects, you use

521
00:35:42,930 --> 00:35:45,590
double equal.

522
00:35:45,590 --> 00:35:51,040
So it says, if the object x mod
2 has the same value as

523
00:35:51,040 --> 00:35:55,520
the object zero, print even.

524
00:35:55,520 --> 00:35:58,700
Else, print odd.

525
00:35:58,700 --> 00:36:02,080
And then, just for fun, I'm
going to see whether or not

526
00:36:02,080 --> 00:36:04,150
it's divisible by three.

527
00:36:04,150 --> 00:36:06,010
Why did I do that?

528
00:36:06,010 --> 00:36:09,100
Just to show you that I can
nest conditionals inside

529
00:36:09,100 --> 00:36:11,190
conditionals.

530
00:36:11,190 --> 00:36:13,660
So in one of the branches of
the conditionals, I'm now

531
00:36:13,660 --> 00:36:16,090
doing a test.

532
00:36:16,090 --> 00:36:20,960
So what this does, is if comes
down, it does the test.

533
00:36:20,960 --> 00:36:27,250
If the value of the test is
true, it executes the block of

534
00:36:27,250 --> 00:36:33,090
code following the if, in
this case, just print.

535
00:36:33,090 --> 00:36:34,860
And then it skips the else.

536
00:36:34,860 --> 00:36:36,930
It does not execute the else.

537
00:36:36,930 --> 00:36:40,250
So it executes one
or the other.

538
00:36:40,250 --> 00:36:44,490
If the test is false, it skips
the block of code following

539
00:36:44,490 --> 00:36:49,870
the if and executes the block
of code following the else.

540
00:36:49,870 --> 00:36:53,441
So it does a or b,
but not both.

541
00:36:53,441 --> 00:36:57,280
The indentation is important.

542
00:36:57,280 --> 00:37:03,270
Python is very unusual in that
the way you indent things

543
00:37:03,270 --> 00:37:05,630
actually affects the
meaning of them.

544
00:37:09,460 --> 00:37:12,590
And you can tell that, if I
were to type this in the

545
00:37:12,590 --> 00:37:18,080
editor, you'll note here it's
on that line, but if I hit

546
00:37:18,080 --> 00:37:21,050
Return, it automatically
indents it.

547
00:37:21,050 --> 00:37:23,790
That's the auto indent feature
I mentioned earlier in the

548
00:37:23,790 --> 00:37:26,890
editor of IDLE.

549
00:37:26,890 --> 00:37:30,920
And this tells me how these
things line up.

550
00:37:30,920 --> 00:37:37,320
So the fact that this is here
tells me I execute it only as

551
00:37:37,320 --> 00:37:40,460
part of the else clause.

552
00:37:40,460 --> 00:37:43,580
The program would mean something
quite different if I

553
00:37:43,580 --> 00:37:44,830
wrote this.

554
00:37:48,520 --> 00:37:55,310
Then it would mean, if x mod
2 is zero, print even.

555
00:37:55,310 --> 00:37:57,340
Otherwise, print odd.

556
00:37:57,340 --> 00:38:00,370
And whether or not it was
even or odd, do this

557
00:38:00,370 --> 00:38:01,620
test in the if statement.

558
00:38:04,260 --> 00:38:08,440
So the indentation actually
affects the

559
00:38:08,440 --> 00:38:11,750
meaning of the program.

560
00:38:11,750 --> 00:38:15,120
Now a lot of other languages,
almost all other languages,

561
00:38:15,120 --> 00:38:16,500
don't do that.

562
00:38:16,500 --> 00:38:18,830
They have some punctuation.

563
00:38:18,830 --> 00:38:23,180
For example, c uses set braces
to designate what's called a

564
00:38:23,180 --> 00:38:24,430
block of code.

565
00:38:29,850 --> 00:38:34,720
If you look, however, at a
well-written piece of C code,

566
00:38:34,720 --> 00:38:38,820
or Java code, or any other
language that I know,

567
00:38:38,820 --> 00:38:43,440
programmers are trained to use
indentation to show the

568
00:38:43,440 --> 00:38:45,770
structure of the program.

569
00:38:45,770 --> 00:38:48,300
Even though you don't need, it
you could line up everything

570
00:38:48,300 --> 00:38:53,330
right at the left edge and
just use the punctuation.

571
00:38:53,330 --> 00:38:54,570
People don't do that.

572
00:38:54,570 --> 00:38:59,880
And the reason they don't do
that is programs are intended

573
00:38:59,880 --> 00:39:11,470
to be read, not just executed.

574
00:39:11,470 --> 00:39:14,630
Why are they intended
to be read?

575
00:39:14,630 --> 00:39:17,890
Because the only reason, the
only way you can debug a

576
00:39:17,890 --> 00:39:19,920
program is reading
the code in it.

577
00:39:23,920 --> 00:39:26,900
Typically, you want to write
your program so that if you

578
00:39:26,900 --> 00:39:31,220
look at it from a distance, the
visual structure of the

579
00:39:31,220 --> 00:39:35,710
program reflects the semantics
of the program.

580
00:39:35,710 --> 00:39:38,340
And that's why people use
indentation when they don't

581
00:39:38,340 --> 00:39:42,010
need to, so that you can see the
structure of the program

582
00:39:42,010 --> 00:39:46,850
by looking at it on your screen
and not having to parse

583
00:39:46,850 --> 00:39:49,790
each symbol.

584
00:39:49,790 --> 00:39:52,760
The authors of Python made what
I think is a very good

585
00:39:52,760 --> 00:39:54,260
design decision.

586
00:39:54,260 --> 00:39:56,680
They said, well, if that's the
way you ought to write your

587
00:39:56,680 --> 00:40:00,310
programs, let's force people to
write their programs that

588
00:40:00,310 --> 00:40:06,400
way and guarantee that the
visual structure of the

589
00:40:06,400 --> 00:40:10,970
program actually matches
the semantic structure.

590
00:40:10,970 --> 00:40:15,310
The problem with languages like
C and Java is that you

591
00:40:15,310 --> 00:40:19,970
can indent things and fool the
reader of the program by

592
00:40:19,970 --> 00:40:24,180
making it look like something is
under something else, when

593
00:40:24,180 --> 00:40:28,650
in fact it really isn't, because
of the punctuation.

594
00:40:28,650 --> 00:40:31,790
So here we have a guarantee
that the visual structure

595
00:40:31,790 --> 00:40:35,020
matches the semantic structure,
and I think that

596
00:40:35,020 --> 00:40:40,690
was one of the really good
design decisions in Python.

597
00:40:40,690 --> 00:40:43,630
OK, people see that?

598
00:40:43,630 --> 00:40:46,180
So we could execute
this program.

599
00:40:46,180 --> 00:40:50,780
Let me get back to what
it was before.

600
00:40:50,780 --> 00:40:53,080
Control z is the go back.

601
00:40:56,660 --> 00:41:00,900
And now we can enter an integer,
say 14, and it will

602
00:41:00,900 --> 00:41:04,150
tell us it's even.

603
00:41:04,150 --> 00:41:10,810
I can run it again, and now I'll
put 15 in, and it will

604
00:41:10,810 --> 00:41:14,140
tell me it's odd.

605
00:41:14,140 --> 00:41:17,770
We'll try it once more.

606
00:41:17,770 --> 00:41:20,290
We'll put in 17.

607
00:41:20,290 --> 00:41:25,160
It was odd and it's not
divisible by three.

608
00:41:25,160 --> 00:41:29,445
These kinds of programs are
called branching programs.

609
00:41:41,220 --> 00:41:43,380
And that's because the structure
of them, as you go

610
00:41:43,380 --> 00:41:46,690
down you execute some
statements, and then there's a

611
00:41:46,690 --> 00:41:51,200
branch which says execute these
statements or execute

612
00:41:51,200 --> 00:41:53,530
those statements.

613
00:41:53,530 --> 00:42:00,530
And then typically it comes back
together and continues.

614
00:42:00,530 --> 00:42:03,620
Of course, branches can
have sub-branches.

615
00:42:03,620 --> 00:42:09,460
We could do this and then
join further down,

616
00:42:09,460 --> 00:42:10,710
as we've seen here.

617
00:42:13,040 --> 00:42:16,820
Now branching programs are much
more interesting than

618
00:42:16,820 --> 00:42:19,090
straight line programs.

619
00:42:19,090 --> 00:42:24,450
We can do a lot of things with
them, but fundamentally

620
00:42:24,450 --> 00:42:28,130
nothing really interesting.

621
00:42:28,130 --> 00:42:33,190
And we can think about that by
thinking about how long it

622
00:42:33,190 --> 00:42:36,820
takes a branching
program to run.

623
00:42:36,820 --> 00:42:39,650
So let's first ask the question,
how long does it

624
00:42:39,650 --> 00:42:43,310
take a straight line
program to run?

625
00:42:43,310 --> 00:42:44,780
14 seconds?

626
00:42:44,780 --> 00:42:47,580
No, that's not the way
to think about it.

627
00:42:47,580 --> 00:42:50,260
How would we think about how
long it takes it to run?

628
00:42:50,260 --> 00:42:53,250
What governs the length
of time a straight

629
00:42:53,250 --> 00:42:56,135
line program can take?

630
00:42:56,135 --> 00:42:57,530
AUDIENCE: [INAUDIBLE].

631
00:42:57,530 --> 00:42:58,630
PROFESSOR: Exactly.

632
00:42:58,630 --> 00:43:02,610
The number of statements or
commands in the program.

633
00:43:02,610 --> 00:43:07,110
Since it executes every command
exactly once, if you

634
00:43:07,110 --> 00:43:11,350
have 100 command, it will
have 100 steps in it.

635
00:43:11,350 --> 00:43:14,190
Now there's some variation on
how long each step will be.

636
00:43:14,190 --> 00:43:18,400
Some commands might take longer
than others, but the

637
00:43:18,400 --> 00:43:21,320
length of time it can take
to run has nothing

638
00:43:21,320 --> 00:43:23,340
to do with its input.

639
00:43:23,340 --> 00:43:28,930
It has to do only with the
number of lines of code.

640
00:43:28,930 --> 00:43:34,230
And that tells us it's not very
useful because, well, we

641
00:43:34,230 --> 00:43:37,640
can only type so many lines
in our lifetime.

642
00:43:37,640 --> 00:43:40,180
Well branching programs
have the same problem.

643
00:43:42,890 --> 00:43:45,200
In a branching program,
each command is

644
00:43:45,200 --> 00:43:49,290
executed at most once.

645
00:43:49,290 --> 00:43:53,170
So again, the length of time
it takes to execute the

646
00:43:53,170 --> 00:43:59,820
program is governed strictly
by the size of the program.

647
00:43:59,820 --> 00:44:02,050
Why isn't that good enough?

648
00:44:02,050 --> 00:44:07,330
Well, think about a program,
say, to compute the GPA of all

649
00:44:07,330 --> 00:44:08,580
the students at MIT.

650
00:44:11,460 --> 00:44:13,590
Well how long is that
going to take?

651
00:44:16,720 --> 00:44:21,630
Think instead about a program to
compute the GPA of all the

652
00:44:21,630 --> 00:44:26,620
students at the University of
Michigan, which is probably 10

653
00:44:26,620 --> 00:44:28,730
times bigger than MIT.

654
00:44:28,730 --> 00:44:31,420
Well you would expect that
to take longer, right?

655
00:44:31,420 --> 00:44:35,270
Because you have to look
at more students.

656
00:44:35,270 --> 00:44:37,160
And in fact, it's true.

657
00:44:37,160 --> 00:44:40,390
Most programs that are
interesting, the amount of

658
00:44:40,390 --> 00:44:43,800
time they take to run should
depend not on the length of

659
00:44:43,800 --> 00:44:48,130
the program, but on the size of
the data that you want to

660
00:44:48,130 --> 00:44:51,190
evaluate using the program.

661
00:44:51,190 --> 00:44:54,500
So you would argue that the
amount of time taken to

662
00:44:54,500 --> 00:44:58,330
compute the GPA of the students
at MIT should be

663
00:44:58,330 --> 00:45:02,260
proportional to the number of
students, not proportional to

664
00:45:02,260 --> 00:45:05,890
the length of the program
used to do it.

665
00:45:05,890 --> 00:45:08,780
We'll talk a lot more about that
later in the term in a

666
00:45:08,780 --> 00:45:12,180
much more thorough way.

667
00:45:12,180 --> 00:45:18,110
But it's important to get that
as something you think about.

668
00:45:18,110 --> 00:45:21,820
So the fact that branching
programs are not proportional

669
00:45:21,820 --> 00:45:25,390
in time to the input means that
they're limited in what

670
00:45:25,390 --> 00:45:28,000
they can do.

671
00:45:28,000 --> 00:45:33,150
So that gets us to the final
concept we need to write every

672
00:45:33,150 --> 00:45:36,350
program that could ever be
written, or at least to

673
00:45:36,350 --> 00:45:41,650
compute every function that
could ever be computed.

674
00:45:41,650 --> 00:45:44,210
And that's some sort of
a looping construct.

675
00:45:56,600 --> 00:46:02,150
Once we add loops, we get to a
class of programming languages

676
00:46:02,150 --> 00:46:07,390
or programming constructs that's
called Turing Complete.

677
00:46:07,390 --> 00:46:10,650
And I mentioned this
last time.

678
00:46:10,650 --> 00:46:13,150
Any program that can be written,
or any function that

679
00:46:13,150 --> 00:46:17,140
can be computed, rather, can
be computed in a Turing

680
00:46:17,140 --> 00:46:20,100
Complete language.

681
00:46:20,100 --> 00:46:21,835
So let's look at an
example here.

682
00:46:24,410 --> 00:46:27,513
This concept, by the way,
is called iteration.

683
00:46:33,620 --> 00:46:40,850
And if we look at languages with
iteration, what we'll see

684
00:46:40,850 --> 00:46:44,130
is a more complicated
flow of control.

685
00:46:44,130 --> 00:46:47,280
You execute some statements,
maybe you do some

686
00:46:47,280 --> 00:46:48,530
branching if you want.

687
00:46:53,520 --> 00:46:59,480
But then you're allowed to go
back and execute statements

688
00:46:59,480 --> 00:47:02,060
you've already executed.

689
00:47:02,060 --> 00:47:04,045
Typically what you have
is another branch.

690
00:47:09,450 --> 00:47:11,480
One branch goes back
and one continues.

691
00:47:15,200 --> 00:47:20,570
So now we see we can execute
a statement more than once.

692
00:47:20,570 --> 00:47:25,820
Suddenly we have enormous
power at our disposal.

693
00:47:25,820 --> 00:47:27,660
So let's look at an
example of that.

694
00:47:43,640 --> 00:47:46,500
By the way, I'm skipping some
of the code in your handout,

695
00:47:46,500 --> 00:47:53,530
but that's probably fine because
it's there for you to

696
00:47:53,530 --> 00:47:54,370
be able to read.

697
00:47:54,370 --> 00:47:58,290
And what I would recommend by
the way, is that we will post

698
00:47:58,290 --> 00:48:02,880
the handouts on the web, but
at the end of every lecture

699
00:48:02,880 --> 00:48:06,560
within a few hours or a few days
at least, go through the

700
00:48:06,560 --> 00:48:11,150
handouts and make sure you
understand everything in.

701
00:48:11,150 --> 00:48:14,380
Because if you don't, you're
probably missing something

702
00:48:14,380 --> 00:48:16,350
you'll need to understand
to do the problem sets.

703
00:48:19,250 --> 00:48:22,860
So here's a little program that
finds the cube root of a

704
00:48:22,860 --> 00:48:25,200
perfect cube.

705
00:48:25,200 --> 00:48:28,280
This, by the way, is a useful
comment here, right?

706
00:48:28,280 --> 00:48:31,770
Tells you what the program
is intended to do.

707
00:48:31,770 --> 00:48:33,770
So we get an integer.

708
00:48:33,770 --> 00:48:36,830
We set the variable
ans to zero.

709
00:48:36,830 --> 00:48:41,820
And then while ans times ans
times ans is less than the

710
00:48:41,820 --> 00:48:45,810
absolute value of x,
we're going to set

711
00:48:45,810 --> 00:48:48,230
ans to ans plus 1.

712
00:48:48,230 --> 00:48:50,360
We could print where we are.

713
00:48:50,360 --> 00:48:54,180
I put those sort of things in
as debugging statements.

714
00:48:54,180 --> 00:48:59,570
If ans times ans times ans is
not equal to the absolute

715
00:48:59,570 --> 00:49:06,800
value of x when I finish the
loop, then I'll print x is not

716
00:49:06,800 --> 00:49:09,850
a perfect cube.

717
00:49:09,850 --> 00:49:12,050
Otherwise I have to do something
to deal with

718
00:49:12,050 --> 00:49:14,780
positive and negative values.

719
00:49:14,780 --> 00:49:20,620
Now I know that this was fast
and that most of you probably

720
00:49:20,620 --> 00:49:23,490
don't fully assimilate
this program.

721
00:49:23,490 --> 00:49:25,290
Do not worry.

722
00:49:25,290 --> 00:49:30,040
It will be discussed in
recitations tomorrow.

723
00:49:30,040 --> 00:49:34,010
So tomorrow, the recitations
will review the Python

724
00:49:34,010 --> 00:49:38,870
concepts we've discussed today,
but we'll start by

725
00:49:38,870 --> 00:49:41,570
emphasizing how these
loops work.

726
00:49:41,570 --> 00:49:42,320
OK.

727
00:49:42,320 --> 00:49:44,020
Thanks for coming.

728
00:49:44,020 --> 00:49:45,360
Enjoy recitation tomorrow.