1
00:00:00,530 --> 00:00:02,960
The following content is
provided under a Creative

2
00:00:02,960 --> 00:00:04,370
Commons license.

3
00:00:04,370 --> 00:00:07,410
Your support will help MIT
OpenCourseWare continue to

4
00:00:07,410 --> 00:00:11,060
offer high-quality educational
resources for free.

5
00:00:11,060 --> 00:00:13,960
To make a donation or view
additional materials from

6
00:00:13,960 --> 00:00:17,890
hundreds of MIT courses, visit
MIT OpenCourseWare at

7
00:00:17,890 --> 00:00:19,140
ocw.mit.edu.

8
00:00:23,490 --> 00:00:25,110
PROFESSOR: By way of review,
we're going to

9
00:00:25,110 --> 00:00:27,970
start off with loops.

10
00:00:27,970 --> 00:00:31,990
So, what are two loops that
we've covered in lecture or

11
00:00:31,990 --> 00:00:33,808
two types of loops?

12
00:00:33,808 --> 00:00:35,140
AUDIENCE: FOR and WHILE.

13
00:00:37,930 --> 00:00:38,430
PROFESSOR: OK.

14
00:00:38,430 --> 00:00:38,840
Yeah.

15
00:00:38,840 --> 00:00:39,760
FOR and WHILE.

16
00:00:39,760 --> 00:00:41,690
I'm going to start with WHILE
loops because that's what I

17
00:00:41,690 --> 00:00:42,940
have first.

18
00:00:44,770 --> 00:00:47,020
Can someone walk me through the
syntax of a WHILE loop?

19
00:00:52,700 --> 00:00:54,680
AUDIENCE: WHILE condition.

20
00:00:54,680 --> 00:00:57,540
PROFESSOR: WHILE condition and
what type is this condition?

21
00:00:57,540 --> 00:00:59,160
AUDIENCE: [INAUDIBLE]

22
00:00:59,160 --> 00:00:59,550
PROFESSOR: OK.

23
00:00:59,550 --> 00:01:01,710
And then I have--

24
00:01:01,710 --> 00:01:02,800
AUDIENCE: [INAUDIBLE]

25
00:01:02,800 --> 00:01:08,990
PROFESSOR: And then a block
of code, indicated by

26
00:01:08,990 --> 00:01:10,290
indentation.

27
00:01:10,290 --> 00:01:11,800
OK.

28
00:01:11,800 --> 00:01:15,347
Next question is, what
does this code do?

29
00:01:22,652 --> 00:01:25,590
AUDIENCE:Executes the loop and
returns Boolean values.

30
00:01:25,590 --> 00:01:25,870
PROFESSOR: Right.

31
00:01:25,870 --> 00:01:29,490
That's a little bit
too high level.

32
00:01:29,490 --> 00:01:31,902
Specifically, what does
this loop do?

33
00:01:31,902 --> 00:01:34,663
AUDIENCE: Prints the even
numbers from 2 to 10.

34
00:01:34,663 --> 00:01:35,913
PROFESSOR: Perfect.

35
00:01:44,570 --> 00:01:46,860
That's exactly the kind of
comment we're looking for.

36
00:01:46,860 --> 00:01:49,120
When you're doing your problem
sets or you're just coding in

37
00:01:49,120 --> 00:01:53,560
general, you want to have a
comment that describes in an

38
00:01:53,560 --> 00:01:56,250
abstract way what's going on
in the chunks of code.

39
00:01:56,250 --> 00:02:00,610
You don't want to have
a comment that says

40
00:02:00,610 --> 00:02:05,100
assigns 2 to a.

41
00:02:05,100 --> 00:02:09,340
Continues looping
until a is 10.

42
00:02:09,340 --> 00:02:11,100
Comments like that aren't really
helpful because you can

43
00:02:11,100 --> 00:02:13,040
get that by reading the code.

44
00:02:13,040 --> 00:02:15,080
So that's exactly right.

45
00:02:15,080 --> 00:02:15,860
It's perfect.

46
00:02:15,860 --> 00:02:19,980
I don't have candy to
pass out, though.

47
00:02:19,980 --> 00:02:21,695
Next question is what's the
decrementing function?

48
00:02:27,050 --> 00:02:29,080
The way to think of a
decrementing function is that

49
00:02:29,080 --> 00:02:33,400
it's a statement that moves
the loop closer to

50
00:02:33,400 --> 00:02:35,460
termination.

51
00:02:35,460 --> 00:02:36,640
In this case--

52
00:02:36,640 --> 00:02:37,890
AUDIENCE: 10 minus a.

53
00:02:41,800 --> 00:02:46,030
PROFESSOR: Yeah, 10 minus
a or a plus equal 2.

54
00:02:46,030 --> 00:02:47,985
As we're incrementing a, we're
getting closer and closer to

55
00:02:47,985 --> 00:02:50,038
10 and that's going to cause
us to kick out of the loop.

56
00:02:58,420 --> 00:02:59,980
Next thing.

57
00:02:59,980 --> 00:03:01,290
Is a a good variable name?

58
00:03:06,410 --> 00:03:10,510
The answer is no, otherwise,
I wouldn't have asked it.

59
00:03:10,510 --> 00:03:13,030
But a better variable name
might be even_number.

60
00:03:16,000 --> 00:03:20,140
Because, instead of just a being
an integer, now we know

61
00:03:20,140 --> 00:03:21,720
what it's supposed to represent
in the code.

62
00:03:24,550 --> 00:03:31,230
And it becomes clearer when we
go to execute it or run it.

63
00:03:37,180 --> 00:03:40,970
For loops, same thing.

64
00:03:40,970 --> 00:03:43,970
Could someone walk me through
the syntax for a FOR loop?

65
00:03:48,480 --> 00:03:51,930
And first question, does this
loop do the same thing as a

66
00:03:51,930 --> 00:03:53,180
WHILE loop?

67
00:03:59,010 --> 00:04:01,250
If this is our WHILE
loop, does this

68
00:04:01,250 --> 00:04:02,500
loop do the same thing?

69
00:04:05,758 --> 00:04:07,174
AUDIENCE: Yes.

70
00:04:07,174 --> 00:04:07,646
PROFESSOR: OK.

71
00:04:07,646 --> 00:04:08,850
Let's see.

72
00:04:08,850 --> 00:04:15,060
The WHILE loop printed out 4,
6,8,10 and 12; this is going

73
00:04:15,060 --> 00:04:19,820
to print out, 8 and 10.

74
00:04:19,820 --> 00:04:23,790
The reason is where we have
the increment, right?

75
00:04:23,790 --> 00:04:39,470
If we had done this, they would
print out both the same.

76
00:04:39,470 --> 00:04:40,900
A little aside.

77
00:04:40,900 --> 00:04:42,150
That was a bug I just caught.

78
00:04:44,900 --> 00:04:46,350
Someone walk me through the
syntax for a FOR loop.

79
00:04:53,028 --> 00:04:54,278
AUDIENCE: [INAUDIBLE]

80
00:04:57,130 --> 00:05:02,030
PROFESSOR: A FOR keyword and
then what do we have here?

81
00:05:02,030 --> 00:05:04,690
A variable of some sort.

82
00:05:04,690 --> 00:05:11,250
Then we have in keyword and then
we have this thing here.

83
00:05:11,250 --> 00:05:13,780
We're going to get to tuples
in a second, but this is a

84
00:05:13,780 --> 00:05:16,420
tuple literal.

85
00:05:16,420 --> 00:05:19,270
And for FOR loops, a FOR loop
requires something that is

86
00:05:19,270 --> 00:05:23,530
enumerable, which means that we
can take one element after

87
00:05:23,530 --> 00:05:26,350
the other and assign it
to the variable i.

88
00:05:30,030 --> 00:05:37,450
FOR loops iterate over
enumerable items.

89
00:05:37,450 --> 00:05:39,740
Thank you.

90
00:05:39,740 --> 00:05:40,950
That's exactly what I
was talking about.

91
00:05:40,950 --> 00:05:43,690
If I'm speaking too low, just
jack your thumbs up.

92
00:05:47,200 --> 00:05:50,310
This construction is
inconvenient though.

93
00:05:50,310 --> 00:05:53,520
If we wanted to list all
the numbers that

94
00:05:53,520 --> 00:05:54,630
we wanted to print--

95
00:05:54,630 --> 00:05:56,180
2 to 10 is not too hard.

96
00:05:56,180 --> 00:05:57,430
But let's say we wanted
all the even numbers

97
00:05:57,430 --> 00:05:59,910
between 2 and 100.

98
00:05:59,910 --> 00:06:04,360
I don't want to have to write
out all 50 of those.

99
00:06:04,360 --> 00:06:08,750
So we get to the
range function.

100
00:06:08,750 --> 00:06:09,770
You've seen this before.

101
00:06:09,770 --> 00:06:11,020
We just haven't ever
explained it.

102
00:06:13,450 --> 00:06:17,140
All the range function does is
it takes between one and three

103
00:06:17,140 --> 00:06:22,090
parameters and returns
a list of integers.

104
00:06:22,090 --> 00:06:25,580
So let's say that I pass
it one parameter.

105
00:06:25,580 --> 00:06:27,960
I'm going to give it
the integer 100.

106
00:06:27,960 --> 00:06:31,330
This is going to give
me nothing because I

107
00:06:31,330 --> 00:06:32,580
didn't print it out.

108
00:06:37,020 --> 00:06:42,255
This is going to give
me integers 0 to 99.

109
00:06:48,710 --> 00:06:51,110
If I give it two parameters,
what it's going

110
00:06:51,110 --> 00:06:52,410
to do is give me?

111
00:06:52,410 --> 00:07:00,400
The integers between
1 and 100.

112
00:07:00,400 --> 00:07:02,770
In this case, it starts off
at 1 and it gets to 99.

113
00:07:06,050 --> 00:07:08,120
One important point is that
when you give it two

114
00:07:08,120 --> 00:07:12,570
parameters, the first one is
inclusive and the second

115
00:07:12,570 --> 00:07:13,820
parameter is exclusive.

116
00:07:17,290 --> 00:07:18,640
Does everyone follow that?

117
00:07:21,580 --> 00:07:26,670
Finally, the third form is
with three parameters.

118
00:07:26,670 --> 00:07:32,070
I have a start, an end, start
inclusive, end exclusive, and

119
00:07:32,070 --> 00:07:34,400
then a step.

120
00:07:34,400 --> 00:07:46,030
This will give me all the odd
numbers between 1 and 100.

121
00:07:46,030 --> 00:07:49,530
We can also go in reverse.

122
00:07:49,530 --> 00:07:57,120
If I want to go count down from
100 to 1, I can give it a

123
00:07:57,120 --> 00:07:58,370
negative step.

124
00:08:02,570 --> 00:08:06,040
If you want help on using the
range function, there's a

125
00:08:06,040 --> 00:08:08,860
handy command called help,
which you can type in the

126
00:08:08,860 --> 00:08:10,110
interactive prompt.

127
00:08:14,940 --> 00:08:18,420
This gives you the syntax
for using range.

128
00:08:18,420 --> 00:08:21,680
You can do this for any
function in Python.

129
00:08:21,680 --> 00:08:25,590
It's going to tell you,
here's the name.

130
00:08:25,590 --> 00:08:27,010
Here's a parameter start.

131
00:08:27,010 --> 00:08:28,350
Here's a parameter stop.

132
00:08:28,350 --> 00:08:30,650
Here's a parameter step.

133
00:08:30,650 --> 00:08:33,940
This little arrow here means
this is what it returns, a

134
00:08:33,940 --> 00:08:35,190
list of integers.

135
00:08:37,600 --> 00:08:41,005
When you type help and you see
one of these square brackets

136
00:08:41,005 --> 00:08:43,499
that means the perimeter
is optional.

137
00:08:46,560 --> 00:08:47,680
A start is optional.

138
00:08:47,680 --> 00:08:49,390
Step is optional.

139
00:08:49,390 --> 00:08:51,880
Stop, we always have a stop.

140
00:08:51,880 --> 00:08:54,580
We always know when we're
stopping a range.

141
00:08:54,580 --> 00:08:58,815
That's why we can pass one,
two, or three parameters.

142
00:08:58,815 --> 00:09:02,010
Is anyone confused on that?

143
00:09:02,010 --> 00:09:05,370
AUDIENCE: If you only put stop,
it will start with 0?

144
00:09:05,370 --> 00:09:05,950
PROFESSOR: Right.

145
00:09:05,950 --> 00:09:10,150
If you only put one parameter,
then it will start from 0.

146
00:09:10,150 --> 00:09:11,870
So the start is implicit.

147
00:09:14,500 --> 00:09:15,750
Are we good on this?

148
00:09:28,100 --> 00:09:34,860
So, we can code our FOR loop
like that, which for five

149
00:09:34,860 --> 00:09:37,540
numbers is not too inconvenient,
or is

150
00:09:37,540 --> 00:09:38,150
convenient.

151
00:09:38,150 --> 00:09:43,440
But if we have 500 numbers, it
makes it a lot easier to just

152
00:09:43,440 --> 00:09:47,600
change one end point than
it is to type in

153
00:09:47,600 --> 00:09:48,850
500 numbers, right?

154
00:09:51,682 --> 00:09:52,932
OK.

155
00:10:00,628 --> 00:10:02,616
AUDIENCE: Can you create
a range for floats?

156
00:10:02,616 --> 00:10:06,095
So let's say you want to
do it by float size?

157
00:10:06,095 --> 00:10:07,160
PROFESSOR: That's
a good question.

158
00:10:07,160 --> 00:10:08,560
We should try it.

159
00:10:08,560 --> 00:10:09,986
Why don't we give it a shot?

160
00:10:15,160 --> 00:10:16,970
The question was can we make
a range of floats?

161
00:10:19,880 --> 00:10:28,200
Let's try 1.02 to 10.0.

162
00:10:28,200 --> 00:10:30,240
It'll give us an
answer, right?

163
00:10:30,240 --> 00:10:32,525
But it also gives
us a warning.

164
00:10:32,525 --> 00:10:36,150
It says that an integer
argument is expected.

165
00:10:36,150 --> 00:10:38,837
Let's say I do this.

166
00:10:42,250 --> 00:10:45,070
Will this work?

167
00:10:45,070 --> 00:10:46,370
What's it's going to
do is it's going to

168
00:10:46,370 --> 00:10:48,550
truncate the floats.

169
00:10:48,550 --> 00:10:51,150
It's going to truncate the start
to 1 and it's going to

170
00:10:51,150 --> 00:10:53,290
truncate the end to 10.

171
00:10:53,290 --> 00:10:57,000
Then it'll just return the
integers as required.

172
00:10:57,000 --> 00:10:59,760
So you can, but it doesn't
work the way

173
00:10:59,760 --> 00:11:01,010
you think it would.

174
00:11:05,970 --> 00:11:12,330
Moving on, you hit tuples
in lecture this week.

175
00:11:12,330 --> 00:11:18,080
So we're done with the
old review stuff.

176
00:11:18,080 --> 00:11:19,970
Can anyone tell me
what a tuple is?

177
00:11:27,800 --> 00:11:35,893
It's a non-scalar data type
that can hold many items.

178
00:11:38,940 --> 00:11:40,300
What does non-scalar mean?

179
00:11:45,260 --> 00:11:48,648
AUDIENCE: It's multiple elements
that you can search

180
00:11:48,648 --> 00:11:50,420
individually.

181
00:11:50,420 --> 00:11:51,590
AUDIENCE: It's a field that
you can hold only

182
00:11:51,590 --> 00:11:54,600
one value at a time.

183
00:11:54,600 --> 00:11:55,400
PROFESSOR: You're both right.

184
00:11:55,400 --> 00:11:58,130
A scalar can hold only one
element at a time.

185
00:11:58,130 --> 00:12:02,750
A non-scalar can hold more than
one element at a time.

186
00:12:02,750 --> 00:12:04,910
Tuples are actually the
second scalar data

187
00:12:04,910 --> 00:12:07,080
type that we've seen.

188
00:12:07,080 --> 00:12:08,350
A string is the first.

189
00:12:08,350 --> 00:12:10,255
A string can have multiple
characters.

190
00:12:13,250 --> 00:12:13,990
Tuples are flexible.

191
00:12:13,990 --> 00:12:15,240
We can have tuples of numbers.

192
00:12:18,130 --> 00:12:23,350
This syntax, the parentheses
with a set of elements

193
00:12:23,350 --> 00:12:26,200
separated by commas,
this is the literal

194
00:12:26,200 --> 00:12:29,390
syntax for a tuple.

195
00:12:29,390 --> 00:12:32,280
All we're saying is that my
tuple of numbers has the

196
00:12:32,280 --> 00:12:36,750
approximation of
pi, 2, 1, -100.

197
00:12:36,750 --> 00:12:39,230
We can have tuples of strings.

198
00:12:39,230 --> 00:12:42,600
We can have tuples of anything,
but you'll get to

199
00:12:42,600 --> 00:12:43,850
that in a second.

200
00:12:47,108 --> 00:12:50,590
AUDIENCE: Can you mix the data
types inside of that?

201
00:12:50,590 --> 00:12:52,050
PROFESSOR: Yes, we're going
to get to that.

202
00:12:55,390 --> 00:12:57,230
The question was, can
you mix data types?

203
00:12:57,230 --> 00:12:58,100
The answer is yes.

204
00:12:58,100 --> 00:13:02,140
We'll get to that in a second.

205
00:13:02,140 --> 00:13:05,870
To access individual elements
of a tuple, we do something

206
00:13:05,870 --> 00:13:07,670
called indexing.

207
00:13:07,670 --> 00:13:10,030
We specify an index by--

208
00:13:10,030 --> 00:13:14,350
if I have tuple_of_numbers, my
variable name, I have a left

209
00:13:14,350 --> 00:13:17,290
square bracket and a right
square bracket, and I have an

210
00:13:17,290 --> 00:13:20,440
integer in between.

211
00:13:20,440 --> 00:13:24,710
This would give me the item
in the tuple that

212
00:13:24,710 --> 00:13:27,490
exists at index 0.

213
00:13:27,490 --> 00:13:35,520
Tuples are indexed starting at
0 and in increments of 1.

214
00:13:35,520 --> 00:13:37,410
When I say tuple_of_numbers[0],
what

215
00:13:37,410 --> 00:13:40,590
should this print out?

216
00:13:40,590 --> 00:13:41,940
AUDIENCE: 3.14159.

217
00:13:41,940 --> 00:13:42,700
PROFESSOR: Right.

218
00:13:42,700 --> 00:13:45,900
It will print out 3.14159.

219
00:13:45,900 --> 00:13:49,292
Now if I change this to 1,
what will this print out?

220
00:13:49,292 --> 00:13:51,140
AUDIENCE: 2.

221
00:13:51,140 --> 00:13:53,320
PROFESSOR: Exactly.

222
00:13:53,320 --> 00:13:59,120
It doesn't matter what data type
is contained in tuple.

223
00:13:59,120 --> 00:14:04,340
If it's string, it'll just print
out whatever's here,

224
00:14:04,340 --> 00:14:07,510
which is 'what'.

225
00:14:07,510 --> 00:14:11,260
You can also use negative
indices.

226
00:14:11,260 --> 00:14:15,560
Negative indices tell Python
that I want to go to one past

227
00:14:15,560 --> 00:14:18,360
the end of the tuple.

228
00:14:18,360 --> 00:14:21,040
In this case, tuple_of_
strings, I'm out here

229
00:14:21,040 --> 00:14:24,260
somewhere, and then walk
back 1, or however

230
00:14:24,260 --> 00:14:26,700
many the integer is.

231
00:14:26,700 --> 00:14:28,840
I have here tuple_of_strings
minus 1.

232
00:14:28,840 --> 00:14:32,480
Python's going to go to
somewhere around here and then

233
00:14:32,480 --> 00:14:35,820
walk back one and
give me 'name'.

234
00:14:40,890 --> 00:14:44,090
Now what if I do minus 3?

235
00:14:46,910 --> 00:14:49,440
What's that going
to print out?

236
00:14:49,440 --> 00:14:50,690
Is.

237
00:14:57,220 --> 00:14:59,210
Let's see who is paying
attention.

238
00:14:59,210 --> 00:15:02,190
What's this going to do?

239
00:15:02,190 --> 00:15:03,440
AUDIENCE: [INAUDIBLE]

240
00:15:05,690 --> 00:15:09,490
AUDIENCE: My name,
or name, rather?

241
00:15:09,490 --> 00:15:13,002
PROFESSOR: Remember we index
tuples at 0, right?

242
00:15:13,002 --> 00:15:14,250
AUDIENCE: That's going
to give an error.

243
00:15:14,250 --> 00:15:15,460
PROFESSOR: Exactly.

244
00:15:15,460 --> 00:15:19,210
It's going to tell us
index out of range.

245
00:15:19,210 --> 00:15:24,210
We have four elements in
tuple strings 0, 1, 2,

246
00:15:24,210 --> 00:15:27,070
3, oops, we're off.

247
00:15:29,600 --> 00:15:32,040
You can get outside of a
tuple and get an error.

248
00:15:34,660 --> 00:15:36,526
To avoid that--

249
00:15:36,526 --> 00:15:37,024
sorry?

250
00:15:37,024 --> 00:15:39,020
AUDIENCE: The thing is when you
said for tuple_of_numbers,

251
00:15:39,020 --> 00:15:44,970
you said 1 and 3.141, number,
which would technically be 0

252
00:15:44,970 --> 00:15:46,225
in this case, wouldn't it?

253
00:15:46,225 --> 00:15:47,120
PROFESSOR: No, I switched it.

254
00:15:47,120 --> 00:15:47,860
AUDIENCE: You switched it.

255
00:15:47,860 --> 00:15:49,110
PROFESSOR: Yeah.

256
00:15:51,190 --> 00:15:54,030
Just to make you feel better--

257
00:15:54,030 --> 00:15:54,762
AUDIENCE: I see it now.

258
00:15:54,762 --> 00:15:56,080
PROFESSOR: You got it?

259
00:15:56,080 --> 00:15:57,330
OK.

260
00:16:01,610 --> 00:16:03,230
It's always possible that
I made an error.

261
00:16:07,280 --> 00:16:09,080
In your code, in order to avoid
that, you can check

262
00:16:09,080 --> 00:16:12,170
yourself by getting the length
of tuple_of_numbers.

263
00:16:12,170 --> 00:16:13,470
So there's a function len.

264
00:16:17,540 --> 00:16:18,630
It's going to tell us that

265
00:16:18,630 --> 00:16:20,250
tuple_of_numbers has 6 elements.

266
00:16:20,250 --> 00:16:24,800
We can count them:
1, 2, 3, 4, 5, 6.

267
00:16:24,800 --> 00:16:30,110
What's the last index
of this tuple?

268
00:16:30,110 --> 00:16:31,360
5, right?

269
00:16:36,500 --> 00:16:40,350
Back to your question, tuples
can hold different data types.

270
00:16:49,290 --> 00:16:52,595
They can hold data types that
are different from each other.

271
00:16:52,595 --> 00:16:56,390
I'm wording that improperly.

272
00:16:56,390 --> 00:16:59,280
So, here we have a float
and three strings.

273
00:16:59,280 --> 00:17:02,750
This is a heterogeneous
data structure.

274
00:17:02,750 --> 00:17:04,770
A homogeneous data structure
would be one that you would

275
00:17:04,770 --> 00:17:09,069
say only hold ints only
holds floats.

276
00:17:09,069 --> 00:17:10,810
But tuples are very flexible.

277
00:17:10,810 --> 00:17:13,339
So, we have a float here
and some strings.

278
00:17:13,339 --> 00:17:15,369
Then you could also
have tuples that

279
00:17:15,369 --> 00:17:16,619
contain other tuples.

280
00:17:20,030 --> 00:17:24,260
In this case, how many
elements does

281
00:17:24,260 --> 00:17:26,476
tuple_of_tuples have?

282
00:17:26,476 --> 00:17:28,448
AUDIENCE: 3.

283
00:17:28,448 --> 00:17:31,430
PROFESSOR: 3.

284
00:17:31,430 --> 00:17:36,740
The first element is a tuple,
the second element is 'got',

285
00:17:36,740 --> 00:17:38,470
and the third element
is 'real'.

286
00:17:41,240 --> 00:17:43,865
What should this print out?

287
00:17:43,865 --> 00:17:45,200
AUDIENCE: [INAUDIBLE]

288
00:17:45,200 --> 00:17:46,450
PROFESSOR: Yeah.

289
00:17:50,370 --> 00:17:52,538
I had to sanitize that quote.

290
00:17:52,538 --> 00:17:55,180
AUDIENCE: Why does it print
out the strings?

291
00:17:55,180 --> 00:17:59,270
PROFESSOR: Python's behavior,
when it sees a tuple data type

292
00:17:59,270 --> 00:18:02,980
and you call it with the print
statement, is it represents as

293
00:18:02,980 --> 00:18:06,180
a string a tuple the
way you would

294
00:18:06,180 --> 00:18:11,680
literally write out a tuple.

295
00:18:11,680 --> 00:18:14,010
'Stuff, just' is a tuple
with the two

296
00:18:14,010 --> 00:18:15,990
strings 'stuff' and 'just'.

297
00:18:15,990 --> 00:18:21,680
Python is going to print out the
literal representation of

298
00:18:21,680 --> 00:18:22,930
that tuple.

299
00:18:25,410 --> 00:18:32,640
Another way to try and explain
it, let's say that I print out

300
00:18:32,640 --> 00:18:34,480
the entire tuple.

301
00:18:34,480 --> 00:18:37,760
What should this look like?

302
00:18:37,760 --> 00:18:39,495
Well, It's going to be
just the literal

303
00:18:39,495 --> 00:18:40,745
representation of the tuple.

304
00:18:47,600 --> 00:18:50,645
What does it mean for the data
type to be immutable?

305
00:18:59,150 --> 00:19:00,110
AUDIENCE: You can't change it.

306
00:19:00,110 --> 00:19:02,050
You can't add another
element to it?

307
00:19:02,050 --> 00:19:03,930
PROFESSOR: You can't
change it.

308
00:19:03,930 --> 00:19:09,270
If I try to change the first
element of tuple_of_numbers,

309
00:19:09,270 --> 00:19:10,930
it's going to tell me
it doesn't support--

310
00:19:10,930 --> 00:19:12,750
or Python's going to tell me
it doesn't support item

311
00:19:12,750 --> 00:19:15,510
assignment.

312
00:19:15,510 --> 00:19:16,760
You'll see this error.

313
00:19:29,010 --> 00:19:33,860
Tuples support something called
slicing, which means

314
00:19:33,860 --> 00:19:38,060
that if I have a
tuple_of_numbers

315
00:19:38,060 --> 00:19:39,720
and I give it a--

316
00:19:39,720 --> 00:19:42,580
where I normally put just a
single integer for an index,

317
00:19:42,580 --> 00:19:47,150
if I give it a start index and
an end index, separated by

318
00:19:47,150 --> 00:19:54,060
this colon, Python's going to
get the item at index 1 to

319
00:19:54,060 --> 00:19:58,810
whatever this end element
is minus 1.

320
00:19:58,810 --> 00:20:02,180
It helps if I just
print it out.

321
00:20:02,180 --> 00:20:04,565
To make it a little bit
easier to follow.

322
00:20:12,260 --> 00:20:14,790
I've said I've told Python that
I want a slice out of

323
00:20:14,790 --> 00:20:18,640
this tuple from 1 to 3.

324
00:20:18,640 --> 00:20:23,960
What Python's going to go do is
look into tuple_of_numbers.

325
00:20:23,960 --> 00:20:25,970
This is element 0.

326
00:20:25,970 --> 00:20:29,490
This is index 1; it's
going to pull in 2.

327
00:20:29,490 --> 00:20:32,650
This is index 2; i it's
going to pull in 1.

328
00:20:32,650 --> 00:20:35,200
Then 3--

329
00:20:35,200 --> 00:20:40,730
in Python, we go 1 past the end
of the range that we want.

330
00:20:40,730 --> 00:20:43,320
It's going to return
a tuple of 2, 1.

331
00:20:43,320 --> 00:20:44,570
This is slicing a tuple.

332
00:20:48,340 --> 00:20:50,854
Anyone confused by that?

333
00:20:50,854 --> 00:20:51,750
No?

334
00:20:51,750 --> 00:20:53,000
Wow.

335
00:20:55,270 --> 00:20:57,980
There are many different ways
that we can slice a tuple.

336
00:20:57,980 --> 00:21:01,320
We can have an implicit start.

337
00:21:01,320 --> 00:21:06,520
If you see this, where there's
no number before the colon,

338
00:21:06,520 --> 00:21:09,010
that tells Python start
at index 0.

339
00:21:12,760 --> 00:21:19,820
Then, in complimentary fashion,
if you see this,

340
00:21:19,820 --> 00:21:23,170
where you have an integer on the
left side and nothing on

341
00:21:23,170 --> 00:21:27,120
the right side, it tells Python
go from index 1 all the

342
00:21:27,120 --> 00:21:28,430
way to the end of the tuple.

343
00:21:34,410 --> 00:21:38,253
What happens is I do this?

344
00:21:43,920 --> 00:21:46,920
What's that telling
Python to do?

345
00:21:46,920 --> 00:21:48,390
AUDIENCE: [INAUDIBLE]

346
00:21:48,390 --> 00:21:49,050
PROFESSOR: Yeah.

347
00:21:49,050 --> 00:21:52,960
It looks redundant but it will
become important to us when we

348
00:21:52,960 --> 00:21:56,840
get to lists and something
called aliasing.

349
00:21:56,840 --> 00:21:59,570
What this does is it tells
Python to take a slice that is

350
00:21:59,570 --> 00:22:00,820
the entire tuple.

351
00:22:04,250 --> 00:22:07,280
Then when we do these
slices, we can also

352
00:22:07,280 --> 00:22:09,530
use negative indices.

353
00:22:09,530 --> 00:22:15,220
This is going to tell Python
to go from 0 to the last

354
00:22:15,220 --> 00:22:18,400
element minus 1.

355
00:22:18,400 --> 00:22:19,650
It'll look like that.

356
00:22:25,000 --> 00:22:26,090
Everyone following?

357
00:22:26,090 --> 00:22:27,270
We good?

358
00:22:27,270 --> 00:22:29,065
AUDIENCE: It was minuses
from the end--

359
00:22:29,065 --> 00:22:29,420
PROFESSOR: Yeah.

360
00:22:29,420 --> 00:22:29,806
AUDIENCE: --of the tuple?

361
00:22:29,806 --> 00:22:32,060
PROFESSOR: Okay.

362
00:22:32,060 --> 00:22:34,240
I wonder if this would work?

363
00:22:34,240 --> 00:22:35,490
I don't know.

364
00:22:37,530 --> 00:22:41,530
No, it has unexpected
behavior.

365
00:22:41,530 --> 00:22:42,220
I don't know why.

366
00:22:42,220 --> 00:22:43,470
I'll have to look that up.

367
00:22:47,800 --> 00:22:50,670
Tuples are also--

368
00:22:50,670 --> 00:22:52,020
we already said earlier
that they were

369
00:22:52,020 --> 00:22:53,210
enumerable items, right?

370
00:22:53,210 --> 00:22:55,530
So we can use a FOR
loop with them.

371
00:22:55,530 --> 00:23:00,570
If I want to print out all the
numbers in tuple_of_numbers, I

372
00:23:00,570 --> 00:23:04,840
have my FOR loop, my variable,
in, and then

373
00:23:04,840 --> 00:23:06,090
my enumerable object.

374
00:23:10,800 --> 00:23:12,050
OK?

375
00:23:16,970 --> 00:23:18,220
I have a question now.

376
00:23:21,120 --> 00:23:23,350
Who thinks this will work?

377
00:23:23,350 --> 00:23:24,785
We know that tuples
are immutable.

378
00:23:33,427 --> 00:23:33,918
AUDIENCE: Yeah.

379
00:23:33,918 --> 00:23:35,890
But you have to change
the inside.

380
00:23:35,890 --> 00:23:37,840
PROFESSOR: Right.

381
00:23:37,840 --> 00:23:39,090
It's going to work.

382
00:23:41,633 --> 00:23:43,355
I still have print up here.

383
00:23:46,960 --> 00:23:49,540
What I'm doing is I'm taking
tuple_of_numbers and I'm

384
00:23:49,540 --> 00:23:51,480
printing before.

385
00:23:51,480 --> 00:23:55,740
Then what I'm doing here is
I'm telling Python to take

386
00:23:55,740 --> 00:24:02,130
this tuple and this tuple and
add them together and reassign

387
00:24:02,130 --> 00:24:03,380
it back to tuple_of_numbers.

388
00:24:06,630 --> 00:24:11,910
So, It looks like I'm
modifying the tuple.

389
00:24:11,910 --> 00:24:15,170
But in reality, what's
happening is I'm

390
00:24:15,170 --> 00:24:16,420
creating a new tuple.

391
00:24:20,130 --> 00:24:23,170
Let's say I have ton here.

392
00:24:23,170 --> 00:24:26,660
Ton is short for
tuple_of_numers.

393
00:24:26,660 --> 00:24:32,110
Originally, it's telling Python
that some chunk of

394
00:24:32,110 --> 00:24:39,320
memory has a tuple
of 1, 2, 3, 4.

395
00:24:39,320 --> 00:24:47,090
When I say a statement like
ton equal ton plus another

396
00:24:47,090 --> 00:24:51,740
tuple, what it's telling Python
to do is create another

397
00:24:51,740 --> 00:24:58,730
chunk of memory that includes
ton, whatever's in ton, and

398
00:24:58,730 --> 00:24:59,980
the other tuple.

399
00:25:03,730 --> 00:25:07,540
Then this assignment statement
tells Python that ton now

400
00:25:07,540 --> 00:25:10,965
points to this new object.

401
00:25:10,965 --> 00:25:13,857
You had a question?

402
00:25:13,857 --> 00:25:16,671
AUDIENCE:Does Python have
a garbage collector?

403
00:25:16,671 --> 00:25:19,350
PROFESSOR: It's an advanced
question.

404
00:25:19,350 --> 00:25:23,190
The question was, does Python
have a garbage collector to

405
00:25:23,190 --> 00:25:25,860
discard this memory that's
no longer being used.

406
00:25:25,860 --> 00:25:27,660
The answer is yes.

407
00:25:27,660 --> 00:25:29,740
If you don't know what a garbage
collector is, don't

408
00:25:29,740 --> 00:25:30,220
worry about it.

409
00:25:30,220 --> 00:25:31,230
You don't need to.

410
00:25:31,230 --> 00:25:34,230
But to answer your question,
yes, it does.

411
00:25:38,166 --> 00:25:40,668
I don't want to get
too far into it.

412
00:25:43,300 --> 00:25:45,870
Does everyone follow that?

413
00:25:45,870 --> 00:25:48,365
That also is going to be
important when we get to lists

414
00:25:48,365 --> 00:25:53,250
and aliasing, that type of
object creation modification.

415
00:25:57,350 --> 00:25:59,400
We won't get to that
for a while.

416
00:25:59,400 --> 00:26:00,410
Everyone's good with this?

417
00:26:00,410 --> 00:26:01,722
I can move on?

418
00:26:01,722 --> 00:26:02,972
All right.

419
00:26:04,850 --> 00:26:11,200
Python has what some might
consider a wart,

420
00:26:11,200 --> 00:26:13,840
when it comes to tuples.

421
00:26:13,840 --> 00:26:17,410
That is when you want to create
a tuple with a single

422
00:26:17,410 --> 00:26:18,660
element in it.

423
00:26:23,370 --> 00:26:28,680
People just starting out with
Python would sometimes mistake

424
00:26:28,680 --> 00:26:32,272
the tuple literal of a single
element to be this: So,

425
00:26:32,272 --> 00:26:34,730
parenthesis with a
single integer.

426
00:26:34,730 --> 00:26:37,850
The problem is that parentheses
are the grouping

427
00:26:37,850 --> 00:26:40,460
operatorS in Python,
but they're also

428
00:26:40,460 --> 00:26:41,940
used for making tuples.

429
00:26:41,940 --> 00:26:45,220
They serve a dual purpose.

430
00:26:45,220 --> 00:26:48,880
What Python will say is, oh,
I've got a number between two

431
00:26:48,880 --> 00:26:49,910
parentheses.

432
00:26:49,910 --> 00:26:52,530
Well, this person really wants
this integer to have high

433
00:26:52,530 --> 00:26:54,010
precedence.

434
00:26:54,010 --> 00:26:57,380
We're going to make an integer
50 and assign it to oopsie.

435
00:26:57,380 --> 00:26:59,880
But it's not what we want.

436
00:26:59,880 --> 00:27:04,660
We want a tuple with
50 as one element.

437
00:27:04,660 --> 00:27:09,780
The way you do that is you have
a lone comma after the

438
00:27:09,780 --> 00:27:11,030
first element.

439
00:27:13,600 --> 00:27:16,610
If we run this and we look at
what it prints out, you see

440
00:27:16,610 --> 00:27:20,900
that oopsie has the integer 50,
which is not what we want.

441
00:27:20,900 --> 00:27:22,150
We want what's in onesie.

442
00:27:34,460 --> 00:27:35,710
Anyone confused by that?

443
00:27:40,250 --> 00:27:41,675
We're zooming along here.

444
00:27:45,720 --> 00:27:51,990
Strings, they're actually
a lot like tuples.

445
00:27:51,990 --> 00:27:52,970
They're immutable.

446
00:27:52,970 --> 00:27:54,420
You can't change them.

447
00:27:54,420 --> 00:27:57,150
They're non-scalar.

448
00:27:57,150 --> 00:28:00,520
They have multiple characters
within them.

449
00:28:00,520 --> 00:28:03,310
If I printed out-- everyone's
seen this--

450
00:28:03,310 --> 00:28:05,850
I can get to individual
characters.

451
00:28:05,850 --> 00:28:10,650
If I want to get to the first
character in name, I use 0.

452
00:28:10,650 --> 00:28:13,080
If I want to get to the second
character, I can use 1.

453
00:28:23,940 --> 00:28:26,300
Then of course they're
immutable, so that's going to

454
00:28:26,300 --> 00:28:27,550
tell me that I can't do that.

455
00:28:36,650 --> 00:28:37,960
They also support iteration.

456
00:28:41,040 --> 00:28:45,430
So, if I want to print out all
the letters in name, one on

457
00:28:45,430 --> 00:28:48,410
each line, I can do this.

458
00:28:48,410 --> 00:28:54,010
Not too useful, but it works.

459
00:28:54,010 --> 00:28:56,224
You looked confused.

460
00:28:56,224 --> 00:28:58,880
AUDIENCE: How did that happen?

461
00:28:58,880 --> 00:29:00,130
PROFESSOR: How did
that happen?

462
00:29:03,450 --> 00:29:04,740
So, name is a string.

463
00:29:04,740 --> 00:29:06,320
Follow that?

464
00:29:06,320 --> 00:29:09,030
String is just a bunch
of characters.

465
00:29:13,170 --> 00:29:17,470
It is enumerable, meaning that
we can go one character at a

466
00:29:17,470 --> 00:29:19,410
time through the string.

467
00:29:24,320 --> 00:29:25,715
That's what the FOR loop does.

468
00:29:28,390 --> 00:29:30,810
AUDIENCE: Do spaces count
as characters?

469
00:29:30,810 --> 00:29:31,082
PROFESSOR: Good.

470
00:29:31,082 --> 00:29:33,600
The question was do spaces
count as characters.

471
00:29:33,600 --> 00:29:35,840
The answer is yes, they do.

472
00:29:35,840 --> 00:29:48,880
If I write spaces there and I
run this again, as I iterate

473
00:29:48,880 --> 00:29:52,830
through the string, I get a
space where I'm supposed to.

474
00:30:01,430 --> 00:30:03,370
Is everyone good with this?

475
00:30:03,370 --> 00:30:04,620
OK.

476
00:30:06,990 --> 00:30:09,370
Like tuples, you can
take slices.

477
00:30:15,330 --> 00:30:16,580
That's going to give me 'it'.

478
00:30:19,090 --> 00:30:24,495
Strings also have
many functions.

479
00:30:28,550 --> 00:30:32,110
This is an incomplete list of
functions that you can use on

480
00:30:32,110 --> 00:30:34,030
string objects.

481
00:30:34,030 --> 00:30:43,880
I can make everything uppercase,
lowercase.

482
00:30:49,920 --> 00:30:52,405
I can also find characters.

483
00:31:01,000 --> 00:31:05,570
What find does is it
finds the index of

484
00:31:05,570 --> 00:31:06,970
the left-most character.

485
00:31:06,970 --> 00:31:13,150
If I want to find i, it returns
1, because i is at

486
00:31:13,150 --> 00:31:16,320
index 1 in the string.

487
00:31:16,320 --> 00:31:19,540
I could also do something
like this.

488
00:31:19,540 --> 00:31:23,990
I can find an entire string.

489
00:31:23,990 --> 00:31:27,350
'tch', the substring,
starts at index 2.

490
00:31:33,110 --> 00:31:36,000
AUDIENCE: What does it return
if it can't find it?

491
00:31:36,000 --> 00:31:39,260
PROFESSOR: If it doesn't
find it--

492
00:31:39,260 --> 00:31:40,510
let's put in garbage--

493
00:31:43,850 --> 00:31:45,100
you get negative 1.

494
00:31:55,320 --> 00:31:57,420
We can also call a
replace function.

495
00:31:57,420 --> 00:31:59,530
If I want to replace
m with p--

496
00:32:02,510 --> 00:32:06,290
it doesn't make sense
anymore--

497
00:32:06,290 --> 00:32:07,255
I can do that.

498
00:32:07,255 --> 00:32:09,580
The question is, how would I use
this to change the string?

499
00:32:14,080 --> 00:32:18,410
Think back to how we
modified the tuple.

500
00:32:18,410 --> 00:32:21,040
We created a new object and
then we assigned it to a

501
00:32:21,040 --> 00:32:24,570
variable of the same name.

502
00:32:24,570 --> 00:32:26,970
If I know that replace is going
to return a string with

503
00:32:26,970 --> 00:32:36,625
m replaced, I can do that.

504
00:32:46,070 --> 00:32:47,320
Does everyone follow that?

505
00:32:49,750 --> 00:32:50,925
AUDIENCE: Is the version
that that

506
00:32:50,925 --> 00:32:52,570
captures your string function?

507
00:32:52,570 --> 00:32:54,500
PROFESSOR: That's
a good question.

508
00:32:54,500 --> 00:32:58,020
That also gives me a perfect
opportunity to demonstrate

509
00:32:58,020 --> 00:33:00,920
another command that you'll
find helpful.

510
00:33:00,920 --> 00:33:04,740
If you're working with an object
like string, you can

511
00:33:04,740 --> 00:33:07,650
use a command in the interactive
editor called dir.

512
00:33:07,650 --> 00:33:15,320
If you type dir str, it's going
to return all of the

513
00:33:15,320 --> 00:33:18,470
symbols that exist within
the str object.

514
00:33:18,470 --> 00:33:24,110
You can also type help str, and
it will give you a nicer

515
00:33:24,110 --> 00:33:25,360
version of this.

516
00:33:28,260 --> 00:33:30,347
AUDIENCE: In this case, the
first character indicates what

517
00:33:30,347 --> 00:33:32,236
you're trying to replace and
the second is what you're

518
00:33:32,236 --> 00:33:35,230
replacing it with?

519
00:33:35,230 --> 00:33:35,780
PROFESSOR: Right.

520
00:33:35,780 --> 00:33:41,350
We can do help str replace,
and it'll tell us.

521
00:33:41,350 --> 00:33:41,827
AUDIENCE: OK.

522
00:33:41,827 --> 00:33:44,689
So it did one.

523
00:33:44,689 --> 00:33:47,074
And then the count in this
case would be if you had

524
00:33:47,074 --> 00:33:49,460
multiple instances?

525
00:33:49,460 --> 00:33:49,940
PROFESSOR: Yes.

526
00:33:49,940 --> 00:33:50,082
AUDIENCE: OK.

527
00:33:50,082 --> 00:33:52,106
So like if you had your name
a couple times, you could

528
00:33:52,106 --> 00:33:53,940
replace it a few times.

529
00:33:53,940 --> 00:33:54,900
PROFESSOR: Right.

530
00:33:54,900 --> 00:33:58,720
If I were particularly
narcissistic that day, I could

531
00:33:58,720 --> 00:34:00,730
replace it multiple times.

532
00:34:00,730 --> 00:34:03,570
So let's demonstrate
that because some

533
00:34:03,570 --> 00:34:04,820
people might be confused.

534
00:34:07,150 --> 00:34:11,389
Let's say, I want
to replace t.

535
00:34:17,230 --> 00:34:18,480
I'm going to replace
it with r.

536
00:34:25,909 --> 00:34:27,650
Whoops.

537
00:34:27,650 --> 00:34:29,780
Well, why didn't it replace
these to t's here?

538
00:34:33,119 --> 00:34:35,510
AUDIENCE: [INAUDIBLE]

539
00:34:35,510 --> 00:34:36,850
PROFESSOR: Right.

540
00:34:36,850 --> 00:34:38,030
In strings, you differentiate
between

541
00:34:38,030 --> 00:34:39,280
lowercase and uppercase.

542
00:34:41,370 --> 00:34:44,780
If I wanted to get the behavior
that I was hoping

543
00:34:44,780 --> 00:34:48,810
for, I could do it this way.

544
00:34:55,659 --> 00:34:57,400
Now I have something that's
not even remotely

545
00:34:57,400 --> 00:34:59,600
looking like English.

546
00:34:59,600 --> 00:35:02,200
Or, I could do something
like this.

547
00:35:05,860 --> 00:35:11,640
I'm going to make everything
lowercase, and

548
00:35:11,640 --> 00:35:13,035
then replace the t.

549
00:35:16,674 --> 00:35:18,361
AUDIENCE: So that's
pretty exact that

550
00:35:18,361 --> 00:35:21,020
you have to be, lower--

551
00:35:21,020 --> 00:35:23,600
PROFESSOR: Remember what I said
first recitation that

552
00:35:23,600 --> 00:35:25,920
computers will do exactly what
you tell them to do and

553
00:35:25,920 --> 00:35:27,170
nothing more or less.

554
00:35:29,910 --> 00:35:31,962
There we go.

555
00:35:31,962 --> 00:35:32,870
AUDIENCE: It's good though.

556
00:35:32,870 --> 00:35:34,690
It figured out [INAUDIBLE]

557
00:35:34,690 --> 00:35:37,640
PROFESSOR: Python is a
very nice language.

558
00:35:37,640 --> 00:35:40,310
It's one of my favorite
languages right now.

559
00:35:40,310 --> 00:35:45,000
Because, it's not as fussy as
some other languages, like

560
00:35:45,000 --> 00:35:52,850
MATLAB or C or C++ or TCL.

561
00:35:52,850 --> 00:35:54,890
Anyone of those.

562
00:35:54,890 --> 00:35:57,490
Is everyone good on strings?

563
00:35:57,490 --> 00:35:58,930
I can move on?

564
00:35:58,930 --> 00:36:01,390
Just remember, if you need help
on any of these commands,

565
00:36:01,390 --> 00:36:03,609
just remember you have the help
command at your disposal.

566
00:36:03,609 --> 00:36:05,445
AUDIENCE: It'll automatically
default to do everything,

567
00:36:05,445 --> 00:36:08,660
unless you tell it something to
do like two of the letters.

568
00:36:08,660 --> 00:36:10,600
PROFESSOR: Yes.

569
00:36:10,600 --> 00:36:13,630
We didn't demonstrate that.

570
00:36:13,630 --> 00:36:15,460
Demonstrations are worth
a thousand words.

571
00:36:15,460 --> 00:36:19,030
If I wanted to, for whatever
reason, only replace the first

572
00:36:19,030 --> 00:36:22,230
two t's, I could tell it to only
replace two t's within

573
00:36:22,230 --> 00:36:23,480
the string.

574
00:36:26,570 --> 00:36:29,872
It leaves the other t alone.

575
00:36:29,872 --> 00:36:33,275
AUDIENCE: How would you pick
out the last field?

576
00:36:33,275 --> 00:36:34,525
PROFESSOR: That's
a good question.

577
00:36:37,560 --> 00:36:38,860
I don't have a ready
answer for you.

578
00:36:49,310 --> 00:36:55,610
You see these functions with
r in front of them?

579
00:36:55,610 --> 00:37:01,620
The string object often has
functions that will start from

580
00:37:01,620 --> 00:37:03,780
the right side as opposed
to the left side.

581
00:37:03,780 --> 00:37:09,390
The find command I showed you
has an rfind command as well.

582
00:37:09,390 --> 00:37:10,960
This guy right here.

583
00:37:10,960 --> 00:37:18,040
I'm pointing on if there is
the analog to replace.

584
00:37:18,040 --> 00:37:20,420
Can I get back to you?

585
00:37:20,420 --> 00:37:22,590
I don't want to spend all our
time searching for this and

586
00:37:22,590 --> 00:37:23,840
then fail spectacularly.

587
00:37:26,550 --> 00:37:28,870
I'll get back to you on that.

588
00:37:28,870 --> 00:37:29,780
Is it possible?

589
00:37:29,780 --> 00:37:30,120
Yeah.

590
00:37:30,120 --> 00:37:33,100
Is there a one-liner function?

591
00:37:33,100 --> 00:37:34,350
I can't tell you
at the moment.

592
00:37:39,960 --> 00:37:41,960
But again, that's why you
have dir and help.

593
00:37:41,960 --> 00:37:43,390
You can find this
out on your own.

594
00:37:49,940 --> 00:37:53,600
Next thing, BREAK.

595
00:37:53,600 --> 00:37:54,770
We're done with strings.

596
00:37:54,770 --> 00:37:56,480
We're done with tuples.

597
00:37:56,480 --> 00:37:58,430
We're still working on loops.

598
00:37:58,430 --> 00:38:01,200
Everyone's seen this function
before, right?

599
00:38:01,200 --> 00:38:09,030
This is our find-the-cube-ro
ot-of-a-perfect-cube function.

600
00:38:09,030 --> 00:38:13,510
If I give it 27, and I tell
Python to stop printing my

601
00:38:13,510 --> 00:38:25,440
name, that's what this does.

602
00:38:25,440 --> 00:38:31,180
As a toy example to illustrate
the BREAK statement--

603
00:38:31,180 --> 00:38:33,940
first of all, can someone tell
me in English what the BREAK

604
00:38:33,940 --> 00:38:35,810
statement does?

605
00:38:35,810 --> 00:38:39,830
AUDIENCE: Would it just
stop the program.

606
00:38:39,830 --> 00:38:41,520
PROFESSOR: Well, It doesn't stop
the program, but it kicks

607
00:38:41,520 --> 00:38:42,770
you out of the loop.

608
00:38:46,620 --> 00:38:54,630
We can rewrite the cube root
program to work like this.

609
00:38:54,630 --> 00:39:00,260
Instead of our stopping criteria
being answer cubed

610
00:39:00,260 --> 00:39:03,980
less than the absolute value
of the number, we're just

611
00:39:03,980 --> 00:39:10,540
going to tell the FOR loop to
go from a range 0 to the

612
00:39:10,540 --> 00:39:13,200
absolute value of the
input plus 1.

613
00:39:13,200 --> 00:39:14,841
Why do we have the
plus 1 there?

614
00:39:14,841 --> 00:39:17,550
AUDIENCE: So it goes to the
absolute value of x.

615
00:39:17,550 --> 00:39:17,980
PROFESSOR: Yeah.

616
00:39:17,980 --> 00:39:20,570
Because, otherwise, it would
go to 1 before the absolute

617
00:39:20,570 --> 00:39:22,800
value of x.

618
00:39:22,800 --> 00:39:27,850
Then we break out of this loop,
if answer cubed is equal

619
00:39:27,850 --> 00:39:28,970
to absolute value of x.

620
00:39:28,970 --> 00:39:33,590
As soon as we see that it's
equal to x, we're going to

621
00:39:33,590 --> 00:39:34,890
call BREAK.

622
00:39:34,890 --> 00:39:38,150
That's going to immediately kick
us out to here, without

623
00:39:38,150 --> 00:39:39,890
executing any more
of the FOR loop.

624
00:39:47,170 --> 00:39:49,240
Do people understand that?

625
00:39:49,240 --> 00:39:51,194
Are people good with that?

626
00:39:51,194 --> 00:39:51,634
AUDIENCE: Does it break you
of the innermost loop? or

627
00:39:51,634 --> 00:39:54,120
[INAUDIBLE]

628
00:39:54,120 --> 00:39:55,170
PROFESSOR: Yes.

629
00:39:55,170 --> 00:39:57,180
Good question.

630
00:39:57,180 --> 00:39:58,590
Does it break you out
of the innermost

631
00:39:58,590 --> 00:40:00,320
loop or all the loops?

632
00:40:00,320 --> 00:40:02,710
The answer is the
innermost loop.

633
00:40:02,710 --> 00:40:04,520
When he says innermost,
what he's talking

634
00:40:04,520 --> 00:40:06,040
about are nested loops.

635
00:40:06,040 --> 00:40:08,922
Let's say I have something
like this.

636
00:40:08,922 --> 00:40:17,110
I'm creating on the fly
now, so excuse my

637
00:40:17,110 --> 00:40:18,360
inability to type.

638
00:40:45,060 --> 00:40:47,420
What is this going to do?

639
00:40:47,420 --> 00:40:51,320
This is an example
of a nested loop.

640
00:40:51,320 --> 00:40:54,200
We have an outer loop
here, then we have

641
00:40:54,200 --> 00:40:55,450
an inner loop here.

642
00:40:58,110 --> 00:41:00,640
All the outer loop is doing is
it's going from the integers

643
00:41:00,640 --> 00:41:02,940
0, 1, 2, 3 to 9.

644
00:41:05,730 --> 00:41:08,700
And then we have an inner loop,
which looks like it

645
00:41:08,700 --> 00:41:13,190
should go from the integers
10 to 100.

646
00:41:13,190 --> 00:41:19,000
But we have the statement
in here if j mod 2--

647
00:41:19,000 --> 00:41:21,990
that's what the percent
sign is, modulus--

648
00:41:21,990 --> 00:41:23,460
is equal to 0.

649
00:41:23,460 --> 00:41:28,700
What we're saying is if j is
evenly divisible by 2, we're

650
00:41:28,700 --> 00:41:30,990
going to break.

651
00:41:30,990 --> 00:41:32,240
Now, the question is--

652
00:41:38,610 --> 00:41:46,130
this is obviously going
to break when j is 10.

653
00:41:46,130 --> 00:41:47,660
This loop is going
to execute once.

654
00:41:50,820 --> 00:42:02,045
The question is does it print
out only one set of i,j

655
00:42:02,045 --> 00:42:04,180
values, or does it
print out 10?

656
00:42:08,200 --> 00:42:09,920
I'm getting to the answer
to this question.

657
00:42:09,920 --> 00:42:12,820
If BREAK statement breaks out
of all the loops, then we

658
00:42:12,820 --> 00:42:16,710
would only see one printout
of i and j.

659
00:42:16,710 --> 00:42:19,350
But if it only breaks out of
this inner loop, then we

660
00:42:19,350 --> 00:42:25,180
should see 10, followed
by 'here'.

661
00:42:25,180 --> 00:42:28,080
So it breaks out of
the inner loop.

662
00:42:28,080 --> 00:42:29,330
Long answer, but
demonstration.

663
00:42:31,876 --> 00:42:33,195
Is anyone confused by that?

664
00:42:38,620 --> 00:42:39,900
Is so, anyone too
shy to admit it?

665
00:42:43,150 --> 00:42:44,400
There's office hours.

666
00:42:47,150 --> 00:42:48,400
Or, you can talk to
me afterwards.

667
00:42:58,030 --> 00:43:00,810
PROFESSOR: Now we're going to
get to functions, which are

668
00:43:00,810 --> 00:43:03,010
triple underlined and circled
over here because they're

669
00:43:03,010 --> 00:43:04,660
extraordinarily important
for you to understand.

670
00:43:07,280 --> 00:43:10,040
Can someone wing it and
tell me what they

671
00:43:10,040 --> 00:43:11,290
think a function is?

672
00:43:19,778 --> 00:43:21,236
AUDIENCE: It's a snippet of code
that takes some input,

673
00:43:21,236 --> 00:43:23,690
does something to it, and
returns some output.

674
00:43:23,690 --> 00:43:25,020
PROFESSOR: Perfect.

675
00:43:25,020 --> 00:43:26,780
It's a bit of code.

676
00:43:26,780 --> 00:43:28,810
It's named, so you
can refer to it.

677
00:43:28,810 --> 00:43:32,930
It takes input, does something
with it, and returns

678
00:43:32,930 --> 00:43:36,130
something, some value.

679
00:43:36,130 --> 00:43:42,240
The way that we define a
function in Python is like so.

680
00:43:42,240 --> 00:43:47,100
Let's say I have a
function cube.

681
00:43:47,100 --> 00:43:48,920
It consists of a few parts.

682
00:43:48,920 --> 00:43:52,330
We've got the DEF keyword.

683
00:43:52,330 --> 00:43:54,170
We've got a name, cube.

684
00:43:54,170 --> 00:43:55,950
The name should be meaningful
for functions.

685
00:43:55,950 --> 00:43:59,780
Like variables, the name should
mean something So, this

686
00:43:59,780 --> 00:44:03,720
would be a bad name
for this function.

687
00:44:03,720 --> 00:44:05,465
You want it to be meaningful.

688
00:44:05,465 --> 00:44:07,520
It has a set of parameters.

689
00:44:07,520 --> 00:44:10,270
In this case, it only
has one parameter.

690
00:44:10,270 --> 00:44:16,720
This is what we pass to the
function when we call it.

691
00:44:16,720 --> 00:44:18,932
We'll talk about that
in another second.

692
00:44:18,932 --> 00:44:20,710
It has this string.

693
00:44:20,710 --> 00:44:23,990
This is called a doc string.

694
00:44:23,990 --> 00:44:26,940
It's the specification
for this function.

695
00:44:26,940 --> 00:44:31,280
When you write functions, it's
good to have this string here.

696
00:44:31,280 --> 00:44:33,770
What it allows you to do is
describe what the function

697
00:44:33,770 --> 00:44:39,330
does, what it expects for
input, and what it

698
00:44:39,330 --> 00:44:40,580
gives you as output.

699
00:44:42,710 --> 00:44:45,140
In this case, it's
very simple.

700
00:44:45,140 --> 00:44:47,100
This is the body of
the function.

701
00:44:47,100 --> 00:44:52,030
Again we denote the block
by indenting.

702
00:44:52,030 --> 00:44:54,470
All it does is it takes a
number, which is passed into

703
00:44:54,470 --> 00:44:59,880
it and raises it to
the third power.

704
00:44:59,880 --> 00:45:03,620
This RETURN statement tells
Python to send that back to

705
00:45:03,620 --> 00:45:04,870
whoever called the function.

706
00:45:07,980 --> 00:45:18,610
As an example if this working,
let's look at

707
00:45:18,610 --> 00:45:20,060
this line of code.

708
00:45:20,060 --> 00:45:22,140
What it's doing is--

709
00:45:22,140 --> 00:45:23,170
we've seen the print
statement, so we

710
00:45:23,170 --> 00:45:25,190
know what it does.

711
00:45:25,190 --> 00:45:31,110
It's going to name cube and
it's going to call it.

712
00:45:31,110 --> 00:45:33,820
Python knows it's calling it
because it's got the name of

713
00:45:33,820 --> 00:45:36,830
the function with the
input parameters.

714
00:45:36,830 --> 00:45:47,140
So, 3 is being passed to cube
to be, well, cubed.

715
00:45:47,140 --> 00:45:51,230
What's going on here is that
Python is breaking out of its

716
00:45:51,230 --> 00:45:58,550
normal flow of execution,
sending 3, calling it number

717
00:45:58,550 --> 00:46:01,290
in the function, and then
raising it to the third power.

718
00:46:01,290 --> 00:46:04,135
If we run this, we see 27.

719
00:46:09,160 --> 00:46:15,720
We can pass it any number
that we want.

720
00:46:15,720 --> 00:46:19,596
Is anyone confused by this?

721
00:46:19,596 --> 00:46:21,255
AUDIENCE: The things you're
running between quotation

722
00:46:21,255 --> 00:46:23,870
marks, doesn't that kind of--

723
00:46:23,870 --> 00:46:25,860
PROFESSOR: They don't
do anything.

724
00:46:25,860 --> 00:46:30,340
The question was, this string
here between the quotation

725
00:46:30,340 --> 00:46:31,680
marks, this doesn't
do anything.

726
00:46:31,680 --> 00:46:32,750
No, this is a comment.

727
00:46:32,750 --> 00:46:35,770
This is so that you can tell
yourself, six months down the

728
00:46:35,770 --> 00:46:37,420
road, what you were thinking.

729
00:46:37,420 --> 00:46:39,730
Or so that you could tell
another programmer what this

730
00:46:39,730 --> 00:46:41,270
function does.

731
00:46:41,270 --> 00:46:44,950
It's a way of documenting
your code.

732
00:46:44,950 --> 00:46:46,180
AUDIENCE: So cube in this
case is something that

733
00:46:46,180 --> 00:46:48,400
is built to go around.

734
00:46:48,400 --> 00:46:48,760
PROFESSOR: Yeah.

735
00:46:48,760 --> 00:46:51,190
This is just a toy example.

736
00:46:51,190 --> 00:46:54,830
I wanted to keep it simple.

737
00:46:54,830 --> 00:46:58,240
I'm illustrating concepts.

738
00:46:58,240 --> 00:47:02,335
It wouldn't be too hard
just to do this.

739
00:47:09,070 --> 00:47:10,540
I'm going to move on.

740
00:47:10,540 --> 00:47:11,790
Everyone's good with
functions?

741
00:47:14,235 --> 00:47:15,485
AUDIENCE: [INAUDIBLE]

742
00:47:20,103 --> 00:47:22,548
Can you say x equals number--

743
00:47:22,548 --> 00:47:27,438
can you keep the number, and
just keep the number, and just

744
00:47:27,438 --> 00:47:29,394
make it into a variable without
the RETURN function.

745
00:47:31,928 --> 00:47:35,400
Do you have to use the RETURN
function on that?

746
00:47:35,400 --> 00:47:36,870
PROFESSOR: I was just
getting to that.

747
00:47:36,870 --> 00:47:39,670
The question is, do you have
to use a RETURN function.

748
00:47:39,670 --> 00:47:42,760
The answer is well, it depends
on what you want to do.

749
00:47:49,840 --> 00:47:52,810
So, let's take a look
at a new function.

750
00:47:52,810 --> 00:47:56,660
Can someone tell me
what this does?

751
00:47:56,660 --> 00:47:58,816
First, what does the
function do?

752
00:47:58,816 --> 00:48:00,066
Or what is it supposed to do?

753
00:48:02,788 --> 00:48:05,420
AUDIENCE: Takes the number
and doubles it.

754
00:48:05,420 --> 00:48:07,100
PROFESSOR: You got that by
reading the writing on the

755
00:48:07,100 --> 00:48:09,540
wall, right?

756
00:48:09,540 --> 00:48:12,910
Really, it's too easy.

757
00:48:12,910 --> 00:48:16,010
In the body of the function,
all it does is it creates a

758
00:48:16,010 --> 00:48:18,820
new variable, answer, and it
assigns number times 2 to it.

759
00:48:21,740 --> 00:48:22,990
What's going to print
out here?

760
00:48:27,450 --> 00:48:28,700
Why don't we run it and see?

761
00:48:31,240 --> 00:48:33,680
That's not doing
what we wanted.

762
00:48:33,680 --> 00:48:38,750
When you don't have a RETURN
statement, Python returns

763
00:48:38,750 --> 00:48:41,730
implicitly none to whoever
calls the function.

764
00:48:45,310 --> 00:48:45,390
Ok.

765
00:48:45,390 --> 00:48:47,660
In this case, this function
obviously doesn't have a

766
00:48:47,660 --> 00:48:52,180
RETURN statement Python
says, OK.

767
00:48:52,180 --> 00:48:53,660
I'm just going to return none.

768
00:48:53,660 --> 00:48:59,210
Whatever work it did in the
function is lost in this case.

769
00:48:59,210 --> 00:49:01,300
To get the right functionality,
we have to add

770
00:49:01,300 --> 00:49:02,550
a RETURN statement.

771
00:49:06,600 --> 00:49:09,520
And it works.

772
00:49:09,520 --> 00:49:11,095
Was that what you
were getting at?

773
00:49:11,095 --> 00:49:12,345
OK.

774
00:49:14,900 --> 00:49:15,640
Anyone confused?

775
00:49:15,640 --> 00:49:16,890
Can I move on?

776
00:49:25,700 --> 00:49:27,530
Functions have something
called variable scope.

777
00:49:31,630 --> 00:49:33,380
I apologize for the punning.

778
00:49:33,380 --> 00:49:35,790
I was getting tired
when I wrote this.

779
00:49:38,740 --> 00:49:40,740
In this chunk of code,
I define a

780
00:49:40,740 --> 00:49:41,990
global variable, all_hope.

781
00:49:44,890 --> 00:49:50,180
I also define a function that
takes a parameter, variables.

782
00:49:52,840 --> 00:49:55,120
It says it steals all the
variables, but I don't know

783
00:49:55,120 --> 00:49:57,420
how it does that
in a computer.

784
00:49:57,420 --> 00:50:00,690
It doesn't return anything.

785
00:50:00,690 --> 00:50:02,970
In the body of the function,
I create another variable,

786
00:50:02,970 --> 00:50:08,800
called my_variable, and
I assign it a string.

787
00:50:08,800 --> 00:50:10,980
I'm not actually returning
anything right because I've

788
00:50:10,980 --> 00:50:12,050
said I'm not returning
anything.

789
00:50:12,050 --> 00:50:15,040
All this is doing is it's
just printing stuff out.

790
00:50:15,040 --> 00:50:19,610
It's printing out what the
parameter passed into it was.

791
00:50:19,610 --> 00:50:22,610
It's printing out variables.

792
00:50:22,610 --> 00:50:25,540
It's printing out all_hope,
which is a global variable

793
00:50:25,540 --> 00:50:27,270
that we define up here.

794
00:50:27,270 --> 00:50:31,450
It's printing out my_variable,
which is a local variable in

795
00:50:31,450 --> 00:50:32,700
the function.

796
00:50:35,330 --> 00:50:40,440
Down here I'm defining a
variable, old_meme_is_old.

797
00:50:40,440 --> 00:50:41,690
I'm calling the function.

798
00:50:45,680 --> 00:50:48,970
It does what we expect
it to do.

799
00:50:48,970 --> 00:50:52,770
What I want to illustrate,
though is what

800
00:50:52,770 --> 00:50:54,020
happens if I do this?

801
00:51:03,010 --> 00:51:05,040
As you might expect,
it's going to give

802
00:51:05,040 --> 00:51:07,150
me an error, right?

803
00:51:07,150 --> 00:51:12,450
The reason is that my_variable
has local scope to this

804
00:51:12,450 --> 00:51:14,570
function, all
_your_vars_are_belong_to_us.

805
00:51:20,900 --> 00:51:22,290
Is anyone confused by this?

806
00:51:22,290 --> 00:51:25,070
No one's confused by this?

807
00:51:25,070 --> 00:51:26,320
OK.

808
00:51:29,910 --> 00:51:31,160
Let's try something else.

809
00:51:59,960 --> 00:52:03,230
Let's not do that.

810
00:52:03,230 --> 00:52:13,700
If I run this code, we can tell
from the function that

811
00:52:13,700 --> 00:52:16,410
it's taking one parameter.

812
00:52:16,410 --> 00:52:18,440
It's incrementing
that parameter.

813
00:52:18,440 --> 00:52:20,460
It's incrementing this
global int that

814
00:52:20,460 --> 00:52:22,200
we've defined up here.

815
00:52:22,200 --> 00:52:25,090
It's returning the parameter
that it's just incremented.

816
00:52:27,670 --> 00:52:31,660
Erase my corny humor.

817
00:52:47,260 --> 00:52:51,210
The question now is, let's say
that I have a variable y, and

818
00:52:51,210 --> 00:52:52,610
I give it a value of 10.

819
00:52:52,610 --> 00:52:54,950
I'm being completely
arbitrary.

820
00:52:54,950 --> 00:53:01,671
If I call the variable, inc_it,
on y, first of all,

821
00:53:01,671 --> 00:53:02,921
what's going to print?

822
00:53:07,500 --> 00:53:09,890
If I print out the value of
y, what's going to print?

823
00:53:12,510 --> 00:53:13,760
We want to run it.

824
00:53:22,310 --> 00:53:25,190
Uh-oh, I'm failing.

825
00:53:37,460 --> 00:53:39,790
I'm stepping on myself here.

826
00:53:39,790 --> 00:53:43,550
This is why you don't debug
code on the fly.

827
00:53:43,550 --> 00:53:49,681
If I have a global variable and
I need to reference it, I

828
00:53:49,681 --> 00:53:50,630
use a global keyword.

829
00:53:50,630 --> 00:53:51,980
You should never have
to do this.

830
00:53:55,940 --> 00:53:58,390
Ink_it is going to
return 11, right?

831
00:53:58,390 --> 00:54:02,320
Because it's taken y, which
is 10, and it's called x

832
00:54:02,320 --> 00:54:03,890
equal x plus 1.

833
00:54:03,890 --> 00:54:05,671
Then it's returned this x.

834
00:54:09,640 --> 00:54:15,490
If I look at what y is, after
I've run this, y is still 10.

835
00:54:15,490 --> 00:54:22,150
This is because when we've
passed in x here and we've

836
00:54:22,150 --> 00:54:25,440
called x equal x plus 1, it's
actually shadowing itself.

837
00:54:25,440 --> 00:54:28,570
It's overriding what's in
the local parameter.

838
00:54:28,570 --> 00:54:35,240
But it's not overriding the
actual variable, y.

839
00:54:35,240 --> 00:54:40,110
We'll get more into
this later on.

840
00:54:40,110 --> 00:54:42,500
The important thing to
understand in this case is

841
00:54:42,500 --> 00:54:45,440
that the changes that you make
to this parameter stay within

842
00:54:45,440 --> 00:54:47,760
the function.

843
00:54:47,760 --> 00:54:48,350
We good?

844
00:54:48,350 --> 00:54:49,310
All right.

845
00:54:49,310 --> 00:54:56,330
I need to move pretty quickly
now to gotchas.

846
00:54:59,180 --> 00:55:02,580
I guarantee you someone's going
to make this mistake.

847
00:55:02,580 --> 00:55:03,830
Print is not RETURN.

848
00:55:09,190 --> 00:55:12,230
When you call print
print_is_not_return, it's

849
00:55:12,230 --> 00:55:14,570
going to call this function.

850
00:55:14,570 --> 00:55:17,760
It will print out this
string, but it's not

851
00:55:17,760 --> 00:55:19,700
returning the string.

852
00:55:19,700 --> 00:55:21,040
What it's returning
is none, because

853
00:55:21,040 --> 00:55:24,000
there's no return statement.

854
00:55:24,000 --> 00:55:25,830
That's where this
none comes from.

855
00:55:29,150 --> 00:55:32,060
RETURN is not print.

856
00:55:32,060 --> 00:55:36,145
So, if I say print this return
value, it will print this; it

857
00:55:36,145 --> 00:55:37,470
will return a string.

858
00:55:37,470 --> 00:55:45,235
But if I just call this, it's
not going to print it again.

859
00:55:47,890 --> 00:55:49,140
It's going to print nothing.

860
00:55:55,170 --> 00:55:56,510
You'll just have to
make the mistake.

861
00:56:03,150 --> 00:56:07,240
One thing to be careful
of in Python--

862
00:56:07,240 --> 00:56:09,360
remember I said everything
is an object?

863
00:56:09,360 --> 00:56:10,540
Functions are no different.

864
00:56:10,540 --> 00:56:13,230
Functions are objects.

865
00:56:13,230 --> 00:56:20,670
If you just reference the
function's name, cube, which

866
00:56:20,670 --> 00:56:31,960
is not defined now, it's going
to print something out that

867
00:56:31,960 --> 00:56:33,210
looks like that.

868
00:56:36,990 --> 00:56:42,600
This is what the object
looks like to Python.

869
00:56:42,600 --> 00:56:45,400
In order to call it, you have
to have the parentheses with

870
00:56:45,400 --> 00:56:46,650
the parameters.

871
00:56:50,070 --> 00:56:51,040
Python's not going
to complain.

872
00:56:51,040 --> 00:56:52,980
Some programming languages
will complain.

873
00:56:52,980 --> 00:56:54,530
Python won't.

874
00:56:54,530 --> 00:56:56,660
It's possible when you're
running your code, if you're

875
00:56:56,660 --> 00:56:59,700
trying to call a function and
you forget the parentheses,

876
00:56:59,700 --> 00:57:02,700
and Python's just not
complaining, it will merrily

877
00:57:02,700 --> 00:57:06,590
do what you tell it to do.

878
00:57:06,590 --> 00:57:08,510
AUDIENCE: [INAUDIBLE]

879
00:57:08,510 --> 00:57:10,840
PROFESSOR: What's that?

880
00:57:10,840 --> 00:57:12,090
AUDIENCE: [INAUDIBLE]

881
00:57:16,600 --> 00:57:19,580
PROFESSOR: I'm sorry,
can you speak up?

882
00:57:19,580 --> 00:57:25,010
AUDIENCE: Print q open
parentheses [INAUDIBLE]

883
00:57:25,010 --> 00:57:26,590
PROFESSOR: OK.

884
00:57:26,590 --> 00:57:29,252
Is x defined?

885
00:57:29,252 --> 00:57:30,502
AUDIENCE: [INAUDIBLE]

886
00:57:34,400 --> 00:57:35,650
PROFESSOR: Yeah.