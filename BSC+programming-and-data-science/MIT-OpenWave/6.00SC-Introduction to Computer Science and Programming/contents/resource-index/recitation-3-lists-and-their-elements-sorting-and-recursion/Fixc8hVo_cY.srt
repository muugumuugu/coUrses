1
00:00:00,530 --> 00:00:02,960
The following content is
provided under a Creative

2
00:00:02,960 --> 00:00:04,370
Commons license.

3
00:00:04,370 --> 00:00:07,410
Your support will help MIT
OpenCourseWare continue to

4
00:00:07,410 --> 00:00:11,060
offer high quality educational
resources for free.

5
00:00:11,060 --> 00:00:13,960
To make a donation or view
additional materials from

6
00:00:13,960 --> 00:00:19,790
hundreds of MIT courses, visit
MIT OpenCourseWare at

7
00:00:19,790 --> 00:00:21,040
ocw.mit.edu.

8
00:00:23,050 --> 00:00:25,840
PROFESSOR: So let's start.

9
00:00:25,840 --> 00:00:28,980
I mean for the first question
you can answer what is tuple.

10
00:00:28,980 --> 00:00:30,870
You can go to that later.

11
00:00:30,870 --> 00:00:32,520
Can a tuple contain a list?

12
00:00:35,280 --> 00:00:36,730
What do you think?

13
00:00:36,730 --> 00:00:38,960
Can a tuple contain a list?

14
00:00:38,960 --> 00:00:39,820
AUDIENCE: Yes.

15
00:00:39,820 --> 00:00:41,620
PROFESSOR: Yes, it can.

16
00:00:41,620 --> 00:00:43,790
So we'll go through the
examples later.

17
00:00:43,790 --> 00:00:48,890
And let's see this
first example.

18
00:00:48,890 --> 00:00:50,305
We have two tuples.

19
00:00:50,305 --> 00:00:53,500
The tuple B contains tuple
A, as well as a list.

20
00:00:56,640 --> 00:00:57,890
So it can't populate.

21
00:01:00,120 --> 00:01:01,630
Let's bring those lists, too.

22
00:01:07,540 --> 00:01:14,840
So for the first example we try
to access the elements 0

23
00:01:14,840 --> 00:01:22,730
and 2 of the tuple A. And
let me use minus 1 to

24
00:01:22,730 --> 00:01:24,450
access which element?

25
00:01:24,450 --> 00:01:26,715
AUDIENCE: [INAUDIBLE]

26
00:01:26,715 --> 00:01:28,080
PROFESSOR: OK.

27
00:01:28,080 --> 00:01:30,150
And 0 is the first element,
of course.

28
00:01:30,150 --> 00:01:32,830
And remember now we
are using 0, 1.

29
00:01:37,260 --> 00:01:39,970
OK, what is tuple B?

30
00:01:39,970 --> 00:01:42,750
It's a two-dimensional tuple.

31
00:01:42,750 --> 00:01:43,630
AUDIENCE: [INAUDIBLE]

32
00:01:43,630 --> 00:01:44,600
PROFESSOR: Yeah, exactly.

33
00:01:44,600 --> 00:01:46,860
It has a list and
a tuple inside.

34
00:01:46,860 --> 00:01:50,640
So the first element is
a tuple, and the last

35
00:01:50,640 --> 00:01:51,920
element is the list.

36
00:01:51,920 --> 00:01:54,720
So now it's sort of like
two-dimensional.

37
00:01:54,720 --> 00:01:59,960
But if you look at the first
element of it, the MIT word,

38
00:01:59,960 --> 00:02:02,420
that doesn't have
any dimension.

39
00:02:02,420 --> 00:02:04,600
Does it?

40
00:02:04,600 --> 00:02:05,320
It's a string.

41
00:02:05,320 --> 00:02:07,650
So you can again access,
but not this way.

42
00:02:07,650 --> 00:02:08,900
But still you can access.

43
00:02:12,330 --> 00:02:18,360
And we are using this notation
to access a portion of the

44
00:02:18,360 --> 00:02:21,870
list, a part of the tuple,
actually, here.

45
00:02:21,870 --> 00:02:23,770
It's called slicing.

46
00:02:23,770 --> 00:02:27,240
So here 0 to 1 gives
you which element?

47
00:02:29,760 --> 00:02:30,960
Just one element right?

48
00:02:30,960 --> 00:02:32,210
It's the first element.

49
00:02:35,140 --> 00:02:40,790
0 to 2 gives you 1 and 2 OK?

50
00:02:40,790 --> 00:02:45,780
This is an interesting
usage of the slicing.

51
00:02:45,780 --> 00:02:48,695
This is used to access
the whole tuple.

52
00:02:48,695 --> 00:02:50,720
Now you might wonder
why we need them.

53
00:02:50,720 --> 00:02:52,186
We could just--

54
00:02:52,186 --> 00:02:54,920
the handouts are here.

55
00:02:54,920 --> 00:03:00,100
So why we need to copy or why
we need to access the list

56
00:03:00,100 --> 00:03:03,810
through the column operator
like this?

57
00:03:03,810 --> 00:03:04,690
We'll look at that later.

58
00:03:04,690 --> 00:03:09,090
It's very essential when
we have lists.

59
00:03:09,090 --> 00:03:12,610
For the timing it's OK when
tuples are immutable.

60
00:03:12,610 --> 00:03:15,840
So it doesn't have
a special usage.

61
00:03:15,840 --> 00:03:18,310
But later on we'll
be using it.

62
00:03:18,310 --> 00:03:20,650
Then if you look at this
part, this is the

63
00:03:20,650 --> 00:03:22,500
most interesting part.

64
00:03:22,500 --> 00:03:23,850
How do iterate through
a tuple?

65
00:03:26,490 --> 00:03:30,770
You use a FOR loop and you call
like item in tuple, the

66
00:03:30,770 --> 00:03:33,290
element in tuple.

67
00:03:33,290 --> 00:03:37,510
The element is initialized with
every element when it

68
00:03:37,510 --> 00:03:38,990
goes through iteration.

69
00:03:38,990 --> 00:03:44,380
At every iteration it will
be instantiated with the

70
00:03:44,380 --> 00:03:46,580
corresponding element
in the tuple.

71
00:03:46,580 --> 00:03:48,315
But you're using the
same name anyway.

72
00:03:48,315 --> 00:03:49,565
It's item.

73
00:03:51,450 --> 00:03:54,105
This is equivalent to accessing
the tuple like this.

74
00:03:57,760 --> 00:04:00,650
Going one-by-one in the range
and accessing their

75
00:04:00,650 --> 00:04:02,330
corresponding element
in the tuple.

76
00:04:02,330 --> 00:04:05,630
So this is the simpler
way to access that.

77
00:04:05,630 --> 00:04:07,205
Do you have any questions
in that part?

78
00:04:12,940 --> 00:04:14,900
Yeah?

79
00:04:14,900 --> 00:04:17,595
AUDIENCE: For that part, don't,
usually if you have a

80
00:04:17,595 --> 00:04:19,310
range you have to [INAUDIBLE]

81
00:04:19,310 --> 00:04:22,750
name because is not--

82
00:04:22,750 --> 00:04:24,530
PROFESSOR: OK, that's correct.

83
00:04:24,530 --> 00:04:25,610
.

84
00:04:25,610 --> 00:04:27,000
OK.

85
00:04:27,000 --> 00:04:30,040
Suppose a tuple has 3 elements,
or for example in

86
00:04:30,040 --> 00:04:33,130
this case tuple A, how many
elements are in the tuple A?

87
00:04:33,130 --> 00:04:34,250
3 elements.

88
00:04:34,250 --> 00:04:36,265
So what would be the
length of tuple A?

89
00:04:36,265 --> 00:04:36,630
AUDIENCE: 3.

90
00:04:36,630 --> 00:04:37,330
PROFESSOR: 3.

91
00:04:37,330 --> 00:04:39,650
But what would be the range?

92
00:04:39,650 --> 00:04:41,350
0, 1, 2, right?

93
00:04:41,350 --> 00:04:44,470
So you have to type 0 to 3.

94
00:04:44,470 --> 00:04:47,180
So that's why I put that, OK?

95
00:04:47,180 --> 00:04:50,678
That is 3, OK?

96
00:04:50,678 --> 00:04:51,176
PROFESSOR: You.

97
00:04:51,176 --> 00:04:54,247
AUDIENCE: So you just say a
range like the tuple is, it

98
00:04:54,247 --> 00:04:55,170
seems like the first one--

99
00:04:55,170 --> 00:04:57,264
PROFESSOR: First the 0 if you
don't specify it the same way.

100
00:05:08,200 --> 00:05:08,880
OK.

101
00:05:08,880 --> 00:05:10,370
Now let's go through the list.

102
00:05:18,730 --> 00:05:22,620
So if you go through the
questions, what is the

103
00:05:22,620 --> 00:05:24,330
difference between a
list and a tuple?

104
00:05:27,990 --> 00:05:30,293
What is the difference between
a list and a tuple?

105
00:05:30,293 --> 00:05:31,682
Anyone?

106
00:05:31,682 --> 00:05:33,534
Yeah?

107
00:05:33,534 --> 00:05:34,923
AUDIENCE: Tuples
are immutable.

108
00:05:34,923 --> 00:05:35,390
PROFESSOR: OK.

109
00:05:35,390 --> 00:05:36,450
Lists are mutable.

110
00:05:36,450 --> 00:05:41,190
And because it's mutable it
takes special functions to

111
00:05:41,190 --> 00:05:44,470
access the elements,
add elements, and

112
00:05:44,470 --> 00:05:46,220
modify the list itself.

113
00:05:49,210 --> 00:05:51,535
How would you add an
element to a list?

114
00:05:54,370 --> 00:06:05,920
Suppose you have list A. How
would you add 3 to this list?

115
00:06:10,600 --> 00:06:12,472
AUDIENCE: [INAUDIBLE]

116
00:06:12,472 --> 00:06:12,950
PROFESSOR: OK.

117
00:06:12,950 --> 00:06:14,200
Let's start our print.

118
00:06:20,978 --> 00:06:22,120
OK.

119
00:06:22,120 --> 00:06:24,505
That's good.

120
00:06:24,505 --> 00:06:25,755
OK?

121
00:06:30,950 --> 00:06:33,810
How would you remove
the element from

122
00:06:33,810 --> 00:06:34,830
the top of the list?

123
00:06:34,830 --> 00:06:36,480
Or the last element, how
would you remove

124
00:06:36,480 --> 00:06:38,720
this 3 from the list?

125
00:06:42,129 --> 00:06:43,379
AUDIENCE: [INAUDIBLE]

126
00:06:50,900 --> 00:06:52,260
PROFESSOR: This one?

127
00:06:52,260 --> 00:06:53,510
Let's see.

128
00:07:00,598 --> 00:07:04,950
You know how to check
the specification

129
00:07:04,950 --> 00:07:07,270
of a function, right?

130
00:07:07,270 --> 00:07:08,520
Sorry.

131
00:07:15,620 --> 00:07:17,430
So it's not the right
function, right?

132
00:07:17,430 --> 00:07:19,930
Because it says it removes
the first occurrence of a

133
00:07:19,930 --> 00:07:23,380
particular value you are parsing
to that function.

134
00:07:23,380 --> 00:07:25,100
OK, there's another function.

135
00:07:25,100 --> 00:07:26,700
It's called list.pop.

136
00:07:30,860 --> 00:07:34,060
That removes the last inserted
value, so it

137
00:07:34,060 --> 00:07:37,300
pops from the top.

138
00:07:37,300 --> 00:07:40,430
So remove can be used to remove
a particular element.

139
00:07:40,430 --> 00:07:42,890
So here suppose we
want to remove 1.

140
00:07:42,890 --> 00:07:46,340
So we could say list
A, remove 1.

141
00:07:50,116 --> 00:07:51,060
OK.

142
00:07:51,060 --> 00:07:53,200
So in this example,
actually, I have

143
00:07:53,200 --> 00:07:56,150
commented out this line.

144
00:07:56,150 --> 00:07:58,260
This will be an error
if I execute.

145
00:07:58,260 --> 00:07:59,510
Why?

146
00:08:04,480 --> 00:08:06,280
Why will it give you an error?

147
00:08:09,105 --> 00:08:10,480
AUDIENCE: [INAUDIBLE]

148
00:08:10,480 --> 00:08:11,875
PROFESSOR: It doesn't exit.

149
00:08:11,875 --> 00:08:14,110
Great.

150
00:08:14,110 --> 00:08:17,520
So the problem here is we can't
access an element in the

151
00:08:17,520 --> 00:08:20,610
list unless we explicitly
assign

152
00:08:20,610 --> 00:08:23,450
something or create something.

153
00:08:23,450 --> 00:08:28,720
But suppose we want to pass
a list of 10 elements to a

154
00:08:28,720 --> 00:08:31,770
program so that it can assign
values on the fly.

155
00:08:31,770 --> 00:08:33,490
And it can modify.

156
00:08:33,490 --> 00:08:34,299
OK?

157
00:08:34,299 --> 00:08:38,133
So how would you pass an empty
list of 10 elements?

158
00:08:41,235 --> 00:08:42,179
OK.

159
00:08:42,179 --> 00:08:44,800
The problem is if you're passing
something like this,

160
00:08:44,800 --> 00:08:50,850
you need to know how this list
should be instantiated.

161
00:08:50,850 --> 00:08:54,080
So you should know what
are the initial

162
00:08:54,080 --> 00:08:57,090
values of these elements.

163
00:08:57,090 --> 00:09:01,610
Suppose you want to create
a list of ten 0's.

164
00:09:01,610 --> 00:09:03,670
Then the easiest way to
create the list is--

165
00:09:09,070 --> 00:09:12,220
So you would create a list
with ten elements.

166
00:09:12,220 --> 00:09:15,670
But If you don't want to waste
memory, or if you don't want

167
00:09:15,670 --> 00:09:18,790
to keep anything particular,
you could do

168
00:09:18,790 --> 00:09:20,040
something like this.

169
00:09:24,730 --> 00:09:29,210
Now this will create a
list of empty list.

170
00:09:29,210 --> 00:09:32,490
And there'll be ten
such empty lists.

171
00:09:32,490 --> 00:09:34,390
OK?

172
00:09:34,390 --> 00:09:37,090
And you could pass this list to
a program so that it will

173
00:09:37,090 --> 00:09:38,340
assign the elements.

174
00:09:40,930 --> 00:09:41,760
OK?

175
00:09:41,760 --> 00:09:45,900
You can iterate to the
list the same way.

176
00:09:45,900 --> 00:09:48,010
But lists are interesting.

177
00:09:48,010 --> 00:09:48,440
Why?

178
00:09:48,440 --> 00:09:49,870
They are mutable.

179
00:09:49,870 --> 00:09:53,370
So they can be actually used
to create interesting

180
00:09:53,370 --> 00:09:54,870
mathematical objects.

181
00:09:54,870 --> 00:09:58,070
For example, like matrix.

182
00:09:58,070 --> 00:10:00,330
So how would you create
a matrix using lists?

183
00:10:03,230 --> 00:10:04,390
Any ideas?

184
00:10:04,390 --> 00:10:06,610
How would you create,
say a 2 by 2 matrix?

185
00:10:11,280 --> 00:10:17,160
If you consider this example,
this creates a matrix 4 by 2.

186
00:10:20,370 --> 00:10:23,495
So that would be like 4
rows and 2 columns.

187
00:10:26,790 --> 00:10:31,310
But how can you go and
access the inner

188
00:10:31,310 --> 00:10:33,870
element or inner matrix?

189
00:10:33,870 --> 00:10:37,070
So if you suppose you want
access 2, 3, that is the third

190
00:10:37,070 --> 00:10:39,570
row, then how would
you access?

191
00:10:42,870 --> 00:10:45,220
How would you call M?

192
00:10:48,391 --> 00:10:48,850
AUDIENCE: M3?

193
00:10:48,850 --> 00:10:50,700
PROFESSOR: M3.

194
00:10:50,700 --> 00:10:53,200
M3 gives you 2, 3.

195
00:10:53,200 --> 00:10:58,190
Suppose you want to access
the 3 and the 2, 3.

196
00:10:58,190 --> 00:10:58,650
Then we--

197
00:10:58,650 --> 00:10:59,570
[INTERPOSING VOICES]

198
00:10:59,570 --> 00:11:01,508
PROFESSOR: Sorry.

199
00:11:01,508 --> 00:11:04,610
AUDIENCE: Why does a 3
give you [INAUDIBLE]?

200
00:11:04,610 --> 00:11:06,270
PROFESSOR: Oh, sorry.

201
00:11:06,270 --> 00:11:07,520
My bad.

202
00:11:11,440 --> 00:11:11,920
Yeah.

203
00:11:11,920 --> 00:11:12,400
OK.

204
00:11:12,400 --> 00:11:13,920
This is computer science,
not maths.

205
00:11:17,240 --> 00:11:19,040
You got it right, why
it's not 3, it's 2?

206
00:11:19,040 --> 00:11:19,496
AUDIENCE: Yeah.

207
00:11:19,496 --> 00:11:21,320
I thought you were talking
about 3 and 4.

208
00:11:21,320 --> 00:11:21,652
PROFESSOR: OK.

209
00:11:21,652 --> 00:11:22,430
That's fine.

210
00:11:22,430 --> 00:11:25,520
So I'm asking now how
would you access the

211
00:11:25,520 --> 00:11:29,482
3 in the 2, 3 box?

212
00:11:29,482 --> 00:11:33,258
AUDIENCE: So I need to do
another parentheses?

213
00:11:33,258 --> 00:11:33,730
PROFESSOR: Not a bracket.

214
00:11:33,730 --> 00:11:34,202
AUDIENCE: OK.

215
00:11:34,202 --> 00:11:35,620
PROFESSOR: OK.

216
00:11:35,620 --> 00:11:38,390
That is all.

217
00:11:38,390 --> 00:11:42,290
So you can access matrices
like this.

218
00:11:45,454 --> 00:11:45,910
OK.

219
00:11:45,910 --> 00:11:47,765
Great.

220
00:11:47,765 --> 00:11:49,015
We are on time.

221
00:11:59,870 --> 00:12:02,990
So this actually gives you
a summary of functions.

222
00:12:02,990 --> 00:12:05,170
Associated functions.

223
00:12:05,170 --> 00:12:07,930
For example the pop I
explained earlier.

224
00:12:07,930 --> 00:12:10,810
Remove removes a particular
element.

225
00:12:10,810 --> 00:12:14,080
Extent, that's interesting.

226
00:12:14,080 --> 00:12:17,640
Can you tell me what
it does here, the

227
00:12:17,640 --> 00:12:19,590
method extent on list?

228
00:12:36,880 --> 00:12:38,757
What does that method take?

229
00:12:42,030 --> 00:12:44,640
It takes another list.

230
00:12:44,640 --> 00:12:49,660
So which means it's going to
merge the list you are passing

231
00:12:49,660 --> 00:12:52,460
with the list you're calling
the method on, that is

232
00:12:52,460 --> 00:12:54,000
[UNINTELLIGIBLE].

233
00:12:54,000 --> 00:12:56,430
So it's going to combine
those lists.

234
00:12:56,430 --> 00:12:57,680
Let's see.

235
00:13:04,440 --> 00:13:06,705
So this corresponds to this.

236
00:13:09,590 --> 00:13:10,965
So two lists are combined.

237
00:13:13,720 --> 00:13:16,300
So this method is actually
useful, right, because you

238
00:13:16,300 --> 00:13:17,750
don't have to write yourself.

239
00:13:17,750 --> 00:13:19,580
Most of things you
can easily do.

240
00:13:19,580 --> 00:13:23,965
Now the question is, why tuple
didn't have these methods?

241
00:13:26,640 --> 00:13:27,890
Why?

242
00:13:30,040 --> 00:13:33,946
Why we didn't have these
methods for tuples?

243
00:13:33,946 --> 00:13:34,850
AUDIENCE: [INAUDIBLE]

244
00:13:34,850 --> 00:13:35,680
PROFESSOR: They're immutable.

245
00:13:35,680 --> 00:13:37,160
So you can't extent, you
can't [UNINTELLIGIBLE].

246
00:13:37,160 --> 00:13:39,360
So even if you extent,
what would happen?

247
00:13:39,360 --> 00:13:41,861
It's going to create
a new tuple.

248
00:13:41,861 --> 00:13:43,520
Actually, you can do that.

249
00:13:43,520 --> 00:13:44,420
But like this.

250
00:13:44,420 --> 00:13:50,860
For example, you have tuple
A which is 1, 2.

251
00:13:50,860 --> 00:13:54,470
And suppose you have
tuple B --

252
00:13:54,470 --> 00:13:55,960
3, 4.

253
00:13:55,960 --> 00:13:58,610
If you want to combine them,
how would you do it?

254
00:14:01,440 --> 00:14:07,500
Tuple A plus tuple B. OK?

255
00:14:07,500 --> 00:14:09,150
That concatenates.

256
00:14:09,150 --> 00:14:13,256
This operator is all
loaded for tuples.

257
00:14:13,256 --> 00:14:14,506
OK?

258
00:14:20,680 --> 00:14:24,810
So lists are mutable so you can
do all of these things.

259
00:14:24,810 --> 00:14:26,380
Let's look at a few other
examples, too.

260
00:14:51,590 --> 00:14:52,840
OK.

261
00:14:55,230 --> 00:14:58,100
There's an interesting
part here.

262
00:14:58,100 --> 00:14:59,310
Lists are mutable.

263
00:14:59,310 --> 00:15:00,950
That we understand.

264
00:15:00,950 --> 00:15:08,970
But how these lists are actually
stored in the memory,

265
00:15:08,970 --> 00:15:14,360
For example, suppose you
have a list lst,

266
00:15:14,360 --> 00:15:17,103
sorry, 0, 1, apple.

267
00:15:21,180 --> 00:15:22,920
How do you think it's stored
in the memory?

268
00:15:27,080 --> 00:15:28,965
So you have 3 elements.

269
00:15:28,965 --> 00:15:31,770
But these elements are actually
not stored in the

270
00:15:31,770 --> 00:15:34,570
list itself.

271
00:15:34,570 --> 00:15:36,560
They actually in the memory.

272
00:15:36,560 --> 00:15:37,810
0, 1, apple.

273
00:15:40,920 --> 00:15:44,260
But you have the pointers
to those lists.

274
00:15:44,260 --> 00:15:48,000
Sorry, to those elements.

275
00:15:48,000 --> 00:15:53,480
So actually you can modify these
values without changing

276
00:15:53,480 --> 00:15:57,625
the list itself, because the
list actually points to this

277
00:15:57,625 --> 00:16:00,970
part, the container.

278
00:16:00,970 --> 00:16:06,220
So in this example you have list
A and B. But the list B

279
00:16:06,220 --> 00:16:09,780
actually contains list A. OK?

280
00:16:09,780 --> 00:16:15,340
Since list A is mutable you
can go and change it.

281
00:16:15,340 --> 00:16:18,970
So here first you print list A
and B, but you're going to

282
00:16:18,970 --> 00:16:21,020
change list A's 0th element.

283
00:16:24,800 --> 00:16:30,290
After changing the element
the list A becomes first.

284
00:16:30,290 --> 00:16:34,730
Its first element
changed to 88.

285
00:16:34,730 --> 00:16:35,980
OK.

286
00:16:37,890 --> 00:16:40,480
Fine.

287
00:16:40,480 --> 00:16:42,420
What do you think the
list B would be?

288
00:16:48,252 --> 00:16:49,502
OK, let's print.

289
00:16:55,270 --> 00:16:58,900
It contains the 88, right,
the modified value.

290
00:16:58,900 --> 00:17:00,150
Why?

291
00:17:02,540 --> 00:17:12,280
Because list B actually had a
pointer to list A. Which again

292
00:17:12,280 --> 00:17:14,859
had pointers to other
elements.

293
00:17:14,859 --> 00:17:18,410
And we modified this
value to 88.

294
00:17:18,410 --> 00:17:22,339
So you're still accessing
list B. OK?

295
00:17:22,339 --> 00:17:26,170
The pointers are not changed.

296
00:17:26,170 --> 00:17:28,890
That we can see here, in
the second example,

297
00:17:28,890 --> 00:17:31,230
the problem of aliasing.

298
00:17:31,230 --> 00:17:37,270
So we have list X. And we call
it by list Y as well.

299
00:17:37,270 --> 00:17:42,110
And we are now changing
the list Y. Sorry.

300
00:17:42,110 --> 00:17:45,850
We are changing the list X. But
it's going to affect list

301
00:17:45,850 --> 00:17:51,740
X as well as list Y. See?

302
00:17:51,740 --> 00:17:54,360
Because it's just a reference.

303
00:17:54,360 --> 00:17:57,170
The actual object is this.

304
00:17:57,170 --> 00:17:59,000
You can call it by two
different names.

305
00:17:59,000 --> 00:17:59,570
It doesn't matter.

306
00:17:59,570 --> 00:18:00,820
But the actual object is here.

307
00:18:05,150 --> 00:18:07,315
That's where we need
this operator.

308
00:18:10,970 --> 00:18:15,640
So if you just point, OK, for
example we had list X, if you

309
00:18:15,640 --> 00:18:20,000
just assign list Y to list X,
it's not going to copy the

310
00:18:20,000 --> 00:18:23,170
elements, just going to
copy the reference.

311
00:18:23,170 --> 00:18:29,250
Which means list X and list Y,
both would be pointing to the

312
00:18:29,250 --> 00:18:32,420
same object.

313
00:18:32,420 --> 00:18:39,370
If you want to copy these
elements and put in a new one,

314
00:18:39,370 --> 00:18:45,300
say, list Z, then we need to
copy one-by-one every element.

315
00:18:45,300 --> 00:18:49,690
For that we can use
this operator.

316
00:18:49,690 --> 00:18:50,940
It's called full slicing.

317
00:18:53,700 --> 00:18:55,860
It's not going to
modify elements.

318
00:18:55,860 --> 00:18:58,955
It's going to copy the whole
list of elements.

319
00:19:15,360 --> 00:19:24,700
And in the same line, just
another small example that

320
00:19:24,700 --> 00:19:28,640
tells you how to cast a
list into tuple, and

321
00:19:28,640 --> 00:19:29,890
a tuple into list.

322
00:19:45,370 --> 00:19:49,120
So you had a tuple, one for
apple [UNINTELLIGIBLE]

323
00:19:49,120 --> 00:19:51,170
and you cast into list.

324
00:19:51,170 --> 00:19:52,515
Now the type is list.

325
00:19:55,330 --> 00:19:57,150
It's a very simple operation.

326
00:19:57,150 --> 00:20:00,250
Can you do that yourself?

327
00:20:00,250 --> 00:20:03,470
How would you do it if you want
to write a function to

328
00:20:03,470 --> 00:20:07,420
cast, how would you do that?

329
00:20:07,420 --> 00:20:11,810
You go through element by
element and add it to a tuple.

330
00:20:11,810 --> 00:20:14,790
And then concatentae
two tuples.

331
00:20:14,790 --> 00:20:17,350
Right?

332
00:20:17,350 --> 00:20:19,350
So I guess you can write
probably as a

333
00:20:19,350 --> 00:20:21,340
homework, try that.

334
00:20:21,340 --> 00:20:26,380
Try how to convert a list to
a tuple without explicitly

335
00:20:26,380 --> 00:20:29,385
calling the casting function.

336
00:20:29,385 --> 00:20:30,780
OK.

337
00:20:30,780 --> 00:20:33,540
Similarly you can convert
a tuple back into list.

338
00:20:36,640 --> 00:20:38,490
So it's pretty straightforward.

339
00:20:38,490 --> 00:20:40,530
And suppose you're getting
an input from

340
00:20:40,530 --> 00:20:42,020
the user as a tuple.

341
00:20:42,020 --> 00:20:43,970
then suppose you want
to make it a list.

342
00:20:43,970 --> 00:20:45,350
You don't have to write
your function.

343
00:20:45,350 --> 00:20:48,940
You can just call this
casting operator.

344
00:20:48,940 --> 00:20:51,130
So it'll be--

345
00:20:51,130 --> 00:20:53,690
it will save some time.

346
00:20:53,690 --> 00:20:53,980
OK.

347
00:20:53,980 --> 00:20:56,470
Great.

348
00:20:56,470 --> 00:20:57,960
Let's go to our dictionaries
now.

349
00:21:05,930 --> 00:21:10,030
So we have a third data
type, dictionaries.

350
00:21:10,030 --> 00:21:11,280
Oh, you didn't get
the second one?

351
00:21:18,490 --> 00:21:21,740
So we have another data
type, dictionaries.

352
00:21:21,740 --> 00:21:24,210
And why do we need dictionaries

353
00:21:24,210 --> 00:21:26,050
in the first place?

354
00:21:26,050 --> 00:21:28,010
Do we need another data type?

355
00:21:28,010 --> 00:21:32,320
Can we just get away with
tuple and list?

356
00:21:32,320 --> 00:21:33,120
Yes.

357
00:21:33,120 --> 00:21:38,520
Because you can actually make
a dictionary out of lists.

358
00:21:38,520 --> 00:21:43,400
And Professor Grimson went
through that in the lecture.

359
00:21:43,400 --> 00:21:45,960
If you want, you can come and
ask in the office hours.

360
00:21:45,960 --> 00:21:49,440
But first try whether you
can do it yourself.

361
00:21:49,440 --> 00:21:55,520
But the problem is, actually not
just the dictionaries, but

362
00:21:55,520 --> 00:21:58,370
the high-level data structures
are actually available in

363
00:21:58,370 --> 00:22:03,420
Python as building data
structures or as classes.

364
00:22:03,420 --> 00:22:07,310
Just because they will have
these methods on these data

365
00:22:07,310 --> 00:22:08,980
structures implemented.

366
00:22:08,980 --> 00:22:11,180
So it would say some
time for us.

367
00:22:11,180 --> 00:22:15,720
Plus those methods are
guaranteed to be state of art.

368
00:22:15,720 --> 00:22:18,747
For example, if you want to go
through all the lists, then

369
00:22:18,747 --> 00:22:23,200
the search function or the
lookup function that you write

370
00:22:23,200 --> 00:22:25,760
may not be that efficient,
right?

371
00:22:25,760 --> 00:22:28,040
But they might use those
efficient algorithms in the

372
00:22:28,040 --> 00:22:29,290
standard implementation.

373
00:22:29,290 --> 00:22:32,660
So it's why you should
always look for the

374
00:22:32,660 --> 00:22:34,420
standard data types.

375
00:22:34,420 --> 00:22:36,880
If you can't you can
write yourself one.

376
00:22:36,880 --> 00:22:40,510
But it's good to use the
available data types so that

377
00:22:40,510 --> 00:22:44,270
they would have this efficient
method implemented.

378
00:22:44,270 --> 00:22:45,910
OK.

379
00:22:45,910 --> 00:22:54,310
So in this dictionary,
we have two elements.

380
00:22:54,310 --> 00:22:57,520
One is key, one is value.

381
00:22:57,520 --> 00:22:58,980
OK?

382
00:22:58,980 --> 00:23:02,130
So these keys actually have
a special property.

383
00:23:02,130 --> 00:23:04,650
What is that?

384
00:23:04,650 --> 00:23:12,360
The keys should be an
immutable object.

385
00:23:12,360 --> 00:23:15,930
So you can actually have
a tuple as a key.

386
00:23:15,930 --> 00:23:20,310
You can have a string as a key,
but not a list as a key.

387
00:23:20,310 --> 00:23:25,270
So you need an immutable
object for the keys.

388
00:23:25,270 --> 00:23:27,685
What about the values?

389
00:23:27,685 --> 00:23:30,040
They can be anything.

390
00:23:30,040 --> 00:23:33,230
Values can be even
a dictionary.

391
00:23:33,230 --> 00:23:34,935
It can be a list.

392
00:23:34,935 --> 00:23:36,950
But the keys must be mutable.

393
00:23:40,160 --> 00:23:42,110
Do these keys need
to be unique?

394
00:23:47,400 --> 00:23:49,370
Yes.

395
00:23:49,370 --> 00:23:51,264
No?

396
00:23:51,264 --> 00:23:52,760
OK.

397
00:23:52,760 --> 00:23:54,010
The problem is this.

398
00:23:56,610 --> 00:24:00,430
Dictionaries have the same
type, I mean structure.

399
00:24:05,340 --> 00:24:08,320
This is a key.

400
00:24:08,320 --> 00:24:11,690
And this key points to a
place in the memory.

401
00:24:11,690 --> 00:24:16,060
Suppose you call it key A. OK?

402
00:24:16,060 --> 00:24:20,770
If you assign another value to
key A, that will actually

403
00:24:20,770 --> 00:24:23,890
replace the content in
the memory, right?

404
00:24:23,890 --> 00:24:27,560
So that's why keys are going
to be unique, It's by

405
00:24:27,560 --> 00:24:31,850
construction, by the
construction of the dictionary

406
00:24:31,850 --> 00:24:34,540
the keys are going
to be unique.

407
00:24:34,540 --> 00:24:37,370
Because if you want to assign
something different, you have

408
00:24:37,370 --> 00:24:41,040
to call it by a different key,
call it by a different name.

409
00:24:41,040 --> 00:24:47,240
Say key B.

410
00:24:47,240 --> 00:24:48,490
What about the values.

411
00:24:50,600 --> 00:24:52,037
Do they need to be unique?

412
00:24:52,037 --> 00:24:54,030
No, of course.

413
00:24:54,030 --> 00:24:57,450
Otherwise no use of key, and no
use of dictionaries, right?

414
00:24:57,450 --> 00:25:02,010
What is the order of the items
stored in the dictionary?

415
00:25:02,010 --> 00:25:05,460
Can you give a guarantee
like in lists?

416
00:25:05,460 --> 00:25:09,490
In lists items are stored from
zero to the left, right?

417
00:25:09,490 --> 00:25:11,670
Length minus 1, actually.

418
00:25:11,670 --> 00:25:13,410
What about dictionaries?

419
00:25:13,410 --> 00:25:16,280
Surely can't guarantee
the order, but you

420
00:25:16,280 --> 00:25:18,192
can modify the order.

421
00:25:18,192 --> 00:25:19,330
OK.

422
00:25:19,330 --> 00:25:23,800
So the thing is first, if you
look at this example, first we

423
00:25:23,800 --> 00:25:27,990
have the staff dictionary.

424
00:25:27,990 --> 00:25:33,040
And when I pin the length
it gives me 3, fine.

425
00:25:33,040 --> 00:25:34,820
Then I'm doing three things.

426
00:25:34,820 --> 00:25:42,540
First I change the address
by calling its key.

427
00:25:42,540 --> 00:25:44,590
And dictionaries are
mutable so you can

428
00:25:44,590 --> 00:25:45,840
change their values.

429
00:25:48,220 --> 00:25:50,950
Then also we are adding
a new element.

430
00:25:50,950 --> 00:25:52,190
Fine.

431
00:25:52,190 --> 00:25:54,840
If you wanted a new element you
call it by the key that

432
00:25:54,840 --> 00:25:56,130
you already assigned.

433
00:25:56,130 --> 00:26:00,000
If the key already exists you
will just modify the value.

434
00:26:00,000 --> 00:26:04,160
Otherwise it will create a new
key and add that value.

435
00:26:04,160 --> 00:26:07,080
You can also check whether this
particular element is in

436
00:26:07,080 --> 00:26:09,120
the dictionary.

437
00:26:09,120 --> 00:26:11,320
But this must be the key.

438
00:26:11,320 --> 00:26:12,660
Whatever you are calling
here should be the

439
00:26:12,660 --> 00:26:13,820
key, not the value.

440
00:26:13,820 --> 00:26:15,550
It won't search for the value.

441
00:26:15,550 --> 00:26:17,070
It will search only for the
key, [UNINTELLIGIBLE]

442
00:26:17,070 --> 00:26:19,705
for that particular key because
you access the values

443
00:26:19,705 --> 00:26:20,955
through keys.

444
00:26:23,080 --> 00:26:25,920
Again here if it is not
in the list, actually

445
00:26:25,920 --> 00:26:29,410
I'm adding an element--

446
00:26:29,410 --> 00:26:30,660
OK.

447
00:26:35,680 --> 00:26:36,020
OK.

448
00:26:36,020 --> 00:26:42,660
To compare in the list, suppose
I have a list 0, 1, 2.

449
00:26:45,460 --> 00:26:48,750
If I want to check whether
1 is in the

450
00:26:48,750 --> 00:26:50,310
list, how would I check?

451
00:26:53,050 --> 00:26:55,370
Do you have to go through
element by element?

452
00:26:55,370 --> 00:26:57,850
No, there's a shortcut.

453
00:26:57,850 --> 00:27:05,340
If 1 in list, right?

454
00:27:05,340 --> 00:27:08,530
If I want to check whether 1 is
not in the list, if I want

455
00:27:08,530 --> 00:27:16,240
to negate this, I would write
it 1 not in list.

456
00:27:16,240 --> 00:27:17,380
We just ignore the words.

457
00:27:17,380 --> 00:27:19,898
It's pretty much like English.

458
00:27:19,898 --> 00:27:20,730
OK?

459
00:27:20,730 --> 00:27:22,660
We just remove the words.

460
00:27:22,660 --> 00:27:24,360
OK.

461
00:27:24,360 --> 00:27:29,360
In the dictionary we do the
same thing through keys.

462
00:27:29,360 --> 00:27:35,530
If key A and, OK I'll
call it, say, D1.

463
00:27:41,402 --> 00:27:42,340
OK?

464
00:27:42,340 --> 00:27:46,260
And you actually call or you'd
search for the key,

465
00:27:46,260 --> 00:27:47,510
not the other way.

466
00:27:58,550 --> 00:27:59,560
OK.

467
00:27:59,560 --> 00:28:03,140
There is an interesting
part here.

468
00:28:03,140 --> 00:28:04,890
If you want to modify
the order--

469
00:28:04,890 --> 00:28:08,420
actually I tell you that the
order C earlier, we couldn't

470
00:28:08,420 --> 00:28:11,950
guarantee the order, right?

471
00:28:11,950 --> 00:28:15,860
It was not the order we typed
because it starts at

472
00:28:15,860 --> 00:28:17,800
[UNINTELLIGIBLE]

473
00:28:17,800 --> 00:28:20,530
because we added at the
end actually, right?

474
00:28:20,530 --> 00:28:22,640
So actually you can't
guarantee the order.

475
00:28:22,640 --> 00:28:25,370
But we can sort it.

476
00:28:25,370 --> 00:28:27,420
But how do you sort it?

477
00:28:27,420 --> 00:28:32,280
We call the keys and
we sort the keys.

478
00:28:32,280 --> 00:28:36,020
Because remember,
every values--

479
00:28:36,020 --> 00:28:38,180
if you want to access a
particular value, you access

480
00:28:38,180 --> 00:28:39,750
it through key.

481
00:28:39,750 --> 00:28:42,730
Actually, if you call the
dictionary, it doesn't know

482
00:28:42,730 --> 00:28:44,280
where these values are.

483
00:28:44,280 --> 00:28:47,460
Just you have to go to the
key to access the value.

484
00:28:47,460 --> 00:28:50,910
So if you want to do something
in the dictionary itself, you

485
00:28:50,910 --> 00:28:53,340
can do that only on keys.

486
00:28:53,340 --> 00:28:54,670
So if you want to sort
the dictionary,

487
00:28:54,670 --> 00:28:56,520
you sort it by keys.

488
00:28:56,520 --> 00:29:01,400
So you call the keys method
for the dictionary--

489
00:29:01,400 --> 00:29:06,450
so it returns the list of
keys and you sort them.

490
00:29:09,070 --> 00:29:10,690
This is called chaining
methods.

491
00:29:10,690 --> 00:29:13,160
So I have chained the methods.

492
00:29:13,160 --> 00:29:15,350
I would have like two
methods, right?

493
00:29:15,350 --> 00:29:17,100
I call the keys.

494
00:29:17,100 --> 00:29:20,900
This first part actually returns
to this top key.

495
00:29:20,900 --> 00:29:22,830
Then you sort them.

496
00:29:22,830 --> 00:29:23,851
Yes?

497
00:29:23,851 --> 00:29:27,080
AUDIENCE: It doesn't look like
they're in alphabetical order?

498
00:29:27,080 --> 00:29:27,705
PROFESSOR: Oh, on this?

499
00:29:27,705 --> 00:29:28,955
Sorry.

500
00:29:32,600 --> 00:29:33,850
Let's see.

501
00:29:40,670 --> 00:29:41,150
OK.

502
00:29:41,150 --> 00:29:42,400
Let's see.

503
00:29:55,550 --> 00:29:56,800
Ooops.

504
00:30:03,370 --> 00:30:03,950
OK.

505
00:30:03,950 --> 00:30:05,200
Now they're sorted.

506
00:30:07,730 --> 00:30:09,190
OK.

507
00:30:09,190 --> 00:30:12,160
What was the problem?

508
00:30:12,160 --> 00:30:14,160
What was the problem there?

509
00:30:14,160 --> 00:30:16,030
Why it wasn't sorted?

510
00:30:16,030 --> 00:30:17,790
AUDIENCE: You have to
do it in two lines.

511
00:30:17,790 --> 00:30:18,240
PROFESSOR: Sorry?

512
00:30:18,240 --> 00:30:21,802
AUDIENCE: You have to call up
the keys and then sort it in a

513
00:30:21,802 --> 00:30:24,300
separate line?

514
00:30:24,300 --> 00:30:25,810
PROFESSOR: OK.

515
00:30:25,810 --> 00:30:29,830
The problem is in the logic.

516
00:30:29,830 --> 00:30:32,560
Actually, when you call this
function, method, you're

517
00:30:32,560 --> 00:30:35,650
actually sorting the keys
returned by this method.

518
00:30:35,650 --> 00:30:40,290
You're not actually going to
sort of the dictionary itself.

519
00:30:40,290 --> 00:30:44,820
You're sorting only the list
that was returned, right?

520
00:30:44,820 --> 00:30:47,230
The list of keys.

521
00:30:47,230 --> 00:30:53,200
Although the dictionary is
mutable, it wasn't sorted.

522
00:30:53,200 --> 00:30:54,720
Do you see the problem?

523
00:30:54,720 --> 00:30:59,230
So that's why when they called
keys equal to staff.keys I'm

524
00:30:59,230 --> 00:31:02,190
getting a list of keys.

525
00:31:02,190 --> 00:31:05,000
Then I'm sorting that list.

526
00:31:05,000 --> 00:31:08,180
And I'm printing that list.

527
00:31:08,180 --> 00:31:12,820
But if you want to go in a
particular order, if you want

528
00:31:12,820 --> 00:31:15,230
to access the dictionary in a
particular order, what could

529
00:31:15,230 --> 00:31:24,380
you do is you could do something
like keys is equal

530
00:31:24,380 --> 00:31:25,630
to staff.keys.

531
00:31:28,280 --> 00:31:29,530
Then you can store keys.

532
00:31:34,430 --> 00:31:40,880
Then for k in keys you can go
and iterate now, right?

533
00:31:40,880 --> 00:31:47,560
So you can say print
k and staff k.

534
00:31:47,560 --> 00:31:49,500
OK?

535
00:31:49,500 --> 00:31:51,770
So you can do this.

536
00:31:51,770 --> 00:31:56,770
But actually, Python provides a
way to iterate what keys and

537
00:31:56,770 --> 00:31:58,020
value pairs.

538
00:32:00,540 --> 00:32:07,660
That you do by calling
both elements?

539
00:32:07,660 --> 00:32:09,730
All the method items.

540
00:32:09,730 --> 00:32:16,040
The items return a list
of key-value pairs.

541
00:32:19,650 --> 00:32:27,530
If you call D1.items you get
a list of key-value pairs.

542
00:32:35,250 --> 00:32:38,210
You see that?

543
00:32:38,210 --> 00:32:42,740
And we are going to iterate
through individual elements.

544
00:32:42,740 --> 00:32:46,190
So first we start with this
and then second this.

545
00:32:46,190 --> 00:32:49,560
So that's a simpler way to
access every elements in the

546
00:32:49,560 --> 00:32:51,448
dictionary.

547
00:32:51,448 --> 00:32:52,698
Great.

548
00:32:59,384 --> 00:33:02,360
OK.

549
00:33:02,360 --> 00:33:04,680
Now we have an interesting
part, recursion.

550
00:33:13,780 --> 00:33:17,040
What's the principle
behind recursion?

551
00:33:17,040 --> 00:33:18,290
Anyone?

552
00:33:21,140 --> 00:33:22,390
What's the idea of recursion?

553
00:33:25,320 --> 00:33:25,720
Yes?

554
00:33:25,720 --> 00:33:28,929
AUDIENCE: The cause itself
is [INAUDIBLE]

555
00:33:28,929 --> 00:33:29,875
base case.

556
00:33:29,875 --> 00:33:32,240
And it saves a lot of money.

557
00:33:32,240 --> 00:33:35,160
PROFESSOR: Yes.

558
00:33:35,160 --> 00:33:38,890
The idea of recursion is, if
you have a problem, try to

559
00:33:38,890 --> 00:33:41,170
express the problem
in a simpler

560
00:33:41,170 --> 00:33:43,090
version of the same problem.

561
00:33:43,090 --> 00:33:47,260
So if you want to find factorial
n, try to express it

562
00:33:47,260 --> 00:33:49,530
in terms of factorial
n minus 1.

563
00:33:49,530 --> 00:33:52,940
So you could keep on doing
this till you come to

564
00:33:52,940 --> 00:33:56,828
factorial 1 for which you know
the explicit answer.

565
00:33:56,828 --> 00:33:57,700
Right?

566
00:33:57,700 --> 00:34:02,000
So you try to express the
problem in its simpler form.

567
00:34:02,000 --> 00:34:05,340
It would be useful
in many cases.

568
00:34:05,340 --> 00:34:09,060
Actually, in your next piece
you do have the problem.

569
00:34:09,060 --> 00:34:12,540
But be mindful.

570
00:34:12,540 --> 00:34:14,000
What's --

571
00:34:14,000 --> 00:34:19,000
what makes it possible for
you to use the recursion?

572
00:34:19,000 --> 00:34:21,840
Only if you can express in terms
of the simpler version.

573
00:34:21,840 --> 00:34:23,860
Otherwise you can't.

574
00:34:23,860 --> 00:34:26,600
This is probably quite like the
induction you might have

575
00:34:26,600 --> 00:34:28,010
studied, mathematical
induction.

576
00:34:28,010 --> 00:34:29,870
I don't know whether you studied
it in high school, but

577
00:34:29,870 --> 00:34:32,170
it's quite like that.

578
00:34:32,170 --> 00:34:34,889
OK.

579
00:34:34,889 --> 00:34:38,389
So there are two parts
in recursion.

580
00:34:38,389 --> 00:34:39,925
The first one is
the base case.

581
00:34:43,340 --> 00:34:53,310
So for a factorial problem we
can express the factorial, say

582
00:34:53,310 --> 00:35:01,530
nth factorial, as any n in
to n minus 1 factorial.

583
00:35:01,530 --> 00:35:03,660
OK?

584
00:35:03,660 --> 00:35:07,050
So this would be our
recursive case.

585
00:35:07,050 --> 00:35:08,740
So what is a recursive case?

586
00:35:14,880 --> 00:35:23,330
Suppose we want to define a
function factorial A. OK?

587
00:35:23,330 --> 00:35:26,042
So what will be our
recursive case?

588
00:35:26,042 --> 00:35:27,292
AUDIENCE: A is greater than 0?

589
00:35:29,270 --> 00:35:30,750
PROFESSOR: I'm asking the
recursive function.

590
00:35:30,750 --> 00:35:32,682
What would be that?

591
00:35:32,682 --> 00:35:33,932
AUDIENCE: [INAUDIBLE]

592
00:35:37,300 --> 00:35:38,550
PROFESSOR: n into 2.

593
00:35:42,350 --> 00:35:45,690
Factorial n minus 1 right?

594
00:35:45,690 --> 00:35:46,950
And you just return this.

595
00:35:50,120 --> 00:35:51,370
What would be your base case?

596
00:35:56,460 --> 00:36:01,070
If n is equal to 0, we know
factorial 0 is 1, right?

597
00:36:06,260 --> 00:36:12,090
What is factorial of 1?

598
00:36:15,750 --> 00:36:17,000
1.

599
00:36:25,420 --> 00:36:27,910
OK?

600
00:36:27,910 --> 00:36:30,020
But why in this program
we didn't have

601
00:36:30,020 --> 00:36:31,270
that particular line.

602
00:36:34,010 --> 00:36:37,340
Why we didn't have n equals 1?

603
00:36:37,340 --> 00:36:38,595
Why we didn't have that?

604
00:36:42,960 --> 00:36:45,385
AUDIENCE: Because it
always goes to 0?

605
00:36:45,385 --> 00:36:47,100
PROFESSOR: It always
goes 0, right?

606
00:36:47,100 --> 00:36:51,000
Because you can express 1 in
terms of 0 as well, right?

607
00:36:51,000 --> 00:36:53,320
So you don't need to actually
write this explicitly.

608
00:36:53,320 --> 00:36:54,840
Why?

609
00:36:54,840 --> 00:36:57,780
Because your recursive function
only depends on its

610
00:36:57,780 --> 00:36:59,360
previous value.

611
00:36:59,360 --> 00:37:03,760
So you need only one value in
advance Which means you need

612
00:37:03,760 --> 00:37:05,200
only one value for
your base case.

613
00:37:08,830 --> 00:37:12,140
So you can understand
this program, right?

614
00:37:12,140 --> 00:37:13,550
I'm not going to go
through that.

615
00:37:13,550 --> 00:37:16,040
But anyway when you write
a program always

616
00:37:16,040 --> 00:37:17,760
check its base case.

617
00:37:17,760 --> 00:37:21,470
So you have to start with
factorial 0 for this case.

618
00:37:21,470 --> 00:37:21,920
OK?

619
00:37:21,920 --> 00:37:23,140
And check one by one.

620
00:37:23,140 --> 00:37:24,790
Then you would know whether
the program is running

621
00:37:24,790 --> 00:37:26,100
correctly or not.

622
00:37:26,100 --> 00:37:27,985
So always start with
a simpler case.

623
00:37:31,130 --> 00:37:32,910
But remember in Fibonacci
series.

624
00:37:36,531 --> 00:37:40,220
OK. for Fibonacci series
can you give me

625
00:37:40,220 --> 00:37:41,470
the recursive function.?

626
00:37:44,270 --> 00:37:44,540
Yes.

627
00:37:44,540 --> 00:37:46,650
What is Fibonacci series?

628
00:37:46,650 --> 00:37:47,900
AUDIENCE: [INAUDIBLE]

629
00:37:50,150 --> 00:37:50,650
PROFESSOR: OK.

630
00:37:50,650 --> 00:37:51,150
Yeah.

631
00:37:51,150 --> 00:37:52,650
That's great.

632
00:37:52,650 --> 00:38:00,020
So return say F of n minus
1 plus F of n minus 2.

633
00:38:00,020 --> 00:38:01,610
What is the Fibonacci series?

634
00:38:01,610 --> 00:38:03,920
You start from 0, you
add these elements.

635
00:38:03,920 --> 00:38:04,740
So 1.

636
00:38:04,740 --> 00:38:06,710
You add last two elements, 2.

637
00:38:06,710 --> 00:38:08,200
You add last two elements, 3.

638
00:38:08,200 --> 00:38:09,450
You add last two elements, 5.

639
00:38:13,030 --> 00:38:14,600
So you add last two elements.

640
00:38:14,600 --> 00:38:19,080
So if you want to find F of n,
you return F of n minus 1 and

641
00:38:19,080 --> 00:38:21,410
plus F of n minus 2.

642
00:38:21,410 --> 00:38:26,880
But here since you have two
elements, or you need to

643
00:38:26,880 --> 00:38:30,450
access two previous elements,
you need to define you base

644
00:38:30,450 --> 00:38:31,700
case accordingly.

645
00:38:33,640 --> 00:38:40,820
So for your base case,
F of 0, is what?

646
00:38:43,526 --> 00:38:45,800
Actually, that depends
on whether you

647
00:38:45,800 --> 00:38:48,135
start here or here.

648
00:38:48,135 --> 00:38:49,385
OK?

649
00:38:51,860 --> 00:38:53,110
You could do this.

650
00:38:59,970 --> 00:39:03,940
I'll go through an interesting
recursive example.

651
00:39:29,350 --> 00:39:30,040
OK.

652
00:39:30,040 --> 00:39:32,810
It's called a recursive
exponentiation.

653
00:39:32,810 --> 00:39:37,720
So I actually you can do an
exponentiation through

654
00:39:37,720 --> 00:39:39,940
recursive multiplication.

655
00:39:39,940 --> 00:39:43,800
Suppose you want to find 3
to the power, say, of 10.

656
00:39:49,546 --> 00:39:50,880
Then how would you do that?

657
00:39:53,970 --> 00:39:58,300
You start by expressing
it in terms of its

658
00:39:58,300 --> 00:39:59,800
simpler version, right?

659
00:39:59,800 --> 00:40:02,630
So it will be 3 into
3 to the power 9.

660
00:40:02,630 --> 00:40:05,280
Sorry, 3 to the power 9.

661
00:40:05,280 --> 00:40:06,530
OK?

662
00:40:11,230 --> 00:40:17,240
So if you want to find that
nth power of number M, you

663
00:40:17,240 --> 00:40:24,490
would say M into M to
the power n minus 1.

664
00:40:24,490 --> 00:40:26,460
So now you have your
recursive case.

665
00:40:29,160 --> 00:40:30,410
What is the base case?

666
00:40:34,060 --> 00:40:36,890
AUDIENCE: [INAUDIBLE]

667
00:40:36,890 --> 00:40:38,775
PROFESSOR: Yes, if
n is equal to 0.

668
00:40:41,720 --> 00:40:48,260
In Python you would test this
by two equal signs.

669
00:40:48,260 --> 00:40:51,694
If n is equal to 0, then what?

670
00:40:51,694 --> 00:40:52,560
AUDIENCE: Return 1.

671
00:40:52,560 --> 00:40:53,810
PROFESSOR: Return 1.

672
00:40:57,574 --> 00:40:59,480
OK?

673
00:40:59,480 --> 00:41:03,492
Why we have only one
base case here?

674
00:41:03,492 --> 00:41:05,250
AUDIENCE: [INAUDIBLE]

675
00:41:05,250 --> 00:41:05,596
PROFESSOR: Sorry?

676
00:41:05,596 --> 00:41:07,340
AUDIENCE: [INAUDIBLE]

677
00:41:07,340 --> 00:41:07,810
PROFESSOR: Yes.

678
00:41:07,810 --> 00:41:09,660
And because you're accessing
only one

679
00:41:09,660 --> 00:41:11,350
previous series, right?

680
00:41:11,350 --> 00:41:12,600
Fibonacci series.

681
00:41:14,880 --> 00:41:18,180
Similarly, if you want to
multiply something--

682
00:41:18,180 --> 00:41:22,670
OK, here what we did is we
replaced this operator by

683
00:41:22,670 --> 00:41:26,280
recursively using
this operator.

684
00:41:26,280 --> 00:41:28,700
OK?

685
00:41:28,700 --> 00:41:33,120
Can you do the multiplication
by recursive addition?

686
00:41:33,120 --> 00:41:38,360
So can you replace this operator
by this operator?

687
00:41:38,360 --> 00:41:39,360
Yes.

688
00:41:39,360 --> 00:41:45,020
So how would you do this, for
example say 3 into 5?

689
00:41:45,020 --> 00:41:46,270
So how would you do it here?

690
00:41:49,470 --> 00:41:49,970
Tell me.

691
00:41:49,970 --> 00:41:51,220
What would this?

692
00:41:55,960 --> 00:41:58,790
AUDIENCE: 3 plus 3 times 4.

693
00:41:58,790 --> 00:41:59,220
PROFESSOR: 3 plus?

694
00:41:59,220 --> 00:42:00,510
AUDIENCE: 3 times 4.

695
00:42:00,510 --> 00:42:02,230
PROFESSOR: 3 times 4.

696
00:42:02,230 --> 00:42:03,480
Here?

697
00:42:11,630 --> 00:42:13,549
Come on, it's simple, right?

698
00:42:13,549 --> 00:42:14,910
AUDIENCE: [INAUDIBLE]

699
00:42:14,910 --> 00:42:17,154
PROFESSOR: I'm insulting you.

700
00:42:17,154 --> 00:42:18,630
OK.

701
00:42:18,630 --> 00:42:20,230
What's the base case?

702
00:42:20,230 --> 00:42:22,090
That is interesting.

703
00:42:22,090 --> 00:42:25,550
What is the base case
if n is equal to 0?

704
00:42:32,438 --> 00:42:35,882
AUDIENCE: [INAUDIBLE]

705
00:42:35,882 --> 00:42:37,850
PROFESSOR: OK.

706
00:42:37,850 --> 00:42:40,210
If n is equal to 0, that is 0.

707
00:42:40,210 --> 00:42:41,250
But that's fine.

708
00:42:41,250 --> 00:42:42,500
But there's another problem.

709
00:42:49,010 --> 00:42:52,930
The problem is you don't know
whether these values are

710
00:42:52,930 --> 00:42:54,620
positive or negative.

711
00:42:54,620 --> 00:42:57,600
So you can't just keep
on adding like this.

712
00:42:57,600 --> 00:42:58,850
This will work if
it's positive.

713
00:43:01,350 --> 00:43:03,860
But if it's negative, actually
you have to check.

714
00:43:03,860 --> 00:43:07,390
Which is sort of tricky
if you want to use the

715
00:43:07,390 --> 00:43:08,770
same recursive function.

716
00:43:08,770 --> 00:43:14,030
Otherwise you could have
an if condition here.

717
00:43:14,030 --> 00:43:17,120
If say n is greater
than 0, do this.

718
00:43:19,690 --> 00:43:25,010
Else-if you multiply n by minus
1 you negate that so it

719
00:43:25,010 --> 00:43:26,080
becomes positive.

720
00:43:26,080 --> 00:43:30,910
And do it the same way and
then that's the answer.

721
00:43:30,910 --> 00:43:32,370
So you could do that.

722
00:43:32,370 --> 00:43:36,780
But if you want to do it in the
same recursive case, then

723
00:43:36,780 --> 00:43:37,940
you had to follow this.

724
00:43:37,940 --> 00:43:39,420
If you have any questions,
come to the

725
00:43:39,420 --> 00:43:42,730
office hours on that.

726
00:43:42,730 --> 00:43:46,175
The final question is, final
example is, the Hanoi example.

727
00:43:49,640 --> 00:43:50,490
OK.

728
00:43:50,490 --> 00:43:51,740
This is very interesting.

729
00:43:57,890 --> 00:44:04,520
So here we have three towers;
source, target, and buffer.

730
00:44:07,580 --> 00:44:10,350
Suppose you have three disks.

731
00:44:10,350 --> 00:44:13,420
You want to move them from
source to target.

732
00:44:13,420 --> 00:44:16,200
And you can always have a
smaller disk on top of a

733
00:44:16,200 --> 00:44:18,250
bigger disk.

734
00:44:18,250 --> 00:44:19,670
Then how would you move?

735
00:44:19,670 --> 00:44:20,470
OK?

736
00:44:20,470 --> 00:44:25,010
So can you express this problem
in a simpler version?

737
00:44:25,010 --> 00:44:26,880
So now we have three disks.

738
00:44:26,880 --> 00:44:29,110
You want to move
them to target.

739
00:44:29,110 --> 00:44:31,710
So can you express it in
a simpler version?

740
00:44:34,320 --> 00:44:37,090
Come on.

741
00:44:37,090 --> 00:44:40,380
Just in plain English,
how would you do it?

742
00:44:40,380 --> 00:44:42,550
Without looking at
the program.

743
00:44:42,550 --> 00:44:43,950
Because Python is very robust.

744
00:44:43,950 --> 00:44:47,010
So if you read the program
you get it in English.

745
00:44:49,776 --> 00:44:53,890
So any ideas?

746
00:44:53,890 --> 00:44:55,210
OK.

747
00:44:55,210 --> 00:44:57,860
We have to here move the last
disk to target, right?

748
00:44:57,860 --> 00:44:59,750
But that's the hardest part.

749
00:44:59,750 --> 00:45:02,720
So before doing that you have
to move this somewhere else.

750
00:45:02,720 --> 00:45:04,120
So let's move it to buffer.

751
00:45:07,960 --> 00:45:10,360
Done.

752
00:45:10,360 --> 00:45:13,600
How would you move this?

753
00:45:13,600 --> 00:45:16,496
Now you can move it to target.

754
00:45:16,496 --> 00:45:18,230
OK.

755
00:45:18,230 --> 00:45:20,634
Now what would you do?

756
00:45:20,634 --> 00:45:21,884
AUDIENCE: [INAUDIBLE]

757
00:45:25,394 --> 00:45:25,880
PROFESSOR: OK.

758
00:45:25,880 --> 00:45:26,460
Sorry.

759
00:45:26,460 --> 00:45:27,870
Yeah, OK?

760
00:45:27,870 --> 00:45:28,250
No.

761
00:45:28,250 --> 00:45:29,317
What would you do?

762
00:45:29,317 --> 00:45:30,780
AUDIENCE: [INAUDIBLE]

763
00:45:30,780 --> 00:45:35,270
PROFESSOR: You can only move
this to the buffer, right?

764
00:45:35,270 --> 00:45:36,330
AUDIENCE: [INAUDIBLE]

765
00:45:36,330 --> 00:45:36,360
[?

766
00:45:36,360 --> 00:45:37,610
PROFESSOR: Not the target.

767
00:45:39,820 --> 00:45:40,920
OK.

768
00:45:40,920 --> 00:45:42,170
So we made some mistake
earlier.

769
00:45:44,888 --> 00:45:46,250
Remember?

770
00:45:46,250 --> 00:45:49,300
The problem is because we didn't
think recursively.

771
00:45:53,720 --> 00:45:55,080
OK.

772
00:45:55,080 --> 00:45:56,330
Let's think recursively.

773
00:46:01,350 --> 00:46:03,751
Source, target, buffer.

774
00:46:03,751 --> 00:46:05,540
Sorry.

775
00:46:05,540 --> 00:46:07,200
Suppose we have only one disk.

776
00:46:10,360 --> 00:46:13,630
Then you can simply
move to target.

777
00:46:13,630 --> 00:46:14,570
OK?

778
00:46:14,570 --> 00:46:17,450
So a condition is if there's
only one disk, just move it to

779
00:46:17,450 --> 00:46:18,700
the target.

780
00:46:21,350 --> 00:46:27,960
So if n is equal to 1
we always move from

781
00:46:27,960 --> 00:46:30,745
move source to target.

782
00:46:33,350 --> 00:46:34,760
OK?

783
00:46:34,760 --> 00:46:36,010
Suppose you have two.

784
00:46:41,330 --> 00:46:44,410
Then what would you do?

785
00:46:44,410 --> 00:46:45,870
You move the top
one to buffer.

786
00:46:50,970 --> 00:46:52,610
OK?

787
00:46:52,610 --> 00:46:56,870
So move source to buffer.

788
00:47:02,560 --> 00:47:05,135
Then you move the next disk
from source to target.

789
00:47:07,990 --> 00:47:11,720
So now it's source to target.

790
00:47:15,660 --> 00:47:19,480
And finally you move
it from the buffer.

791
00:47:19,480 --> 00:47:20,730
All right?

792
00:47:24,130 --> 00:47:28,590
Now we have a very nice
recursive case.

793
00:47:28,590 --> 00:47:34,400
If you have two, we move from
source to buffer, then source

794
00:47:34,400 --> 00:47:36,660
to target, then from
buffer to target.

795
00:47:39,360 --> 00:47:45,600
So if you look at this example
I'm checking if

796
00:47:45,600 --> 00:47:48,060
n is equal to 1.

797
00:47:48,060 --> 00:47:53,180
If it is 1, just I'm moving
from source to target.

798
00:47:53,180 --> 00:47:55,920
If it is greater than
n, what would I do?

799
00:47:55,920 --> 00:47:58,150
And that first assert statement
is just there to

800
00:47:58,150 --> 00:47:59,460
make sure that n is
greater than 0.

801
00:47:59,460 --> 00:48:01,690
Otherwise it's meaningless,
right?

802
00:48:01,690 --> 00:48:02,830
You need to have this.

803
00:48:02,830 --> 00:48:05,660
You can't have negative this.

804
00:48:05,660 --> 00:48:12,630
So what would be the next
step if you have

805
00:48:12,630 --> 00:48:13,760
more than one disk?

806
00:48:13,760 --> 00:48:14,980
Suppose you have two disks.

807
00:48:14,980 --> 00:48:16,810
Then what would you do?

808
00:48:16,810 --> 00:48:19,590
You move the top disk
or whatever on

809
00:48:19,590 --> 00:48:22,320
the top to the buffer.

810
00:48:22,320 --> 00:48:26,270
For this simple example
it was just one disk.

811
00:48:26,270 --> 00:48:30,120
But suppose you had more disks
on top of the last disk?

812
00:48:30,120 --> 00:48:32,280
So you would have moved
all of them to buffer.

813
00:48:32,280 --> 00:48:33,760
You don't have to worry
how you move it.

814
00:48:33,760 --> 00:48:36,050
But you have to move
it anyway.

815
00:48:36,050 --> 00:48:39,830
After moving that, you can
leisurely move this big disk

816
00:48:39,830 --> 00:48:42,420
to the top, to the target.

817
00:48:42,420 --> 00:48:43,420
OK?

818
00:48:43,420 --> 00:48:48,510
Finally, you bring back all
of them here, right?

819
00:48:48,510 --> 00:48:52,340
For you first operation, for
your first operation, from

820
00:48:52,340 --> 00:48:54,890
source to target, you have
to move all of them, the

821
00:48:54,890 --> 00:48:56,150
[UNINTELLIGIBLE].

822
00:48:56,150 --> 00:48:57,910
You could have used target
as your buffer.

823
00:49:00,622 --> 00:49:01,530
OK?

824
00:49:01,530 --> 00:49:10,450
So that's why in this line I'm
using source as source.

825
00:49:10,450 --> 00:49:14,030
But the second argument, which
should have been the target,

826
00:49:14,030 --> 00:49:17,580
is now buffer because my current
target is buffer for

827
00:49:17,580 --> 00:49:20,480
the top n minus 1 disk.

828
00:49:20,480 --> 00:49:23,500
But my buffer is
now the target.

829
00:49:23,500 --> 00:49:23,550
OK.

830
00:49:23,550 --> 00:49:28,240
Because I can use the target
as buffer for the movement.

831
00:49:28,240 --> 00:49:33,204
Then I moved from source to the
target, the last big disk.

832
00:49:33,204 --> 00:49:34,090
OK?

833
00:49:34,090 --> 00:49:36,210
For that I can use buffer
as my buffer.

834
00:49:39,290 --> 00:49:43,170
Then finally I bring back from
buffer to target using source

835
00:49:43,170 --> 00:49:44,420
as my buffer.

836
00:49:47,478 --> 00:49:48,850
OK?

837
00:49:48,850 --> 00:49:52,240
So the thing is if you want to
have a recursive problem you

838
00:49:52,240 --> 00:49:54,110
can do it in two ways.

839
00:49:54,110 --> 00:49:59,830
One thing, you can start
thinking how to express this

840
00:49:59,830 --> 00:50:02,500
problem in its simpler version
like how you thought about the

841
00:50:02,500 --> 00:50:04,430
Fibonacci series,
for instance.

842
00:50:04,430 --> 00:50:08,700
Or else, you can start from
its base case, the most

843
00:50:08,700 --> 00:50:10,310
fundamental situation.

844
00:50:10,310 --> 00:50:12,810
So here it's n equal to
1, but this doesn't

845
00:50:12,810 --> 00:50:14,350
give you enough context.

846
00:50:14,350 --> 00:50:17,100
So you go to the next level, n
is equal to 2, and you have

847
00:50:17,100 --> 00:50:18,720
the answer.

848
00:50:18,720 --> 00:50:19,970
Right?