Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2021-10-12T19:31:00+05:30

====== heap ======
Created Tuesday 12 October 2021

===== Priority Queue =====
* implements a set S of elements
* each elelemnt is associated with a key

===== Specs of the abstract data type =====
* insert (S,x)
* max(S)
* extract_max(S)
* increase_key(S,x,k)

===== implementation =====
* array visualized as a nearly complete binary tree.
				a_{1}
			/         \
		  a_{2}            a_{3}
		/   \	      /   \ 
	   a_{4}    a_{5}     a_{6}       a_{7}
* root = a_{1}
* parent(i)=i/2
* left(i)=2i
* right(i)=2i+1

==== max-heap property ====
key of node ≥ keys of its children

==== max-heap property ====
key of node ≤ keys of its children

===== Heap Operations =====

==== all of these need to maintain a represation invariant, say max-heap property ====
1. build_max_heap: produce max-heap from unordered array.
2. max_heapify: correct single violation of heap property in a subtree's root.

=== max heapify ===
* input : Array A and index i
* assumptions :
	* tress rooted @ left(i) and right(i) are max heaps.
* it performs swaps recursively → A[i] is swapped with its larger child, and max_heapify is called on at that child position. Till the position in question is a max-heap
* O(lg(n)) → number of levels in tree.

=== build max heap ===
```
for i = n/2 down to 1
	do max_heapify(A,i)
```
* n/2 is the first level above the leaves.
* leaves are already max-heaps
* max_heapify takes O(!) time for nodes that are just above the leaves
* in general O(l) time for nodes that are l levels above the leave.
* n/4 nodes @ level 1, n/8 @ level 2 ....
* T = 1C*(n/4) + 2C*n/8+ .....lg(n)C*1
	* putting n/4=2^{k}
	* C*2^{k}(1/2+2/2^{2} +.....(k+1)/2^{k}) → convergent series bounded by constant
	* O(2^{k}) == O(n)
