Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2021-10-12T21:01:06+05:30

====== binary search tree ======
Created Tuesday 12 October 2021

===== Scheduling =====

==== Runway Resolution Problem ====
* Assume a airport with a single runway
* Reservations for future landings
* Reserve request specifies landing time t.
* Add **t** to the set **R** of landing times if no other landings are scheduled within **k** miniutes.
* Remove **t **from set R after plane lands
* efficiency required : O(lg(n))

==== trying different ADTs ====
1. unsorted array : 
	* check and insert : O(n)-->
2. sorted array :
	* searching for index → O(lg(n))
	* inserting → requires shifting → O(n) time
3. Heaps: min/max
	* the invariant is weak.
	* here inserting is pretty neat, but
	* searching an element that is beyond the k-neighboured of t takes O(n) time.


===== BST specs =====
* it is a tree, unlike heap, which was just an array
* collection of pointers forming a tree.
* each node has 3 pointers 
	1. parent
	2. left child
	3. right child
* Invariant:
	* for all nodes x if y is in the left subtree of x,
		* key(y)≤key(x)
	* similarly, for right subtree
		* key(y)≥key(x)
* check takes O(h) time where h is the tree-height.
	* check and search can be performed together using the binary search algorithm on the tree.

==== Augmentations ====
compute **Rank**(t) → number of landings at times ≤ t.

=== Augment the BST structure ===
* associate two keys to each node.
* the other one being the subtree size.
* increment it for each node in insertion path whille adding a node.
* Ranks

==== BST Operations ====
1. find_min() : go to the left till leaf → O(h)
2. next_larger(x)
3. insert
4. delete
5. rotation:
	* left rotate: put right at node's position, self is put as left child of new root, and left child of original right is now the new right child of self.
	* right rotate: inverse of left rotate

