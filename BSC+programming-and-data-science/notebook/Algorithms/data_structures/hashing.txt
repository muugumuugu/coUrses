Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2021-10-14T01:16:55+05:30

====== hashing ======
Created Thursday 14 October 2021

===== Dictionary ADT =====
* maintain set of items, each with a unique key
* insert & delete item.
* search(key): no successor/predcessor reporting, reports key error if not found
* constant time for each operation

==== Pythonic Model: ====
* D[key] ~ search
* D[key]=val ~ insert
* del D[key] ~ delete
* stored as item → (key,value) pair


=== Naive approach : Direct Access Table ===
store items in an array indexed by a key.
* keys may not be integers.
	* solve by prehash mapping keys to non-negative integer
	* in theory jeys are finite an disrete : string of bits
* gigantic memory hog since array is sequentially stored.

== Pre-Hashing in Python ==
//hash(x) → //pre hashes x.
* ideally: hash(x)=hash(y) ↔ x=y
* can be implemented for memory static variables as hash(x) = address id.

== Hashing : Key Reducal ==
* reduce universe of all keys down to a reasonable size m for a //hash table.//
* idea : m=O(n)
* but PHP enforces that there would be multiple collisions( equal hashes for diff keys )

== Chaining ==
* in a slot in the hash table store a linked list of keys that map to the same hash.
* worst case : O(n) → all items have same hash.

==== Simple Uniform Hashing ====
each key is equally likely to be hashed to **any ** slot of the hash table.

=== Analysis: ===
* load factor
	* expected length of chain for n keys, m slots → n/m
	* O(1) if m=O(n)
* running time for search = O(1 + n/m) → computing hash and then walking the linked list.
