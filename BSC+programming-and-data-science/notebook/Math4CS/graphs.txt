Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6

====== Graphs ======
* Graph = (V,E)
	* V = set of vertices / nodes
	* E = set of edges, is a subset of VxV, that is, it is a binary relation on the nodes
* Directed Graph
	* (v,v') ∈ E doesnot ⇒ (v',v) ∈ E
* Un-Directed Graph
	* eg -freindships
	* (v,v') ∈ E  ⇒ (v',v) ∈ E
	* effectively (v,v') is the same edge as (v',v)

===== degree =====
d(v)= number of edges incident on i

===== tree =====
1. minimally connected graph.
2. edges explored by a BFS form one tree per component.
3. collection of trees= forest.
4. N vertice tree necessarily has n-1 edges.
5. acyclic graph.

* any non tree edge creates a cycle.

===== non-tree edges =====
1. Forward edges
2. Backward edges -- form cycles
3. Cross edged - across branches

===== Directed Acyclic Graphs =====
* directed cycle:  must follow *one* direction only.
* DAG - no directed cycles
	* tasks and dependenceies - constrain on sequences

===== Path =====
* sequence of vertices connected by edges.
* no vertice is re[eated
* every adjacent vertice in the seqeunce share an edge

===== walk =====
* path with freedom of repeating vertices.


==== reachable vertex ====
* v is reachable from u if there is a path from   u to v.

==== connected graph ====
* example flight landings
* every vertice is reachable from every other vertice
* strong connectiton:
	* two vertices have both paths from v1 to v2 and v2 to v1.

===== graph analysis =====

==== map coloring ====
* example min classroom for overlapping timeslots
* states that share a border should be different color
* create a graph
	* each state = vertex
	* edge relation = sharing border
	* problem becomes assigning colors to nodes so that endpoins of an edge have diff colors.
	* for planar graphs , 4 colors suffice. -- Four color theorem

==== vertex covering ====
* example= installing cct cameras
	* vertices = intersections of coridors
	* Edges = corridor segments connecting intersections
* smallest set of V to cover all the edges

==== independent set ====
* example group dances
	* vertices = dances
	* edges = have common dancers
	* dances we can have so as to have one dancer perform only once
* set of vertices such as none of them share an edge

==== matching ====
* example - class project
	* group of freinds
* subset of E of mutually disjoint edges
* maximal matching, max cardinality matching
* perfect matching, covers all vertices.

===== computational representation =====

==== adjacency matrix ====
* map vertex names to integer indices
* Matrix entry (i,j) = 1 if (vᵢ,vⱼ) is an edge , 0 otherwise
* columns represent incoming edges
* rows represent outgoing edges
* wastes lots of space because typically |E|<< n²

==== adjacency list ====
* list of neighbour indices for any vertices
* time costly for neighbourhood scanning, etc.

===== Exploration =====

==== Breadth-first neighbour search ====
* do it level by level
* implement using queue(FIFO)
* visit closest ( 1-step away) neighbours and mark them for exploration by adding them to the queue.
* repeat closest neighbour exploration for each item in queue, dequeuing it and flaging it as visited,till queue is empty, adding to queue only unvisited neighbours.
* necessarily mark each visited node with a flag so as to not loop infinitely.
* to store and extract path --> store parents, while exploring nearest neighbours, store parent in addition to flagging the neighbour visited.
* can also store level insted of visited flag --> unvisited =level -1
* on exploration of each item's nearest neighbours, while adding parent increment level.



===== Depth-first search =====
* implement using stack (LIFO)
* explore fully till the end a neighbour to its fring end and then back track to the parent and explore its other neighbours
* keep backtracking and exploring till u reach back the root, and it has no new neighbours to explore.


===== applications of explorations =====

==== shortest paths ====

==== unweighted graph ====
From bfs parent list --> get shortest path of unweighted graph.

==== weighted graph ====

=== Djkstras Algorithm ===
for +vely weighted graph.
initially start with infinite distances and will try to improve them step by step.
* Mark all nodes unvisited. Create a set of all the unvisited nodes called the unvisited set.
* Assign to every node a tentative distance value: set it to zero for our initial node and to infinity for all other nodes.
	* The tentative distance of a node v is the length of the shortest path discovered so far between the node v and the starting node
	* Since initially no path is known to any other vertex than the source itself (which is a path of length zero), all other tentative distances are initially set to infinity.
* Set the initial node as current.
* For the current node, consider all of its unvisited neighbors and calculate their tentative distances through the current node.
* Compare the newly calculated tentative distance to the current assigned value and assign the smaller one.
* When we are done considering all of the unvisited neighbors of the current node, mark the current node as visited and remove it from the unvisited set. A visited node will never be checked again.
* If the destination node has been marked visited (when planning a route between two specific nodes) or if the smallest tentative distance among the nodes in the unvisited set is infinity (when planning a complete traversal; occurs when there is no connection between the initial node and remaining unvisited nodes), then stop. The algorithm has finished.
* Otherwise, select the unvisited node that is marked with the smallest tentative distance, set it as the new current node, and go back to step 3.


=== Belman Ford ===
* works as long as there are no negative cycles.
* consider **D(j)** to be the minumum distance known so far from the source vertex-*0* to vertex *j*
* Set D(0)=0, obiously and rest to infinty since no paths are known as of yet
* consider all edges, for any starting vertex, consider all edges outgoing from it and put into neighbours the distance to it through the current vertex if it is lower than the distance already associated.
* to make sure we loop thru all vertices doing so. --> n-1 iterations.
* do another update looping thru all edges --> if distance doesnot converge, then there must be a negative cycle.

==== decomposition ====
finding components of a graph. (mutually unconnected maximal connected subgraphs)
a. starts bfs/dfs at vertex 0  -- initialize component number 0 and assign it to each node as u visit it.
b. increment component number and start scan on smallest unvisited node.
* gives strongly Connected Components in directed graphs

==== detecting cycles. ====
> walk that ends on the same vertex, without repeating an edge
* simple cycle - only repeated vertice is the start/end.
* maintain a DFS counter that is incremented both at start and end of exploring a node
* assign nodes these entry and exit numbers

==== Topological sort ====
* given a DAG, enumerate V=\{0,1,2,...n-1\} such that ∀ (i,j) ∈ E , i appears before j.
* transitivity holds in scheduling therefore there is no way to topologically sort a directed graph with cycle
* all DAGS can be topologically sorted .
	* a vertex with no dependencies has in degree =0
		* every DAG has a zero-dependency vertex.
		* else in parent backtracking there seems to be a cycle in the graph
	* algorithm
		* choose zero vertex, add it to the enumeration,
		* delete it and its edges from the DAG (update the indegrees of its neighbours),
		* resulting in another DAG.
		* repeat till the reulting DAG is a null graph.

==== find *cut vertices* ====
> vertices which connect the graph, on deleting the graph no longer remains connected.

==== find bridge ====
> edges that connect the graph.

==== classifying tree edges using dfs numbers ====
1. forward :Interval  \[pre(start),post(start)\] contains \[pre(end),post(end)\]
2. backward:Interval  \[pre(end),post(end)\] contains \[pre(start),post(start)\]
3. cross :Intervals  \[pre(start),post(start)\] & \[pre(end),post(end)\] are disjoint.

==== Longest Paths in DAGs ====
> time it takes to finish a task set described by constraint DAG.
>> longest-path-to(i)= 1 + max\{longest-path-to(j) ∋ (j,i)∈E\}
>>> compute in topological order to be sure of dynamic programming setup.
>> longest-path-to(i)=0 for inititial graph's zero-in vertices.

```
Initialize dist[] = -∞, -∞, ... and dist[s] = 0 where s is the source vertex.
Create a topological order of all vertices.
Do following for every vertex u in topological order.
	Do following for every adjacent vertex v of u
		if (dist[v] < dist[u] + weight(u, v))
			dist[v] = dist[u] + weight(u, v)
```

===== adjacency powers. =====
* Powers of adjacency matrix represent adjacency in terms of existence of paths with length=power.
* A¹= adjacent vertices.
* Aᵏ=aᵢⱼ, aᵢⱼ =number of paths of length k from vᵢto vⱼ.
* makes sense coz aᵢⱼ=∑aᵢₖaₖⱼ = number of pairs for which ∃  k-1 paths from i to k and k to j = number of k-paths from i to j. Beautiful.


===== Transitive Closure =====
* super graph where all reachable verices from any vertex are adjacent to it.
* simply put, it appends to edge set all edges that would be in it if it was transitive.
* transitive closure relation matrix, for each entry = 1 if entry(i,j)>0 in any of the n-1 powers of adjacency matrix.
* Or simlply use AND and OR instead of x and + to just find k-adjacency using Aᵏ.
	* A⁺=A¹+A²+...Aⁿ⁻¹

==== Floyd–Warshall algorithm ====
* Consider Bᵏ[i,j]=1 if ∃ a path from i to j via vertices {0,1,...k-1}
* B⁰ obviously is Adjacency Matrix.

=== all-pairs shortest distance ===

===== Minimum Cost Spanning Trees =====
subgraph that touches all vertices, and is a tree, and sum of weights is minimum.

==== Minimum Seperator Lemma ====
* Let V be partitioned into 2 non-empty sets U and W
* if e=(u,w) is the minimum edge connecting U and W ), then every MCST must include e.
* proof obvious via contradriction

==== Prim's Algorithm ====
* builds the tree bottom up, connected.
* start with smallest edge and grow tree.

1. Initialize a tree with a single vertex, chosen arbitrarily from the graph.
2. Grow the tree by one edge:
	* of the edges that connect the tree to vertices not yet in the tree, find the minimum-weight edge that doesnot create a cycle, and transfer it to the tree.
3. Repeat step 2 (until all vertices are in the tree).
	* n-2 iterations

==== Kruskal's Algorithm ====
> connects disjoint pieces top down into a tree.
>> scan edges in asc order of weight to connect components without forming cycles.
* create a forest F (a set of trees), where each vertex in the graph is a separate tree
	* create a set S containing all the edges in the graph
	* while S is nonempty and F is not yet spanning
		* remove an edge with minimum weight from S
		* if the removed edge connects two different trees then add it to the forest F, combining two trees into a single tree
* At the termination of the algorithm, the forest forms a minimum spanning forest of the graph. If the graph is connected, the forest has a single component and forms a minimum spanning tree.
